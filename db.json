{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"826cee09762eb73f61023110739d6dce72d9059a","modified":1510034760000},{"_id":"source/CNAME","hash":"a8b9838eb928d0a47a31f71b25aa986ad18e3878","modified":1509793757000},{"_id":"source/_drafts/2013-12-22-Summary-Of-2013.md","hash":"bc8cbd14210f59da7a2194e1067426c07969b173","modified":1509793757000},{"_id":"source/_drafts/2013-12-30-Does-AppleCare-Plan-Worth.md","hash":"8698e1708c5d9fc4ed59029e7eb9447e30a91772","modified":1509793757000},{"_id":"source/_drafts/2014-04-15-token-description.md","hash":"4b0574539c9adb89202d23f5add63f952b9aa0b3","modified":1509793757000},{"_id":"source/_drafts/2014-12-06-Javascript-Clorse.md","hash":"b7d77392821514c356c6615bdefdc03816933055","modified":1509793757000},{"_id":"source/_drafts/2015-04-09-Become-A-FE-Prepare.md","hash":"fd44533ba810f4f84b96fb1465f699a29e38094e","modified":1509793757000},{"_id":"source/_drafts/2015-05-11-The-Meaning-Of-Travel.md","hash":"ba026389c2d206ff596f9ef084f685a1e525f330","modified":1509793757000},{"_id":"source/_drafts/2015-12-26-IKEA-JIONG.md","hash":"1c200714d1ef348b9f71845de7d2678b7c41f1aa","modified":1509793757000},{"_id":"source/_drafts/2015-12-27-MY2015.md","hash":"8157257fc0c5fd3634f73418a1f072d083792fa6","modified":1509793757000},{"_id":"source/_drafts/2016-06-03-How-to-Write-Maintainable-JavaScript.md","hash":"fbbdd4885f34ecb48f8d140fe4ec069fc5c61aa0","modified":1509793757000},{"_id":"source/_drafts/2016-06-20-WANQU-Essential-Security-for-Linux-Servers.md","hash":"f54aa16a362d6f28191202f0c3b2ef1f25768aba","modified":1509793757000},{"_id":"source/_drafts/2016-06-21-WANQU-I-hate-the-news.md","hash":"19e99637c401eb6339ff01eac55d881f372be003","modified":1509793757000},{"_id":"source/_drafts/2017-01-04-About-Meta.md","hash":"1681d5d7a7b7509e18a2ace9fb17d7fc71988c3f","modified":1509793757000},{"_id":"source/_images/favicon.ico","hash":"8d856ecaf48ac8a8fb65a6779ab4923d114aff3f","modified":1509793757000},{"_id":"source/_posts/2013-11-28-First-Blog.md","hash":"f0f7d6ad42e75453ff4238a0b7648666a38b3a6c","modified":1509793757000},{"_id":"source/about/index.md","hash":"689d33412236342c6ba1baf57ff24d92d7b4f2d9","modified":1509793757000},{"_id":"source/_posts/2013-12-04-Finished-the-book.md","hash":"9b665405ade75c6bf4b446338a1f2087fe1a3343","modified":1509793757000},{"_id":"source/_posts/2013-12-05-Eassy-Programmer.md","hash":"19bb78a9183dc1bbf280895c62b6be4ac73072a9","modified":1509793757000},{"_id":"source/_posts/2014-01-10-The-Summary-of-At.md","hash":"f56ad19791015ec5447622f5a4c3ff0afdb624fb","modified":1509793757000},{"_id":"source/_posts/2014-03-20-Read-The-Book-Of-Zhihu.md","hash":"2f3cbdb36a995df1762398dcfe58ed451c4faf31","modified":1509793757000},{"_id":"source/_posts/2014-04-12-Misfit-Shine.md","hash":"a561595afe702b4f5332fd5e53fab776fca44648","modified":1509793757000},{"_id":"source/_posts/2014-06-06-Java-Collection-Review.md","hash":"76d4683a60fcc41e3fb23bfeb6608b2f8bbd5b0f","modified":1509793757000},{"_id":"source/_posts/2014-06-08-Study-Swift-1.md","hash":"b2065ddc5bfaca283338fa1759665f6efd0b92c0","modified":1509793757000},{"_id":"source/_posts/2014-06-19-Mac-Tool-Series-1.md","hash":"240b11cb2b9a2c2844d7226803c4518267018837","modified":1509793757000},{"_id":"source/_posts/2014-06-28-How-To-Connect-Internet-With-VPN.md","hash":"4c75ec2d1742440c4a0d07e40ff7b998dbd01825","modified":1509793757000},{"_id":"source/_posts/2014-11-25-OSC-Party.md","hash":"a4c4f5f54b7ac118ad5a4a9331c2d177ed58b32a","modified":1509793757000},{"_id":"source/_posts/2015-06-27-Question-Of-Front-End.md","hash":"382621de744e25eee73363be77ccb2c961d9df71","modified":1509793757000},{"_id":"source/_posts/2015-07-19-Try-My-Best.md","hash":"a8d990736c11475d5c5c49bc98fb8bce282d3a1a","modified":1509793757000},{"_id":"source/_posts/2015-07-26-Jul-And-Aug.md","hash":"4040ab7da011dc283c3f1d4ddad200f6e5e8b466","modified":1509793757000},{"_id":"source/_posts/2015-11-22-Notes-Of-360FE-Lesson.md","hash":"0709805646fe88060953ca68fb83222b7c483299","modified":1509793757000},{"_id":"source/_posts/2016-05-19-WANQU-Program-Beginning.md","hash":"dd93d986aab717931084ea97fa15a314915950e5","modified":1509793757000},{"_id":"source/_posts/2016-05-31-Simple-HTTP-Server-on-OSX.md","hash":"4a937a1e6957f03be26606dc264c1227e5d82b57","modified":1509793757000},{"_id":"source/_posts/2016-06-17-NPM-vs-Bower-vs-Browserify-vs-Gulp-vs-Grunt-vs-Webpack.md","hash":"9f769cf50af603431e08aae93601d4a75261a01d","modified":1509793757000},{"_id":"source/all-categories/index.md","hash":"3d47d4e31035e3c8d960730f36bd3ad27f88e9be","modified":1509793757000},{"_id":"source/all-archives/index.md","hash":"634c7e0b6841e3cdbb53b62fc5db80e1ad3a69f2","modified":1509793757000},{"_id":"source/all-tags/index.md","hash":"a9092fa374dd3f5b8b5c72f02fa0b128309f91ed","modified":1509793757000},{"_id":"source/beanlab/index.md","hash":"9988c1031d4f27fb7143ade3c363288a148392b1","modified":1509793757000},{"_id":"source/links/index.md","hash":"5d61afe1e5079a24fdf7b32ea42946564e498183","modified":1509793757000},{"_id":"source/_drafts/2018-02-11-blog-translate-web-performance-optimization-with-webpack-from-google.md","hash":"6d89d26d8003e2c50b4fd737c92c66331bf28862","modified":1518578392738}],"Category":[{"name":"blog","_id":"cjc31n1el0004gey5tqbofl0m"},{"name":"数码生活","_id":"cjc31n1et000agey5f9i8mgg2"},{"name":"译文计划","_id":"cjc31n1f5000qgey5t5cxo51j"},{"name":"Note","_id":"cjc31n1fx001vgey5ln1v6e3r"}],"Data":[],"Page":[{"title":"About","comments":0,"date":"2016-06-30T10:15:41.000Z","_content":"\n## 关于我\n\n目前就职于 JDC（京东用户体验与设计中心）任前端工程师，前端新人小白，曾担任过 Java 服务端工程师，技术栈 Javascript, Nodejs, Java ...\n\n## About Me\n\n[About Me Page](https://about.me/bean_lee)\n\n## Weibo\n\n[Weibo](http://weibo.com/callmemrbean)\n\n## Instgram\n\n[Beanlee](https://instagram.com/beanlee2020)\n\n## Links\n\n* [山药蛋](http://www.caosen.me)\n* [三木的知乎专栏](http://zhuanlan.zhihu.com/sensen)\n* [LOVEKY](https://loveky.github.io/)","source":"about/index.md","raw":"---\ntitle: About\ncomments: false\ndate: 2016-06-30 18:15:41\n---\n\n## 关于我\n\n目前就职于 JDC（京东用户体验与设计中心）任前端工程师，前端新人小白，曾担任过 Java 服务端工程师，技术栈 Javascript, Nodejs, Java ...\n\n## About Me\n\n[About Me Page](https://about.me/bean_lee)\n\n## Weibo\n\n[Weibo](http://weibo.com/callmemrbean)\n\n## Instgram\n\n[Beanlee](https://instagram.com/beanlee2020)\n\n## Links\n\n* [山药蛋](http://www.caosen.me)\n* [三木的知乎专栏](http://zhuanlan.zhihu.com/sensen)\n* [LOVEKY](https://loveky.github.io/)","updated":"2017-11-04T11:09:17.000Z","path":"about/index.html","layout":"page","_id":"cjc31n1ef0001gey588qhuz3a","content":"<h2 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h2><p>目前就职于 JDC（京东用户体验与设计中心）任前端工程师，前端新人小白，曾担任过 Java 服务端工程师，技术栈 Javascript, Nodejs, Java …</p>\n<h2 id=\"About-Me\"><a href=\"#About-Me\" class=\"headerlink\" title=\"About Me\"></a>About Me</h2><p><a href=\"https://about.me/bean_lee\" target=\"_blank\" rel=\"noopener\">About Me Page</a></p>\n<h2 id=\"Weibo\"><a href=\"#Weibo\" class=\"headerlink\" title=\"Weibo\"></a>Weibo</h2><p><a href=\"http://weibo.com/callmemrbean\" target=\"_blank\" rel=\"noopener\">Weibo</a></p>\n<h2 id=\"Instgram\"><a href=\"#Instgram\" class=\"headerlink\" title=\"Instgram\"></a>Instgram</h2><p><a href=\"https://instagram.com/beanlee2020\" target=\"_blank\" rel=\"noopener\">Beanlee</a></p>\n<h2 id=\"Links\"><a href=\"#Links\" class=\"headerlink\" title=\"Links\"></a>Links</h2><ul>\n<li><a href=\"http://www.caosen.me\" target=\"_blank\" rel=\"noopener\">山药蛋</a></li>\n<li><a href=\"http://zhuanlan.zhihu.com/sensen\" target=\"_blank\" rel=\"noopener\">三木的知乎专栏</a></li>\n<li><a href=\"https://loveky.github.io/\" target=\"_blank\" rel=\"noopener\">LOVEKY</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h2><p>目前就职于 JDC（京东用户体验与设计中心）任前端工程师，前端新人小白，曾担任过 Java 服务端工程师，技术栈 Javascript, Nodejs, Java …</p>\n<h2 id=\"About-Me\"><a href=\"#About-Me\" class=\"headerlink\" title=\"About Me\"></a>About Me</h2><p><a href=\"https://about.me/bean_lee\" target=\"_blank\" rel=\"noopener\">About Me Page</a></p>\n<h2 id=\"Weibo\"><a href=\"#Weibo\" class=\"headerlink\" title=\"Weibo\"></a>Weibo</h2><p><a href=\"http://weibo.com/callmemrbean\" target=\"_blank\" rel=\"noopener\">Weibo</a></p>\n<h2 id=\"Instgram\"><a href=\"#Instgram\" class=\"headerlink\" title=\"Instgram\"></a>Instgram</h2><p><a href=\"https://instagram.com/beanlee2020\" target=\"_blank\" rel=\"noopener\">Beanlee</a></p>\n<h2 id=\"Links\"><a href=\"#Links\" class=\"headerlink\" title=\"Links\"></a>Links</h2><ul>\n<li><a href=\"http://www.caosen.me\" target=\"_blank\" rel=\"noopener\">山药蛋</a></li>\n<li><a href=\"http://zhuanlan.zhihu.com/sensen\" target=\"_blank\" rel=\"noopener\">三木的知乎专栏</a></li>\n<li><a href=\"https://loveky.github.io/\" target=\"_blank\" rel=\"noopener\">LOVEKY</a></li>\n</ul>\n"},{"title":"all-categories","layout":"all-categories","comments":0,"_content":"","source":"all-categories/index.md","raw":"---\ntitle: \"all-categories\"\nlayout: \"all-categories\"\ncomments: false\n---\n","date":"2017-11-04T11:09:17.000Z","updated":"2017-11-04T11:09:17.000Z","path":"all-categories/index.html","_id":"cjc31n1ek0003gey5e01i3dt9","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"all-archives","layout":"all-archives","comments":0,"_content":"","source":"all-archives/index.md","raw":"---\ntitle: \"all-archives\"\nlayout: \"all-archives\"\ncomments: false\n---\n","date":"2017-11-04T11:09:17.000Z","updated":"2017-11-04T11:09:17.000Z","path":"all-archives/index.html","_id":"cjc31n1ep0007gey56qsg07wg","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"all-tags","layout":"all-tags","comments":0,"_content":"","source":"all-tags/index.md","raw":"---\ntitle: \"all-tags\"\nlayout: \"all-tags\"\ncomments: false\n---\n","date":"2017-11-04T11:09:17.000Z","updated":"2017-11-04T11:09:17.000Z","path":"all-tags/index.html","_id":"cjc31n1gn0047gey5cur5ajhj","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Bean Lab","layout":"beanlab","comments":0,"_content":"\n### UPDATE 2016-05-30\n\nBean 已经成功在2015年9月转岗JDC（京东用户设计与体验中心）专职做前端客户端的工作！希望这个实验室后面会有更多的体验demo出来。\n\n2015-05-30 17:34:04\n\n### Gift for my girlfriend\n\n2015年情人节送给女朋友的礼物，同时也感谢FlowerProject的作者\n\n[Heart](http://beanlee.com/lab/love/index_zh.html)\n\n2015-06-10 00:25:04\n\nBean 对前端和移动客户端很感兴趣，目前虽然还是的服务端的Java工程师，2014年7月也挤破头皮从传统软件业公司转到了互联网公司，暂时还在努力适应新环境，加班不见得减少但比以前更加坚定要抽时间做自己喜欢感兴趣的事，而这里就将成为 Bean 的实验室，在这里我会分享自己的阶段成果demo，也希望能够跟更多人分享和学习，让我们共同努力，为曾经吹过的牛逼奋斗！\n\n2014-08-17 17:57:57\n\n","source":"beanlab/index.md","raw":"---\ntitle: \"Bean Lab\"\nlayout: \"beanlab\"\ncomments: false\n---\n\n### UPDATE 2016-05-30\n\nBean 已经成功在2015年9月转岗JDC（京东用户设计与体验中心）专职做前端客户端的工作！希望这个实验室后面会有更多的体验demo出来。\n\n2015-05-30 17:34:04\n\n### Gift for my girlfriend\n\n2015年情人节送给女朋友的礼物，同时也感谢FlowerProject的作者\n\n[Heart](http://beanlee.com/lab/love/index_zh.html)\n\n2015-06-10 00:25:04\n\nBean 对前端和移动客户端很感兴趣，目前虽然还是的服务端的Java工程师，2014年7月也挤破头皮从传统软件业公司转到了互联网公司，暂时还在努力适应新环境，加班不见得减少但比以前更加坚定要抽时间做自己喜欢感兴趣的事，而这里就将成为 Bean 的实验室，在这里我会分享自己的阶段成果demo，也希望能够跟更多人分享和学习，让我们共同努力，为曾经吹过的牛逼奋斗！\n\n2014-08-17 17:57:57\n\n","date":"2017-11-04T11:09:17.000Z","updated":"2017-11-04T11:09:17.000Z","path":"beanlab/index.html","_id":"cjc31n1go0048gey56t2mcxwc","content":"<h3 id=\"UPDATE-2016-05-30\"><a href=\"#UPDATE-2016-05-30\" class=\"headerlink\" title=\"UPDATE 2016-05-30\"></a>UPDATE 2016-05-30</h3><p>Bean 已经成功在2015年9月转岗JDC（京东用户设计与体验中心）专职做前端客户端的工作！希望这个实验室后面会有更多的体验demo出来。</p>\n<p>2015-05-30 17:34:04</p>\n<h3 id=\"Gift-for-my-girlfriend\"><a href=\"#Gift-for-my-girlfriend\" class=\"headerlink\" title=\"Gift for my girlfriend\"></a>Gift for my girlfriend</h3><p>2015年情人节送给女朋友的礼物，同时也感谢FlowerProject的作者</p>\n<p><a href=\"http://beanlee.com/lab/love/index_zh.html\">Heart</a></p>\n<p>2015-06-10 00:25:04</p>\n<p>Bean 对前端和移动客户端很感兴趣，目前虽然还是的服务端的Java工程师，2014年7月也挤破头皮从传统软件业公司转到了互联网公司，暂时还在努力适应新环境，加班不见得减少但比以前更加坚定要抽时间做自己喜欢感兴趣的事，而这里就将成为 Bean 的实验室，在这里我会分享自己的阶段成果demo，也希望能够跟更多人分享和学习，让我们共同努力，为曾经吹过的牛逼奋斗！</p>\n<p>2014-08-17 17:57:57</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"UPDATE-2016-05-30\"><a href=\"#UPDATE-2016-05-30\" class=\"headerlink\" title=\"UPDATE 2016-05-30\"></a>UPDATE 2016-05-30</h3><p>Bean 已经成功在2015年9月转岗JDC（京东用户设计与体验中心）专职做前端客户端的工作！希望这个实验室后面会有更多的体验demo出来。</p>\n<p>2015-05-30 17:34:04</p>\n<h3 id=\"Gift-for-my-girlfriend\"><a href=\"#Gift-for-my-girlfriend\" class=\"headerlink\" title=\"Gift for my girlfriend\"></a>Gift for my girlfriend</h3><p>2015年情人节送给女朋友的礼物，同时也感谢FlowerProject的作者</p>\n<p><a href=\"http://beanlee.com/lab/love/index_zh.html\">Heart</a></p>\n<p>2015-06-10 00:25:04</p>\n<p>Bean 对前端和移动客户端很感兴趣，目前虽然还是的服务端的Java工程师，2014年7月也挤破头皮从传统软件业公司转到了互联网公司，暂时还在努力适应新环境，加班不见得减少但比以前更加坚定要抽时间做自己喜欢感兴趣的事，而这里就将成为 Bean 的实验室，在这里我会分享自己的阶段成果demo，也希望能够跟更多人分享和学习，让我们共同努力，为曾经吹过的牛逼奋斗！</p>\n<p>2014-08-17 17:57:57</p>\n"},{"title":"Links","date":"2015-06-12T18:41:14.000Z","_content":"\n* [山药蛋](http://www.caosen.me)\n* [三木的知乎专栏](http://zhuanlan.zhihu.com/sensen)","source":"links/index.md","raw":"title: Links\ndate: 2015-06-13 02:41:14\n---\n\n* [山药蛋](http://www.caosen.me)\n* [三木的知乎专栏](http://zhuanlan.zhihu.com/sensen)","updated":"2017-11-04T11:09:17.000Z","path":"links/index.html","comments":1,"layout":"page","_id":"cjc31n1go0049gey5pmzvs4ru","content":"<ul>\n<li><a href=\"http://www.caosen.me\" target=\"_blank\" rel=\"noopener\">山药蛋</a></li>\n<li><a href=\"http://zhuanlan.zhihu.com/sensen\" target=\"_blank\" rel=\"noopener\">三木的知乎专栏</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><a href=\"http://www.caosen.me\" target=\"_blank\" rel=\"noopener\">山药蛋</a></li>\n<li><a href=\"http://zhuanlan.zhihu.com/sensen\" target=\"_blank\" rel=\"noopener\">三木的知乎专栏</a></li>\n</ul>\n"}],"Post":[{"layout":"post","title":"我的2013","tagline":"","description":"2013年终将过去，这篇Blog可能会零零散散分级部分写完，因为基本上是想到今年的种种就会拓展开一小段文字，用来记录我这一年的经历。文章to be continued...","_content":"\n#旅程\n\n###英国\n\n这是今年走的最远的旅程，就是在7月份的时候，做了一次个人英国旅行，目的地弟弟正在上学读书的Manchester，这期间有很多故事，包括办理签证的准备，签证过程，以及旅行途中的很多故事，希望在2014年有时间好好整理一下，相机和磁盘里好多照片还没来得及整理和洗印，相信这会是几篇精心书写的Blogs\n\n###北戴河之旅\n2天旅行\n\n###成都行\n4天旅行\n\n\n#收获\n今年最大的收获就是收获了一份甜美的爱情，茫茫人海中遇到的她，祝福我们以后越来越好！\n\n#改变\n整个2013年中工作上想的最多的就是想有所改变，说到底其实就是想走了，但这件事似乎整整一年都在挣扎，因为我总是顾及很多，又想做好万全的准备再出去，离开目前熟悉的环境去迎接新的挑战，去寻找新的机遇。我很感谢两年多以来身边的人，So many thing s make me feel comfortable! \n\n年末的时候和原来公司认识很好的同事G，一起去吃饭。当聊到他最近找工作的辛苦的时候，他跟我说一句话很让我获益，他说他这四个多月频繁面试，辛苦找工作的过程中总结三句话，当你跳槽换工作的时候你一定要想明白三件事。\n\n * 自己到底想要做什么\n * 期望的薪水是多少\n * 自己的上升空间在哪里\n \n\n\n\n","source":"_drafts/2013-12-22-Summary-Of-2013.md","raw":"---\nlayout: post\ntitle : 我的2013\ncategory : blog\ntagline: \"\"\ntags : [文字, 生活]\ndescription : 2013年终将过去，这篇Blog可能会零零散散分级部分写完，因为基本上是想到今年的种种就会拓展开一小段文字，用来记录我这一年的经历。文章to be continued...\n---\n\n#旅程\n\n###英国\n\n这是今年走的最远的旅程，就是在7月份的时候，做了一次个人英国旅行，目的地弟弟正在上学读书的Manchester，这期间有很多故事，包括办理签证的准备，签证过程，以及旅行途中的很多故事，希望在2014年有时间好好整理一下，相机和磁盘里好多照片还没来得及整理和洗印，相信这会是几篇精心书写的Blogs\n\n###北戴河之旅\n2天旅行\n\n###成都行\n4天旅行\n\n\n#收获\n今年最大的收获就是收获了一份甜美的爱情，茫茫人海中遇到的她，祝福我们以后越来越好！\n\n#改变\n整个2013年中工作上想的最多的就是想有所改变，说到底其实就是想走了，但这件事似乎整整一年都在挣扎，因为我总是顾及很多，又想做好万全的准备再出去，离开目前熟悉的环境去迎接新的挑战，去寻找新的机遇。我很感谢两年多以来身边的人，So many thing s make me feel comfortable! \n\n年末的时候和原来公司认识很好的同事G，一起去吃饭。当聊到他最近找工作的辛苦的时候，他跟我说一句话很让我获益，他说他这四个多月频繁面试，辛苦找工作的过程中总结三句话，当你跳槽换工作的时候你一定要想明白三件事。\n\n * 自己到底想要做什么\n * 期望的薪水是多少\n * 自己的上升空间在哪里\n \n\n\n\n","slug":"Summary-Of-2013","published":0,"date":"2013-12-21T16:00:00.000Z","updated":"2017-11-04T11:09:17.000Z","comments":1,"photos":[],"link":"","_id":"cjc31n1ea0000gey5yi0ahi6e","content":"<p>#旅程</p>\n<p>###英国</p>\n<p>这是今年走的最远的旅程，就是在7月份的时候，做了一次个人英国旅行，目的地弟弟正在上学读书的Manchester，这期间有很多故事，包括办理签证的准备，签证过程，以及旅行途中的很多故事，希望在2014年有时间好好整理一下，相机和磁盘里好多照片还没来得及整理和洗印，相信这会是几篇精心书写的Blogs</p>\n<p>###北戴河之旅<br>2天旅行</p>\n<p>###成都行<br>4天旅行</p>\n<p>#收获<br>今年最大的收获就是收获了一份甜美的爱情，茫茫人海中遇到的她，祝福我们以后越来越好！</p>\n<p>#改变<br>整个2013年中工作上想的最多的就是想有所改变，说到底其实就是想走了，但这件事似乎整整一年都在挣扎，因为我总是顾及很多，又想做好万全的准备再出去，离开目前熟悉的环境去迎接新的挑战，去寻找新的机遇。我很感谢两年多以来身边的人，So many thing s make me feel comfortable! </p>\n<p>年末的时候和原来公司认识很好的同事G，一起去吃饭。当聊到他最近找工作的辛苦的时候，他跟我说一句话很让我获益，他说他这四个多月频繁面试，辛苦找工作的过程中总结三句话，当你跳槽换工作的时候你一定要想明白三件事。</p>\n<ul>\n<li>自己到底想要做什么</li>\n<li>期望的薪水是多少</li>\n<li>自己的上升空间在哪里</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>#旅程</p>\n<p>###英国</p>\n<p>这是今年走的最远的旅程，就是在7月份的时候，做了一次个人英国旅行，目的地弟弟正在上学读书的Manchester，这期间有很多故事，包括办理签证的准备，签证过程，以及旅行途中的很多故事，希望在2014年有时间好好整理一下，相机和磁盘里好多照片还没来得及整理和洗印，相信这会是几篇精心书写的Blogs</p>\n<p>###北戴河之旅<br>2天旅行</p>\n<p>###成都行<br>4天旅行</p>\n<p>#收获<br>今年最大的收获就是收获了一份甜美的爱情，茫茫人海中遇到的她，祝福我们以后越来越好！</p>\n<p>#改变<br>整个2013年中工作上想的最多的就是想有所改变，说到底其实就是想走了，但这件事似乎整整一年都在挣扎，因为我总是顾及很多，又想做好万全的准备再出去，离开目前熟悉的环境去迎接新的挑战，去寻找新的机遇。我很感谢两年多以来身边的人，So many thing s make me feel comfortable! </p>\n<p>年末的时候和原来公司认识很好的同事G，一起去吃饭。当聊到他最近找工作的辛苦的时候，他跟我说一句话很让我获益，他说他这四个多月频繁面试，辛苦找工作的过程中总结三句话，当你跳槽换工作的时候你一定要想明白三件事。</p>\n<ul>\n<li>自己到底想要做什么</li>\n<li>期望的薪水是多少</li>\n<li>自己的上升空间在哪里</li>\n</ul>\n"},{"layout":"post","title":"AppleCare Plan值得购买吗？","tagline":"","description":"笔者结合使用Mac一年多时间使用经验和大家分享AppleCare是否值得购买","_content":"\n##背景\n笔者2013年年初购买15' MacBook Pro with Retina，因为工作关系，很长一段时间，并没有将Mac完全作为主力机器来使用，仅仅平时坐地铁背来背去，自己都感觉浪费。\n\n恰巧今天在Amazon上购买的AppleCare Plan今天到货，博主希望和读者一起抽出几分钟时间讨论一下AppleCare是否值得购买。\n\n##亲身经历\n笔者MacBook入手一年多，大大小小经过很多的折腾，基本都局限于软件上的使用和OSX的体验。由于工作的关系，笔者在忙碌时不得不使用旧电脑的Windows操作系统，一直将","source":"_drafts/2013-12-30-Does-AppleCare-Plan-Worth.md","raw":"---\nlayout: post\ntitle : AppleCare Plan值得购买吗？\ncategory : 数码生活\ntagline: \"\"\ntags : [数码, 生活, Mac]\ndescription : 笔者结合使用Mac一年多时间使用经验和大家分享AppleCare是否值得购买\n---\n\n##背景\n笔者2013年年初购买15' MacBook Pro with Retina，因为工作关系，很长一段时间，并没有将Mac完全作为主力机器来使用，仅仅平时坐地铁背来背去，自己都感觉浪费。\n\n恰巧今天在Amazon上购买的AppleCare Plan今天到货，博主希望和读者一起抽出几分钟时间讨论一下AppleCare是否值得购买。\n\n##亲身经历\n笔者MacBook入手一年多，大大小小经过很多的折腾，基本都局限于软件上的使用和OSX的体验。由于工作的关系，笔者在忙碌时不得不使用旧电脑的Windows操作系统，一直将","slug":"Does-AppleCare-Plan-Worth","published":0,"date":"2013-12-29T16:00:00.000Z","updated":"2017-11-04T11:09:17.000Z","comments":1,"photos":[],"link":"","_id":"cjc31n1ei0002gey5j52jjhbu","content":"<p>##背景<br>笔者2013年年初购买15’ MacBook Pro with Retina，因为工作关系，很长一段时间，并没有将Mac完全作为主力机器来使用，仅仅平时坐地铁背来背去，自己都感觉浪费。</p>\n<p>恰巧今天在Amazon上购买的AppleCare Plan今天到货，博主希望和读者一起抽出几分钟时间讨论一下AppleCare是否值得购买。</p>\n<p>##亲身经历<br>笔者MacBook入手一年多，大大小小经过很多的折腾，基本都局限于软件上的使用和OSX的体验。由于工作的关系，笔者在忙碌时不得不使用旧电脑的Windows操作系统，一直将</p>\n","site":{"data":{}},"excerpt":"","more":"<p>##背景<br>笔者2013年年初购买15’ MacBook Pro with Retina，因为工作关系，很长一段时间，并没有将Mac完全作为主力机器来使用，仅仅平时坐地铁背来背去，自己都感觉浪费。</p>\n<p>恰巧今天在Amazon上购买的AppleCare Plan今天到货，博主希望和读者一起抽出几分钟时间讨论一下AppleCare是否值得购买。</p>\n<p>##亲身经历<br>笔者MacBook入手一年多，大大小小经过很多的折腾，基本都局限于软件上的使用和OSX的体验。由于工作的关系，笔者在忙碌时不得不使用旧电脑的Windows操作系统，一直将</p>\n"},{"layout":"post","title":"token插件使用经验与结合产品改造快速选人组件总结","tagline":"","description":"jquery-token组件使用分享与改造介绍","_content":"TODO\n#背景\n相信大家平时使用邮件、微博时候，对于地址栏自动匹配到具体的人或者地址这样的功能一定觉得很方便，可以说自动完成成为了我们平时感觉不到的使用习惯，而本篇Blog就是写笔者在做上基于这样的使用习惯改造的一些经验分享。\n#前期构思\n目前的功能有一个很好的匹配到具体人员的功能，经历了很多版本和很长时间的磨练，其中无论性能还是权限都比较成熟，快速选人这个功能要想完全替代原有的功能，挑战是非常困难的，时间紧任务重，所以我决定本阶段将这个快速选人组件定位成一个原有功能的辅助，不做原有功能完全复杂的逻辑，从快捷匹配到具体的人员入手，完成基本的选人发送功能即可。\n\n> 过早的优化是万恶之源。\n\n\n#token插件简介\n作者\n###token插件的几个特点\n\n* 自身有缓存\n* 支持JSON格式的待检索数据\n* 小巧且检索较快\n\n\n#改造过程\n\n\n#目前问题\n","source":"_drafts/2014-04-15-token-description.md","raw":"---\nlayout: post\ntitle : token插件使用经验与结合产品改造快速选人组件总结\ncategory : blog\ntagline: \"\"\ntags : [Javascript, jQuery, 技术]\ndescription : jquery-token组件使用分享与改造介绍\n---\nTODO\n#背景\n相信大家平时使用邮件、微博时候，对于地址栏自动匹配到具体的人或者地址这样的功能一定觉得很方便，可以说自动完成成为了我们平时感觉不到的使用习惯，而本篇Blog就是写笔者在做上基于这样的使用习惯改造的一些经验分享。\n#前期构思\n目前的功能有一个很好的匹配到具体人员的功能，经历了很多版本和很长时间的磨练，其中无论性能还是权限都比较成熟，快速选人这个功能要想完全替代原有的功能，挑战是非常困难的，时间紧任务重，所以我决定本阶段将这个快速选人组件定位成一个原有功能的辅助，不做原有功能完全复杂的逻辑，从快捷匹配到具体的人员入手，完成基本的选人发送功能即可。\n\n> 过早的优化是万恶之源。\n\n\n#token插件简介\n作者\n###token插件的几个特点\n\n* 自身有缓存\n* 支持JSON格式的待检索数据\n* 小巧且检索较快\n\n\n#改造过程\n\n\n#目前问题\n","slug":"token-description","published":0,"date":"2014-04-14T16:00:00.000Z","updated":"2017-11-04T11:09:17.000Z","comments":1,"photos":[],"link":"","_id":"cjc31n1em0006gey5st931zla","content":"<p>TODO</p>\n<p>#背景<br>相信大家平时使用邮件、微博时候，对于地址栏自动匹配到具体的人或者地址这样的功能一定觉得很方便，可以说自动完成成为了我们平时感觉不到的使用习惯，而本篇Blog就是写笔者在做上基于这样的使用习惯改造的一些经验分享。</p>\n<p>#前期构思<br>目前的功能有一个很好的匹配到具体人员的功能，经历了很多版本和很长时间的磨练，其中无论性能还是权限都比较成熟，快速选人这个功能要想完全替代原有的功能，挑战是非常困难的，时间紧任务重，所以我决定本阶段将这个快速选人组件定位成一个原有功能的辅助，不做原有功能完全复杂的逻辑，从快捷匹配到具体的人员入手，完成基本的选人发送功能即可。</p>\n<blockquote>\n<p>过早的优化是万恶之源。</p>\n</blockquote>\n<p>#token插件简介<br>作者</p>\n<p>###token插件的几个特点</p>\n<ul>\n<li>自身有缓存</li>\n<li>支持JSON格式的待检索数据</li>\n<li>小巧且检索较快</li>\n</ul>\n<p>#改造过程</p>\n<p>#目前问题</p>\n","site":{"data":{}},"excerpt":"","more":"<p>TODO</p>\n<p>#背景<br>相信大家平时使用邮件、微博时候，对于地址栏自动匹配到具体的人或者地址这样的功能一定觉得很方便，可以说自动完成成为了我们平时感觉不到的使用习惯，而本篇Blog就是写笔者在做上基于这样的使用习惯改造的一些经验分享。</p>\n<p>#前期构思<br>目前的功能有一个很好的匹配到具体人员的功能，经历了很多版本和很长时间的磨练，其中无论性能还是权限都比较成熟，快速选人这个功能要想完全替代原有的功能，挑战是非常困难的，时间紧任务重，所以我决定本阶段将这个快速选人组件定位成一个原有功能的辅助，不做原有功能完全复杂的逻辑，从快捷匹配到具体的人员入手，完成基本的选人发送功能即可。</p>\n<blockquote>\n<p>过早的优化是万恶之源。</p>\n</blockquote>\n<p>#token插件简介<br>作者</p>\n<p>###token插件的几个特点</p>\n<ul>\n<li>自身有缓存</li>\n<li>支持JSON格式的待检索数据</li>\n<li>小巧且检索较快</li>\n</ul>\n<p>#改造过程</p>\n<p>#目前问题</p>\n"},{"layout":"post","title":"温故Javascript之闭包","date":"2014-12-06T23:37:15.000Z","_content":"\n<!-- more -->\n\n# 温故 Javascript 之闭包\n","source":"_drafts/2014-12-06-Javascript-Clorse.md","raw":"---\nlayout: post\ntitle: 温故Javascript之闭包\ndate: 2014-12-07 07:37:15\ntags: [Javascript]\n---\n\n<!-- more -->\n\n# 温故 Javascript 之闭包\n","slug":"Javascript-Clorse","published":0,"updated":"2017-11-04T11:09:17.000Z","comments":1,"photos":[],"link":"","_id":"cjc31n1eq0008gey5mt8wtog6","content":"<a id=\"more\"></a>\n<h1 id=\"温故-Javascript-之闭包\"><a href=\"#温故-Javascript-之闭包\" class=\"headerlink\" title=\"温故 Javascript 之闭包\"></a>温故 Javascript 之闭包</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"温故-Javascript-之闭包\"><a href=\"#温故-Javascript-之闭包\" class=\"headerlink\" title=\"温故 Javascript 之闭包\"></a>温故 Javascript 之闭包</h1>"},{"layout":"post","title":"Become A Front-End Dev","tagline":"","description":null,"date":"2015-04-08T16:00:01.000Z","_content":"\n## 跳槽\n\n> 千万不要为了当前不好而跳槽，一定是要因为将来会更好而跳槽！\n\n完成Blog的时候应该是通过最终的面试马上要入职的阶段了吧，一年内换两份工作在一个人的履历上可能不是一个太好的条目，当时当时来到某东","source":"_drafts/2015-04-09-Become-A-FE-Prepare.md","raw":"---\nlayout: post\ntitle : Become A Front-End Dev\ncategory : blog\ntagline: \"\"\ntags : [Front-End]\ndescription : \ndate: 2015-04-09 00:00:01\n---\n\n## 跳槽\n\n> 千万不要为了当前不好而跳槽，一定是要因为将来会更好而跳槽！\n\n完成Blog的时候应该是通过最终的面试马上要入职的阶段了吧，一年内换两份工作在一个人的履历上可能不是一个太好的条目，当时当时来到某东","slug":"Become-A-FE-Prepare","published":0,"updated":"2017-11-04T11:09:17.000Z","comments":1,"photos":[],"link":"","_id":"cjc31n1er0009gey51eklzi4e","content":"<h2 id=\"跳槽\"><a href=\"#跳槽\" class=\"headerlink\" title=\"跳槽\"></a>跳槽</h2><blockquote>\n<p>千万不要为了当前不好而跳槽，一定是要因为将来会更好而跳槽！</p>\n</blockquote>\n<p>完成Blog的时候应该是通过最终的面试马上要入职的阶段了吧，一年内换两份工作在一个人的履历上可能不是一个太好的条目，当时当时来到某东</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"跳槽\"><a href=\"#跳槽\" class=\"headerlink\" title=\"跳槽\"></a>跳槽</h2><blockquote>\n<p>千万不要为了当前不好而跳槽，一定是要因为将来会更好而跳槽！</p>\n</blockquote>\n<p>完成Blog的时候应该是通过最终的面试马上要入职的阶段了吧，一年内换两份工作在一个人的履历上可能不是一个太好的条目，当时当时来到某东</p>\n"},{"layout":"post","title":"The Meaning Of Travel","tagline":"","description":null,"date":"2015-05-11T15:09:00.000Z","_content":"\n# 旅行的意义\n\n> 周末600天环球骑行李瑞旅行分享会回来的一点感触\n\n文章的标题虽然看起来似乎是要在这里讨论很高大上大问题，因为单纯说旅行就有太多的话题可以讨论，而今天我只是想在这里分享一下2015年5月9日参加李瑞旅行分享会回来的一点点感触而已。\n\n## “世界很大，我想去看看”\n\n因为一位老师辞职信，这句话一下子成了网络热词，","source":"_drafts/2015-05-11-The-Meaning-Of-Travel.md","raw":"---\nlayout: post\ntitle : The Meaning Of Travel\ncategory : blog\ntagline: \"\"\ntags : [Life]\ndescription : \ndate: 2015-05-11 23:09:00\n---\n\n# 旅行的意义\n\n> 周末600天环球骑行李瑞旅行分享会回来的一点感触\n\n文章的标题虽然看起来似乎是要在这里讨论很高大上大问题，因为单纯说旅行就有太多的话题可以讨论，而今天我只是想在这里分享一下2015年5月9日参加李瑞旅行分享会回来的一点点感触而已。\n\n## “世界很大，我想去看看”\n\n因为一位老师辞职信，这句话一下子成了网络热词，","slug":"The-Meaning-Of-Travel","published":0,"updated":"2017-11-04T11:09:17.000Z","comments":1,"photos":[],"link":"","_id":"cjc31n1eu000cgey5zlfhofq1","content":"<h1 id=\"旅行的意义\"><a href=\"#旅行的意义\" class=\"headerlink\" title=\"旅行的意义\"></a>旅行的意义</h1><blockquote>\n<p>周末600天环球骑行李瑞旅行分享会回来的一点感触</p>\n</blockquote>\n<p>文章的标题虽然看起来似乎是要在这里讨论很高大上大问题，因为单纯说旅行就有太多的话题可以讨论，而今天我只是想在这里分享一下2015年5月9日参加李瑞旅行分享会回来的一点点感触而已。</p>\n<h2 id=\"“世界很大，我想去看看”\"><a href=\"#“世界很大，我想去看看”\" class=\"headerlink\" title=\"“世界很大，我想去看看”\"></a>“世界很大，我想去看看”</h2><p>因为一位老师辞职信，这句话一下子成了网络热词，</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"旅行的意义\"><a href=\"#旅行的意义\" class=\"headerlink\" title=\"旅行的意义\"></a>旅行的意义</h1><blockquote>\n<p>周末600天环球骑行李瑞旅行分享会回来的一点感触</p>\n</blockquote>\n<p>文章的标题虽然看起来似乎是要在这里讨论很高大上大问题，因为单纯说旅行就有太多的话题可以讨论，而今天我只是想在这里分享一下2015年5月9日参加李瑞旅行分享会回来的一点点感触而已。</p>\n<h2 id=\"“世界很大，我想去看看”\"><a href=\"#“世界很大，我想去看看”\" class=\"headerlink\" title=\"“世界很大，我想去看看”\"></a>“世界很大，我想去看看”</h2><p>因为一位老师辞职信，这句话一下子成了网络热词，</p>\n"},{"title":"IKEA-JIONG","date":"2015-12-26T14:19:40.000Z","_content":"# IKEA 囧\n\n以前每次和她去逛宜家，总是有好多憧憬和许愿，把这个弄回家，家里以后要弄哪个，到时候那么设计，然后再这么摆放，到最后离开的时候只能将几个设计性和实用性兼具的小玩意带走，每每都少不了一点点遗憾。\n\n今天当我把一件件看中的物件运回家和师傅一块组装，给新家添置家具的时候，这个过程尤其的享受，特期待早点入住新房！\n\n喜欢的，舒适的就是最“完美”的家居！\n\nPS.下午时分，师傅说这都2015年年底了，你们家是第三家从宜家买这种特别高的滑门衣柜，安装太费劲了，咱要不再歇一会，我出去抽根烟琢磨下它这个安装说明说！囧_(:ｪ 」∠)_","source":"_drafts/2015-12-26-IKEA-JIONG.md","raw":"title: IKEA-JIONG\ndate: 2015-12-26 22:19:40\ntags: Life\n---\n# IKEA 囧\n\n以前每次和她去逛宜家，总是有好多憧憬和许愿，把这个弄回家，家里以后要弄哪个，到时候那么设计，然后再这么摆放，到最后离开的时候只能将几个设计性和实用性兼具的小玩意带走，每每都少不了一点点遗憾。\n\n今天当我把一件件看中的物件运回家和师傅一块组装，给新家添置家具的时候，这个过程尤其的享受，特期待早点入住新房！\n\n喜欢的，舒适的就是最“完美”的家居！\n\nPS.下午时分，师傅说这都2015年年底了，你们家是第三家从宜家买这种特别高的滑门衣柜，安装太费劲了，咱要不再歇一会，我出去抽根烟琢磨下它这个安装说明说！囧_(:ｪ 」∠)_","slug":"IKEA-JIONG","published":0,"updated":"2017-11-04T11:09:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc31n1ew000dgey59jqnk1cm","content":"<h1 id=\"IKEA-囧\"><a href=\"#IKEA-囧\" class=\"headerlink\" title=\"IKEA 囧\"></a>IKEA 囧</h1><p>以前每次和她去逛宜家，总是有好多憧憬和许愿，把这个弄回家，家里以后要弄哪个，到时候那么设计，然后再这么摆放，到最后离开的时候只能将几个设计性和实用性兼具的小玩意带走，每每都少不了一点点遗憾。</p>\n<p>今天当我把一件件看中的物件运回家和师傅一块组装，给新家添置家具的时候，这个过程尤其的享受，特期待早点入住新房！</p>\n<p>喜欢的，舒适的就是最“完美”的家居！</p>\n<p>PS.下午时分，师傅说这都2015年年底了，你们家是第三家从宜家买这种特别高的滑门衣柜，安装太费劲了，咱要不再歇一会，我出去抽根烟琢磨下它这个安装说明说！囧<em>(:ｪ 」∠)</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"IKEA-囧\"><a href=\"#IKEA-囧\" class=\"headerlink\" title=\"IKEA 囧\"></a>IKEA 囧</h1><p>以前每次和她去逛宜家，总是有好多憧憬和许愿，把这个弄回家，家里以后要弄哪个，到时候那么设计，然后再这么摆放，到最后离开的时候只能将几个设计性和实用性兼具的小玩意带走，每每都少不了一点点遗憾。</p>\n<p>今天当我把一件件看中的物件运回家和师傅一块组装，给新家添置家具的时候，这个过程尤其的享受，特期待早点入住新房！</p>\n<p>喜欢的，舒适的就是最“完美”的家居！</p>\n<p>PS.下午时分，师傅说这都2015年年底了，你们家是第三家从宜家买这种特别高的滑门衣柜，安装太费劲了，咱要不再歇一会，我出去抽根烟琢磨下它这个安装说明说！囧<em>(:ｪ 」∠)</em></p>\n"},{"title":"MY2015","date":"2015-12-27T05:05:53.000Z","_content":"# My 2015 写给自己的2015年干货\n\n如果说2016就这么巧如生息地来到你面前，而你只能无所适从的选择接受，我情愿花很大一个篇幅，甚至几天时间去回顾自己的2015，不愿自己的生活再如从前一样混吃等死过日子，于是就有了这篇Blog。\n\nPS.咖啡馆身边有两位打字飞快的人，通过简单聊天知道是两个编剧。\n\n## Big Thing Timeline 时间线\n\n* 2015.01 工作－京东结算页V3.0上线\n* 2015.02 家庭－春节回家主旋律\n* 2015.03 个人－献血、工作－移动仓项目上线\n* 2015.04 家庭－拜访好哥们的新家、个人－Misfit线下硬件体验会\n* 2015.05 家庭－好哥们的婚礼、个人－李瑞分享会、工作－为面试做准备\n* 2015.06 家庭－厦门旅行\n* 2015.07 七下\n* 2015.08 八上\n* 2015.09 家庭－钻戒、工作－搬家京东总部\n* 2015.10 家庭－正式会亲家、新房验房收房、个人－海贼王音乐会\n* 2015.11 家庭－装修（壁纸、车位、讨论装修家具）\n* 2015.12 家庭－装修（家具）\n\n## Family 家庭\n\n“成家立业”\n\n似乎从时间线上就能看出2015年主旋律是围绕家庭，因为从一个男孩成长成一个男人，对另一半负起责任是作为男人应该是必须迈出踏实的一步。\n\n## Jun & Aug 七下八上\n\n可以说在个人发展上来看，在2015年我目前属于原地踏步的状态，这种状态早在2014年年底就有所察觉，尤其是在去年年底决定将自己的职业规划作了调整以后特别明显。这段之所以叫七下\n\n","source":"_drafts/2015-12-27-MY2015.md","raw":"title: MY2015\ndate: 2015-12-27 13:05:53\ntags: [生活, 工作, 新年计划]\n---\n# My 2015 写给自己的2015年干货\n\n如果说2016就这么巧如生息地来到你面前，而你只能无所适从的选择接受，我情愿花很大一个篇幅，甚至几天时间去回顾自己的2015，不愿自己的生活再如从前一样混吃等死过日子，于是就有了这篇Blog。\n\nPS.咖啡馆身边有两位打字飞快的人，通过简单聊天知道是两个编剧。\n\n## Big Thing Timeline 时间线\n\n* 2015.01 工作－京东结算页V3.0上线\n* 2015.02 家庭－春节回家主旋律\n* 2015.03 个人－献血、工作－移动仓项目上线\n* 2015.04 家庭－拜访好哥们的新家、个人－Misfit线下硬件体验会\n* 2015.05 家庭－好哥们的婚礼、个人－李瑞分享会、工作－为面试做准备\n* 2015.06 家庭－厦门旅行\n* 2015.07 七下\n* 2015.08 八上\n* 2015.09 家庭－钻戒、工作－搬家京东总部\n* 2015.10 家庭－正式会亲家、新房验房收房、个人－海贼王音乐会\n* 2015.11 家庭－装修（壁纸、车位、讨论装修家具）\n* 2015.12 家庭－装修（家具）\n\n## Family 家庭\n\n“成家立业”\n\n似乎从时间线上就能看出2015年主旋律是围绕家庭，因为从一个男孩成长成一个男人，对另一半负起责任是作为男人应该是必须迈出踏实的一步。\n\n## Jun & Aug 七下八上\n\n可以说在个人发展上来看，在2015年我目前属于原地踏步的状态，这种状态早在2014年年底就有所察觉，尤其是在去年年底决定将自己的职业规划作了调整以后特别明显。这段之所以叫七下\n\n","slug":"MY2015","published":0,"updated":"2017-11-04T11:09:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc31n1ez000hgey572ou0oc2","content":"<h1 id=\"My-2015-写给自己的2015年干货\"><a href=\"#My-2015-写给自己的2015年干货\" class=\"headerlink\" title=\"My 2015 写给自己的2015年干货\"></a>My 2015 写给自己的2015年干货</h1><p>如果说2016就这么巧如生息地来到你面前，而你只能无所适从的选择接受，我情愿花很大一个篇幅，甚至几天时间去回顾自己的2015，不愿自己的生活再如从前一样混吃等死过日子，于是就有了这篇Blog。</p>\n<p>PS.咖啡馆身边有两位打字飞快的人，通过简单聊天知道是两个编剧。</p>\n<h2 id=\"Big-Thing-Timeline-时间线\"><a href=\"#Big-Thing-Timeline-时间线\" class=\"headerlink\" title=\"Big Thing Timeline 时间线\"></a>Big Thing Timeline 时间线</h2><ul>\n<li>2015.01 工作－京东结算页V3.0上线</li>\n<li>2015.02 家庭－春节回家主旋律</li>\n<li>2015.03 个人－献血、工作－移动仓项目上线</li>\n<li>2015.04 家庭－拜访好哥们的新家、个人－Misfit线下硬件体验会</li>\n<li>2015.05 家庭－好哥们的婚礼、个人－李瑞分享会、工作－为面试做准备</li>\n<li>2015.06 家庭－厦门旅行</li>\n<li>2015.07 七下</li>\n<li>2015.08 八上</li>\n<li>2015.09 家庭－钻戒、工作－搬家京东总部</li>\n<li>2015.10 家庭－正式会亲家、新房验房收房、个人－海贼王音乐会</li>\n<li>2015.11 家庭－装修（壁纸、车位、讨论装修家具）</li>\n<li>2015.12 家庭－装修（家具）</li>\n</ul>\n<h2 id=\"Family-家庭\"><a href=\"#Family-家庭\" class=\"headerlink\" title=\"Family 家庭\"></a>Family 家庭</h2><p>“成家立业”</p>\n<p>似乎从时间线上就能看出2015年主旋律是围绕家庭，因为从一个男孩成长成一个男人，对另一半负起责任是作为男人应该是必须迈出踏实的一步。</p>\n<h2 id=\"Jun-amp-Aug-七下八上\"><a href=\"#Jun-amp-Aug-七下八上\" class=\"headerlink\" title=\"Jun &amp; Aug 七下八上\"></a>Jun &amp; Aug 七下八上</h2><p>可以说在个人发展上来看，在2015年我目前属于原地踏步的状态，这种状态早在2014年年底就有所察觉，尤其是在去年年底决定将自己的职业规划作了调整以后特别明显。这段之所以叫七下</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"My-2015-写给自己的2015年干货\"><a href=\"#My-2015-写给自己的2015年干货\" class=\"headerlink\" title=\"My 2015 写给自己的2015年干货\"></a>My 2015 写给自己的2015年干货</h1><p>如果说2016就这么巧如生息地来到你面前，而你只能无所适从的选择接受，我情愿花很大一个篇幅，甚至几天时间去回顾自己的2015，不愿自己的生活再如从前一样混吃等死过日子，于是就有了这篇Blog。</p>\n<p>PS.咖啡馆身边有两位打字飞快的人，通过简单聊天知道是两个编剧。</p>\n<h2 id=\"Big-Thing-Timeline-时间线\"><a href=\"#Big-Thing-Timeline-时间线\" class=\"headerlink\" title=\"Big Thing Timeline 时间线\"></a>Big Thing Timeline 时间线</h2><ul>\n<li>2015.01 工作－京东结算页V3.0上线</li>\n<li>2015.02 家庭－春节回家主旋律</li>\n<li>2015.03 个人－献血、工作－移动仓项目上线</li>\n<li>2015.04 家庭－拜访好哥们的新家、个人－Misfit线下硬件体验会</li>\n<li>2015.05 家庭－好哥们的婚礼、个人－李瑞分享会、工作－为面试做准备</li>\n<li>2015.06 家庭－厦门旅行</li>\n<li>2015.07 七下</li>\n<li>2015.08 八上</li>\n<li>2015.09 家庭－钻戒、工作－搬家京东总部</li>\n<li>2015.10 家庭－正式会亲家、新房验房收房、个人－海贼王音乐会</li>\n<li>2015.11 家庭－装修（壁纸、车位、讨论装修家具）</li>\n<li>2015.12 家庭－装修（家具）</li>\n</ul>\n<h2 id=\"Family-家庭\"><a href=\"#Family-家庭\" class=\"headerlink\" title=\"Family 家庭\"></a>Family 家庭</h2><p>“成家立业”</p>\n<p>似乎从时间线上就能看出2015年主旋律是围绕家庭，因为从一个男孩成长成一个男人，对另一半负起责任是作为男人应该是必须迈出踏实的一步。</p>\n<h2 id=\"Jun-amp-Aug-七下八上\"><a href=\"#Jun-amp-Aug-七下八上\" class=\"headerlink\" title=\"Jun &amp; Aug 七下八上\"></a>Jun &amp; Aug 七下八上</h2><p>可以说在个人发展上来看，在2015年我目前属于原地踏步的状态，这种状态早在2014年年底就有所察觉，尤其是在去年年底决定将自己的职业规划作了调整以后特别明显。这段之所以叫七下</p>\n"},{"layout":"post","title":"【译】Untangling Spaghetti Code How to Write Maintainable JavaScript","date":"2016-06-03T06:24:27.000Z","_content":"\n> 湾区日报推荐：里面提到的不少实践也适合其他编程语言。推荐使用 .editorconfig 保持团队的代码风格。\n\ncoming...\n\n[Source Link](https://www.sitepoint.com/write-maintainable-javascript/)\n\n[众诚翻译版本](http://www.zcfy.cc/article/312)\n\n","source":"_drafts/2016-06-03-How-to-Write-Maintainable-JavaScript.md","raw":"---\nlayout: post\ntitle: 【译】Untangling Spaghetti Code How to Write Maintainable JavaScript\ndate: 2016-06-03 14:24:27\ncategory : 译文计划\ntags: [Javascript]\n---\n\n> 湾区日报推荐：里面提到的不少实践也适合其他编程语言。推荐使用 .editorconfig 保持团队的代码风格。\n\ncoming...\n\n[Source Link](https://www.sitepoint.com/write-maintainable-javascript/)\n\n[众诚翻译版本](http://www.zcfy.cc/article/312)\n\n","slug":"How-to-Write-Maintainable-JavaScript","published":0,"updated":"2017-11-04T11:09:17.000Z","comments":1,"photos":[],"link":"","_id":"cjc31n1f1000kgey5v1qy7czf","content":"<blockquote>\n<p>湾区日报推荐：里面提到的不少实践也适合其他编程语言。推荐使用 .editorconfig 保持团队的代码风格。</p>\n</blockquote>\n<p>coming…</p>\n<p><a href=\"https://www.sitepoint.com/write-maintainable-javascript/\" target=\"_blank\" rel=\"noopener\">Source Link</a></p>\n<p><a href=\"http://www.zcfy.cc/article/312\" target=\"_blank\" rel=\"noopener\">众诚翻译版本</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>湾区日报推荐：里面提到的不少实践也适合其他编程语言。推荐使用 .editorconfig 保持团队的代码风格。</p>\n</blockquote>\n<p>coming…</p>\n<p><a href=\"https://www.sitepoint.com/write-maintainable-javascript/\" target=\"_blank\" rel=\"noopener\">Source Link</a></p>\n<p><a href=\"http://www.zcfy.cc/article/312\" target=\"_blank\" rel=\"noopener\">众诚翻译版本</a></p>\n"},{"title":"【译】My First 5 Minutes On A Server; Or, Essential Security for Linux Servers","date":"2016-06-20T09:02:12.000Z","_content":"\n[Source Link](https://plusbryan.com/my-first-5-minutes-on-a-server-or-essential-security-for-linux-servers?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website)\n\ncoming...","source":"_drafts/2016-06-20-WANQU-Essential-Security-for-Linux-Servers.md","raw":"---\ntitle: 【译】My First 5 Minutes On A Server; Or, Essential Security for Linux Servers\ndate: 2016-06-20 17:02:12\ntags: [linux]\n---\n\n[Source Link](https://plusbryan.com/my-first-5-minutes-on-a-server-or-essential-security-for-linux-servers?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website)\n\ncoming...","slug":"WANQU-Essential-Security-for-Linux-Servers","published":0,"updated":"2017-11-04T11:09:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc31n1f3000ogey5oha8zaj5","content":"<p><a href=\"https://plusbryan.com/my-first-5-minutes-on-a-server-or-essential-security-for-linux-servers?utm_source=wanqu.co&amp;utm_campaign=Wanqu+Daily&amp;utm_medium=website\" target=\"_blank\" rel=\"noopener\">Source Link</a></p>\n<p>coming…</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://plusbryan.com/my-first-5-minutes-on-a-server-or-essential-security-for-linux-servers?utm_source=wanqu.co&amp;utm_campaign=Wanqu+Daily&amp;utm_medium=website\" target=\"_blank\" rel=\"noopener\">Source Link</a></p>\n<p>coming…</p>\n"},{"title":"【译】I hate the news","date":"2016-06-21T06:05:22.000Z","_content":"\n> 湾区简评：我们这个时代的传奇人物、已过世的Aaron Swartz在20岁的时候写的文章。新闻普遍都是噱头，真没那么多重要的新闻值得占用你宝贵的时间，错过了哪条新闻你的人生都不会有什么损失。\n>思想境界要提高，还是得把时间花在读优质长文与好书。\n\n[Source Link](http://www.aaronsw.com/weblog/hatethenews)\n\n","source":"_drafts/2016-06-21-WANQU-I-hate-the-news.md","raw":"---\ntitle: 【译】I hate the news\ndate: 2016-06-21 14:05:22\ntags: [reading]\n---\n\n> 湾区简评：我们这个时代的传奇人物、已过世的Aaron Swartz在20岁的时候写的文章。新闻普遍都是噱头，真没那么多重要的新闻值得占用你宝贵的时间，错过了哪条新闻你的人生都不会有什么损失。\n>思想境界要提高，还是得把时间花在读优质长文与好书。\n\n[Source Link](http://www.aaronsw.com/weblog/hatethenews)\n\n","slug":"WANQU-I-hate-the-news","published":0,"updated":"2017-11-04T11:09:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc31n1f5000rgey5lwjawvna","content":"<blockquote>\n<p>湾区简评：我们这个时代的传奇人物、已过世的Aaron Swartz在20岁的时候写的文章。新闻普遍都是噱头，真没那么多重要的新闻值得占用你宝贵的时间，错过了哪条新闻你的人生都不会有什么损失。<br>思想境界要提高，还是得把时间花在读优质长文与好书。</p>\n</blockquote>\n<p><a href=\"http://www.aaronsw.com/weblog/hatethenews\" target=\"_blank\" rel=\"noopener\">Source Link</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>湾区简评：我们这个时代的传奇人物、已过世的Aaron Swartz在20岁的时候写的文章。新闻普遍都是噱头，真没那么多重要的新闻值得占用你宝贵的时间，错过了哪条新闻你的人生都不会有什么损失。<br>思想境界要提高，还是得把时间花在读优质长文与好书。</p>\n</blockquote>\n<p><a href=\"http://www.aaronsw.com/weblog/hatethenews\" target=\"_blank\" rel=\"noopener\">Source Link</a></p>\n"},{"title":"About Meta","_content":"","source":"_drafts/2017-01-04-About-Meta.md","raw":"---\ntitle: About Meta\ntags: []\ncategories: []\n---\n","slug":"About-Meta","published":0,"date":"2017-01-03T16:00:00.000Z","updated":"2017-11-04T11:09:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc31n1f8000ugey53si2mrle","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"开篇","description":"Blog第一篇文章","date":"2013-11-27T16:00:01.000Z","_content":"\n欢迎阅读豆子先生的Blog自介绍开篇\n\n[Bean Blog](http://beanlee.com)\n\n### What\n\n这是一个独立的Blog，基于Github Pages + Jekyll，托管在Git服务器上，编写语言是Mardown，图床待定，网盘待定。\n\n``Update 2015`` 目前基于 Hexo 搭建，图床临时使用微博做载体。\n\n### Who\n\n作者[About me](http://about.me/bean_lee)常常自称豆子先生，目标成为海贼王，啊！不对，是成为架构师的攻城狮一枚。\n\n关于写Blog没有任何经验，文字功底不深，但有一腔热血和语言想记录下来。\n\n目前的工作，是做一些J2EE的WEB 系统开发，自然个人最熟悉的开发语言是Java，同时也对Python, Groovy, Javascript等脚本语言有一些研究和实际应用；\n\n### When\nBlog创建于2013年11月27日凌晨1:00\n\n### Why\n\n豆子先生年初制定2013年个人计划中的一项：搭建独立的个人Blog。希望这个基于Github Pages + Jekyll下搭建的Blog能够坚持维护下去，虽然目前还是雏形，还需要继续学习逐渐完善。建立Blog的初衷很简单，就是想记录豆子先生日常生活中工作、学习、生活中的一些积累和感悟。\n\n下个月找时间把个人搭建这个blog过程写一篇小教程，把整个过程，包括Blog选型，对比，搭建过程，遇到的问题，查询的资料和文档等等经验，分享给想通过GitHub Pages快速搭建Blog朋友。\n\n\n### How\n\n经常关注各类新技术，热衷于尝试新鲜事物和新技术，收集各类有意思的软件，自从年初MacBook Pro with Retina成为主力机之后近期逐渐追加关注Mac下的各类有趣的软件，也希望有兴趣开发出有趣的App，所以今后可能在Blog中写一些软件试用的推荐小文；\n\n关注各类数码产品，半个发烧玩家！\n\n这个Blog中也会记录一些个人从之前零散记录的内容，后续也会整理总结的一些技术相关的内容，欢迎大家关注订阅[RSS](http://beanlee.github.io/rss.xml)和拍砖留言。\n","source":"_posts/2013-11-28-First-Blog.md","raw":"---\ntitle : 开篇\ncategory : blog\ntags : \ndescription : Blog第一篇文章\ndate: 2013-11-28 00:00:01\n---\n\n欢迎阅读豆子先生的Blog自介绍开篇\n\n[Bean Blog](http://beanlee.com)\n\n### What\n\n这是一个独立的Blog，基于Github Pages + Jekyll，托管在Git服务器上，编写语言是Mardown，图床待定，网盘待定。\n\n``Update 2015`` 目前基于 Hexo 搭建，图床临时使用微博做载体。\n\n### Who\n\n作者[About me](http://about.me/bean_lee)常常自称豆子先生，目标成为海贼王，啊！不对，是成为架构师的攻城狮一枚。\n\n关于写Blog没有任何经验，文字功底不深，但有一腔热血和语言想记录下来。\n\n目前的工作，是做一些J2EE的WEB 系统开发，自然个人最熟悉的开发语言是Java，同时也对Python, Groovy, Javascript等脚本语言有一些研究和实际应用；\n\n### When\nBlog创建于2013年11月27日凌晨1:00\n\n### Why\n\n豆子先生年初制定2013年个人计划中的一项：搭建独立的个人Blog。希望这个基于Github Pages + Jekyll下搭建的Blog能够坚持维护下去，虽然目前还是雏形，还需要继续学习逐渐完善。建立Blog的初衷很简单，就是想记录豆子先生日常生活中工作、学习、生活中的一些积累和感悟。\n\n下个月找时间把个人搭建这个blog过程写一篇小教程，把整个过程，包括Blog选型，对比，搭建过程，遇到的问题，查询的资料和文档等等经验，分享给想通过GitHub Pages快速搭建Blog朋友。\n\n\n### How\n\n经常关注各类新技术，热衷于尝试新鲜事物和新技术，收集各类有意思的软件，自从年初MacBook Pro with Retina成为主力机之后近期逐渐追加关注Mac下的各类有趣的软件，也希望有兴趣开发出有趣的App，所以今后可能在Blog中写一些软件试用的推荐小文；\n\n关注各类数码产品，半个发烧玩家！\n\n这个Blog中也会记录一些个人从之前零散记录的内容，后续也会整理总结的一些技术相关的内容，欢迎大家关注订阅[RSS](http://beanlee.github.io/rss.xml)和拍砖留言。\n","slug":"First-Blog","published":1,"updated":"2017-11-04T11:09:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc31n1fa000vgey5onf8z0ii","content":"<p>欢迎阅读豆子先生的Blog自介绍开篇</p>\n<p><a href=\"http://beanlee.com\">Bean Blog</a></p>\n<h3 id=\"What\"><a href=\"#What\" class=\"headerlink\" title=\"What\"></a>What</h3><p>这是一个独立的Blog，基于Github Pages + Jekyll，托管在Git服务器上，编写语言是Mardown，图床待定，网盘待定。</p>\n<p><code>Update 2015</code> 目前基于 Hexo 搭建，图床临时使用微博做载体。</p>\n<h3 id=\"Who\"><a href=\"#Who\" class=\"headerlink\" title=\"Who\"></a>Who</h3><p>作者<a href=\"http://about.me/bean_lee\" target=\"_blank\" rel=\"noopener\">About me</a>常常自称豆子先生，目标成为海贼王，啊！不对，是成为架构师的攻城狮一枚。</p>\n<p>关于写Blog没有任何经验，文字功底不深，但有一腔热血和语言想记录下来。</p>\n<p>目前的工作，是做一些J2EE的WEB 系统开发，自然个人最熟悉的开发语言是Java，同时也对Python, Groovy, Javascript等脚本语言有一些研究和实际应用；</p>\n<h3 id=\"When\"><a href=\"#When\" class=\"headerlink\" title=\"When\"></a>When</h3><p>Blog创建于2013年11月27日凌晨1:00</p>\n<h3 id=\"Why\"><a href=\"#Why\" class=\"headerlink\" title=\"Why\"></a>Why</h3><p>豆子先生年初制定2013年个人计划中的一项：搭建独立的个人Blog。希望这个基于Github Pages + Jekyll下搭建的Blog能够坚持维护下去，虽然目前还是雏形，还需要继续学习逐渐完善。建立Blog的初衷很简单，就是想记录豆子先生日常生活中工作、学习、生活中的一些积累和感悟。</p>\n<p>下个月找时间把个人搭建这个blog过程写一篇小教程，把整个过程，包括Blog选型，对比，搭建过程，遇到的问题，查询的资料和文档等等经验，分享给想通过GitHub Pages快速搭建Blog朋友。</p>\n<h3 id=\"How\"><a href=\"#How\" class=\"headerlink\" title=\"How\"></a>How</h3><p>经常关注各类新技术，热衷于尝试新鲜事物和新技术，收集各类有意思的软件，自从年初MacBook Pro with Retina成为主力机之后近期逐渐追加关注Mac下的各类有趣的软件，也希望有兴趣开发出有趣的App，所以今后可能在Blog中写一些软件试用的推荐小文；</p>\n<p>关注各类数码产品，半个发烧玩家！</p>\n<p>这个Blog中也会记录一些个人从之前零散记录的内容，后续也会整理总结的一些技术相关的内容，欢迎大家关注订阅<a href=\"http://beanlee.github.io/rss.xml\" target=\"_blank\" rel=\"noopener\">RSS</a>和拍砖留言。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>欢迎阅读豆子先生的Blog自介绍开篇</p>\n<p><a href=\"http://beanlee.com\">Bean Blog</a></p>\n<h3 id=\"What\"><a href=\"#What\" class=\"headerlink\" title=\"What\"></a>What</h3><p>这是一个独立的Blog，基于Github Pages + Jekyll，托管在Git服务器上，编写语言是Mardown，图床待定，网盘待定。</p>\n<p><code>Update 2015</code> 目前基于 Hexo 搭建，图床临时使用微博做载体。</p>\n<h3 id=\"Who\"><a href=\"#Who\" class=\"headerlink\" title=\"Who\"></a>Who</h3><p>作者<a href=\"http://about.me/bean_lee\" target=\"_blank\" rel=\"noopener\">About me</a>常常自称豆子先生，目标成为海贼王，啊！不对，是成为架构师的攻城狮一枚。</p>\n<p>关于写Blog没有任何经验，文字功底不深，但有一腔热血和语言想记录下来。</p>\n<p>目前的工作，是做一些J2EE的WEB 系统开发，自然个人最熟悉的开发语言是Java，同时也对Python, Groovy, Javascript等脚本语言有一些研究和实际应用；</p>\n<h3 id=\"When\"><a href=\"#When\" class=\"headerlink\" title=\"When\"></a>When</h3><p>Blog创建于2013年11月27日凌晨1:00</p>\n<h3 id=\"Why\"><a href=\"#Why\" class=\"headerlink\" title=\"Why\"></a>Why</h3><p>豆子先生年初制定2013年个人计划中的一项：搭建独立的个人Blog。希望这个基于Github Pages + Jekyll下搭建的Blog能够坚持维护下去，虽然目前还是雏形，还需要继续学习逐渐完善。建立Blog的初衷很简单，就是想记录豆子先生日常生活中工作、学习、生活中的一些积累和感悟。</p>\n<p>下个月找时间把个人搭建这个blog过程写一篇小教程，把整个过程，包括Blog选型，对比，搭建过程，遇到的问题，查询的资料和文档等等经验，分享给想通过GitHub Pages快速搭建Blog朋友。</p>\n<h3 id=\"How\"><a href=\"#How\" class=\"headerlink\" title=\"How\"></a>How</h3><p>经常关注各类新技术，热衷于尝试新鲜事物和新技术，收集各类有意思的软件，自从年初MacBook Pro with Retina成为主力机之后近期逐渐追加关注Mac下的各类有趣的软件，也希望有兴趣开发出有趣的App，所以今后可能在Blog中写一些软件试用的推荐小文；</p>\n<p>关注各类数码产品，半个发烧玩家！</p>\n<p>这个Blog中也会记录一些个人从之前零散记录的内容，后续也会整理总结的一些技术相关的内容，欢迎大家关注订阅<a href=\"http://beanlee.github.io/rss.xml\" target=\"_blank\" rel=\"noopener\">RSS</a>和拍砖留言。</p>\n"},{"layout":"post","title":"英雄再见","tagline":"《獵命師傳奇》最终章","description":"断断续续地在地铁上读完这本小说，九把刀的长篇《獵命師傳奇》，乱写点随笔","date":"2013-12-03T16:00:01.000Z","_content":"\n# 《獵命師傳奇》最终章完结\n\n断断续续地在地铁上读完了这本九把刀的长篇《獵命師傳奇》，说来初识九把刀还是在看过《那些年，我们一起追的女孩儿》这部电影来的，当时只是觉得这些年台湾电影成长的很快，这位有趣自大的导演第一部电影长篇就拍的如此热血，导演本人也一定非常有趣，带着疑问和好奇，我开始在网上查阅九把刀。\n\n<!-- more -->\n\n这是一个有趣的作家，在大陆很多人还在看盗版书或是用手机下载看免费网络小说的时候，这个人联合出版社出资定制了一个iOS上的应用“真·九把刀全集”来免费为读者提供他的书籍和小说。我还记得app一打开，一段5s的视频，九把刀说着：“打魔兽要钱，玩电动要钱，泡妹妹要钱，看真正的九把刀小说，不要钱！”且不说迎合了很多大陆同胞“偏爱”免费的“习惯”，说实在的，我也是这样，当意识到这个App免费就立马下载，但作为软件开发者，深知开发同胞的辛苦，小开发制作的软件还是尽量保持限免活动或者购买的方式在使用，否则还陷在网上搜来质量良莠不齐的盗版书，再拷贝到kindle中来读的境地。\n\n啰嗦了几句，简单说说，看完这部魔幻小说的感受，九把刀的热血从头贯穿至结尾，乌拉拉与乌霆奸兄弟情谊让人热血沸腾，剧情不错，文字画面感很强，推荐各位在读《獵命師傳奇》之前一定先去看短篇《卧底》，九把刀在最终章完结的时候说过，正事因为9年写《卧底》这部短篇才构思出来，吸血鬼英雄与命运掌控者猎命师，命格等等等等独立且完整的一个热血世界。\n\n第二十章是猎命师的首部曲完结，整整9年的连载，9年的时光对于任何一个人来说，之间经历过的事都是弥足珍贵的“宝藏”，作者在连载小说的几年间，经历了母亲患病、女朋友分手、服兵役、忠犬去世、交新女朋友等等，都没有过多地打扰或中断他，这种毅力也是我最喜欢他的地方，虽然他的文字有时有些无厘头，但是他的这部小说，尤其是小说里的男主角乌拉拉总是给我一种积极的态度，每天挤在地铁却也能感受到这样的能量。\n\n“正能量”这个词，我总觉得社会上用的越多越失去它真正的意义！\n\n不废话太多，这部热血的小说，推荐大家闲暇时看一看，和豆先生一起期待后续的剧情！\n\n另外看新闻说，九把刀的第二部同名小说改编电影《少林寺第八铜人》也在紧锣密鼓地拍摄中，非常期待早日上映！","source":"_posts/2013-12-04-Finished-the-book.md","raw":"---\nlayout: post\ntitle : 英雄再见\ncategory : blog\ntagline: \"《獵命師傳奇》最终章\"\ntags : [reading]\ndescription : 断断续续地在地铁上读完这本小说，九把刀的长篇《獵命師傳奇》，乱写点随笔\ndate: 2013-12-04 00:00:01\n---\n\n# 《獵命師傳奇》最终章完结\n\n断断续续地在地铁上读完了这本九把刀的长篇《獵命師傳奇》，说来初识九把刀还是在看过《那些年，我们一起追的女孩儿》这部电影来的，当时只是觉得这些年台湾电影成长的很快，这位有趣自大的导演第一部电影长篇就拍的如此热血，导演本人也一定非常有趣，带着疑问和好奇，我开始在网上查阅九把刀。\n\n<!-- more -->\n\n这是一个有趣的作家，在大陆很多人还在看盗版书或是用手机下载看免费网络小说的时候，这个人联合出版社出资定制了一个iOS上的应用“真·九把刀全集”来免费为读者提供他的书籍和小说。我还记得app一打开，一段5s的视频，九把刀说着：“打魔兽要钱，玩电动要钱，泡妹妹要钱，看真正的九把刀小说，不要钱！”且不说迎合了很多大陆同胞“偏爱”免费的“习惯”，说实在的，我也是这样，当意识到这个App免费就立马下载，但作为软件开发者，深知开发同胞的辛苦，小开发制作的软件还是尽量保持限免活动或者购买的方式在使用，否则还陷在网上搜来质量良莠不齐的盗版书，再拷贝到kindle中来读的境地。\n\n啰嗦了几句，简单说说，看完这部魔幻小说的感受，九把刀的热血从头贯穿至结尾，乌拉拉与乌霆奸兄弟情谊让人热血沸腾，剧情不错，文字画面感很强，推荐各位在读《獵命師傳奇》之前一定先去看短篇《卧底》，九把刀在最终章完结的时候说过，正事因为9年写《卧底》这部短篇才构思出来，吸血鬼英雄与命运掌控者猎命师，命格等等等等独立且完整的一个热血世界。\n\n第二十章是猎命师的首部曲完结，整整9年的连载，9年的时光对于任何一个人来说，之间经历过的事都是弥足珍贵的“宝藏”，作者在连载小说的几年间，经历了母亲患病、女朋友分手、服兵役、忠犬去世、交新女朋友等等，都没有过多地打扰或中断他，这种毅力也是我最喜欢他的地方，虽然他的文字有时有些无厘头，但是他的这部小说，尤其是小说里的男主角乌拉拉总是给我一种积极的态度，每天挤在地铁却也能感受到这样的能量。\n\n“正能量”这个词，我总觉得社会上用的越多越失去它真正的意义！\n\n不废话太多，这部热血的小说，推荐大家闲暇时看一看，和豆先生一起期待后续的剧情！\n\n另外看新闻说，九把刀的第二部同名小说改编电影《少林寺第八铜人》也在紧锣密鼓地拍摄中，非常期待早日上映！","slug":"Finished-the-book","published":1,"updated":"2017-11-04T11:09:17.000Z","comments":1,"photos":[],"link":"","_id":"cjc31n1fc000xgey5pzl35b66","content":"<h1 id=\"《獵命師傳奇》最终章完结\"><a href=\"#《獵命師傳奇》最终章完结\" class=\"headerlink\" title=\"《獵命師傳奇》最终章完结\"></a>《獵命師傳奇》最终章完结</h1><p>断断续续地在地铁上读完了这本九把刀的长篇《獵命師傳奇》，说来初识九把刀还是在看过《那些年，我们一起追的女孩儿》这部电影来的，当时只是觉得这些年台湾电影成长的很快，这位有趣自大的导演第一部电影长篇就拍的如此热血，导演本人也一定非常有趣，带着疑问和好奇，我开始在网上查阅九把刀。</p>\n<a id=\"more\"></a>\n<p>这是一个有趣的作家，在大陆很多人还在看盗版书或是用手机下载看免费网络小说的时候，这个人联合出版社出资定制了一个iOS上的应用“真·九把刀全集”来免费为读者提供他的书籍和小说。我还记得app一打开，一段5s的视频，九把刀说着：“打魔兽要钱，玩电动要钱，泡妹妹要钱，看真正的九把刀小说，不要钱！”且不说迎合了很多大陆同胞“偏爱”免费的“习惯”，说实在的，我也是这样，当意识到这个App免费就立马下载，但作为软件开发者，深知开发同胞的辛苦，小开发制作的软件还是尽量保持限免活动或者购买的方式在使用，否则还陷在网上搜来质量良莠不齐的盗版书，再拷贝到kindle中来读的境地。</p>\n<p>啰嗦了几句，简单说说，看完这部魔幻小说的感受，九把刀的热血从头贯穿至结尾，乌拉拉与乌霆奸兄弟情谊让人热血沸腾，剧情不错，文字画面感很强，推荐各位在读《獵命師傳奇》之前一定先去看短篇《卧底》，九把刀在最终章完结的时候说过，正事因为9年写《卧底》这部短篇才构思出来，吸血鬼英雄与命运掌控者猎命师，命格等等等等独立且完整的一个热血世界。</p>\n<p>第二十章是猎命师的首部曲完结，整整9年的连载，9年的时光对于任何一个人来说，之间经历过的事都是弥足珍贵的“宝藏”，作者在连载小说的几年间，经历了母亲患病、女朋友分手、服兵役、忠犬去世、交新女朋友等等，都没有过多地打扰或中断他，这种毅力也是我最喜欢他的地方，虽然他的文字有时有些无厘头，但是他的这部小说，尤其是小说里的男主角乌拉拉总是给我一种积极的态度，每天挤在地铁却也能感受到这样的能量。</p>\n<p>“正能量”这个词，我总觉得社会上用的越多越失去它真正的意义！</p>\n<p>不废话太多，这部热血的小说，推荐大家闲暇时看一看，和豆先生一起期待后续的剧情！</p>\n<p>另外看新闻说，九把刀的第二部同名小说改编电影《少林寺第八铜人》也在紧锣密鼓地拍摄中，非常期待早日上映！</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"《獵命師傳奇》最终章完结\"><a href=\"#《獵命師傳奇》最终章完结\" class=\"headerlink\" title=\"《獵命師傳奇》最终章完结\"></a>《獵命師傳奇》最终章完结</h1><p>断断续续地在地铁上读完了这本九把刀的长篇《獵命師傳奇》，说来初识九把刀还是在看过《那些年，我们一起追的女孩儿》这部电影来的，当时只是觉得这些年台湾电影成长的很快，这位有趣自大的导演第一部电影长篇就拍的如此热血，导演本人也一定非常有趣，带着疑问和好奇，我开始在网上查阅九把刀。</p>","more":"<p>这是一个有趣的作家，在大陆很多人还在看盗版书或是用手机下载看免费网络小说的时候，这个人联合出版社出资定制了一个iOS上的应用“真·九把刀全集”来免费为读者提供他的书籍和小说。我还记得app一打开，一段5s的视频，九把刀说着：“打魔兽要钱，玩电动要钱，泡妹妹要钱，看真正的九把刀小说，不要钱！”且不说迎合了很多大陆同胞“偏爱”免费的“习惯”，说实在的，我也是这样，当意识到这个App免费就立马下载，但作为软件开发者，深知开发同胞的辛苦，小开发制作的软件还是尽量保持限免活动或者购买的方式在使用，否则还陷在网上搜来质量良莠不齐的盗版书，再拷贝到kindle中来读的境地。</p>\n<p>啰嗦了几句，简单说说，看完这部魔幻小说的感受，九把刀的热血从头贯穿至结尾，乌拉拉与乌霆奸兄弟情谊让人热血沸腾，剧情不错，文字画面感很强，推荐各位在读《獵命師傳奇》之前一定先去看短篇《卧底》，九把刀在最终章完结的时候说过，正事因为9年写《卧底》这部短篇才构思出来，吸血鬼英雄与命运掌控者猎命师，命格等等等等独立且完整的一个热血世界。</p>\n<p>第二十章是猎命师的首部曲完结，整整9年的连载，9年的时光对于任何一个人来说，之间经历过的事都是弥足珍贵的“宝藏”，作者在连载小说的几年间，经历了母亲患病、女朋友分手、服兵役、忠犬去世、交新女朋友等等，都没有过多地打扰或中断他，这种毅力也是我最喜欢他的地方，虽然他的文字有时有些无厘头，但是他的这部小说，尤其是小说里的男主角乌拉拉总是给我一种积极的态度，每天挤在地铁却也能感受到这样的能量。</p>\n<p>“正能量”这个词，我总觉得社会上用的越多越失去它真正的意义！</p>\n<p>不废话太多，这部热血的小说，推荐大家闲暇时看一看，和豆先生一起期待后续的剧情！</p>\n<p>另外看新闻说，九把刀的第二部同名小说改编电影《少林寺第八铜人》也在紧锣密鼓地拍摄中，非常期待早日上映！</p>"},{"layout":"post","title":"程序员都是理想主义者","tagline":"","description":"程序员都是理想主义者","date":"2013-12-04T16:00:01.000Z","_content":"\n今天看到微博上转发的一篇长博文中写到一段话很有感触。\n\n“每个夜晚来临的时候，孤独总在我左右，在我苍白的笑容背后，有多少落寞和哀愁面对日益发达的，极具诱惑力的夜生活，少有人能置之开外。但就有那么一群人，即使黑幕高垂还栖守在工作之位，面对夜晚的繁荣和喧嚣视若无睹”。是的，他们就是程序员，一群成天编写代码的程序员，难怪有人感叹程序员是被流行和时髦给遗忘的部落“\n\n“或许，每一个属于程序员的夜晚，都是沉静的夜。但是每一个程序员都是理想主义者，内心的沉静是一股强大的力量，支持着我们坚定第一点一点地去改变这个世界”\n\n你我共勉！\n\n","source":"_posts/2013-12-05-Eassy-Programmer.md","raw":"---\nlayout: post\ntitle : 程序员都是理想主义者\ncategory : blog\ntagline: \"\"\ntags : [文字, 生活]\ndescription : 程序员都是理想主义者\ndate: 2013-12-05 00:00:01\n---\n\n今天看到微博上转发的一篇长博文中写到一段话很有感触。\n\n“每个夜晚来临的时候，孤独总在我左右，在我苍白的笑容背后，有多少落寞和哀愁面对日益发达的，极具诱惑力的夜生活，少有人能置之开外。但就有那么一群人，即使黑幕高垂还栖守在工作之位，面对夜晚的繁荣和喧嚣视若无睹”。是的，他们就是程序员，一群成天编写代码的程序员，难怪有人感叹程序员是被流行和时髦给遗忘的部落“\n\n“或许，每一个属于程序员的夜晚，都是沉静的夜。但是每一个程序员都是理想主义者，内心的沉静是一股强大的力量，支持着我们坚定第一点一点地去改变这个世界”\n\n你我共勉！\n\n","slug":"Eassy-Programmer","published":1,"updated":"2017-11-04T11:09:17.000Z","comments":1,"photos":[],"link":"","_id":"cjc31n1fe000zgey58u4mfkz0","content":"<p>今天看到微博上转发的一篇长博文中写到一段话很有感触。</p>\n<p>“每个夜晚来临的时候，孤独总在我左右，在我苍白的笑容背后，有多少落寞和哀愁面对日益发达的，极具诱惑力的夜生活，少有人能置之开外。但就有那么一群人，即使黑幕高垂还栖守在工作之位，面对夜晚的繁荣和喧嚣视若无睹”。是的，他们就是程序员，一群成天编写代码的程序员，难怪有人感叹程序员是被流行和时髦给遗忘的部落“</p>\n<p>“或许，每一个属于程序员的夜晚，都是沉静的夜。但是每一个程序员都是理想主义者，内心的沉静是一股强大的力量，支持着我们坚定第一点一点地去改变这个世界”</p>\n<p>你我共勉！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>今天看到微博上转发的一篇长博文中写到一段话很有感触。</p>\n<p>“每个夜晚来临的时候，孤独总在我左右，在我苍白的笑容背后，有多少落寞和哀愁面对日益发达的，极具诱惑力的夜生活，少有人能置之开外。但就有那么一群人，即使黑幕高垂还栖守在工作之位，面对夜晚的繁荣和喧嚣视若无睹”。是的，他们就是程序员，一群成天编写代码的程序员，难怪有人感叹程序员是被流行和时髦给遗忘的部落“</p>\n<p>“或许，每一个属于程序员的夜晚，都是沉静的夜。但是每一个程序员都是理想主义者，内心的沉静是一股强大的力量，支持着我们坚定第一点一点地去改变这个世界”</p>\n<p>你我共勉！</p>\n"},{"layout":"post","title":"微博等SNS@功能探索技术验证总结","tagline":"","description":"公司阶段技术预言项，推特微博等@人员功能，断断续续3-4天时间，做了一些总结在Blog中和大家分享","date":"2014-01-09T16:00:01.000Z","_content":"\n公司阶段技术预言项，推特微博等@人员功能，断断续续3-4天时间，做了一些总结在Blog中和大家分享\n\n<!-- more -->\n\n### 功能对比\n\n!['at1'](http://ww1.sinaimg.cn/mw690/454c4867tw1eh7jb40u64j21kw16jwun.jpg)\n\n!['at2'](http://ww3.sinaimg.cn/mw690/454c4867tw1eh7jbxfjq2j21kw16l7ji.jpg)\n\n!['at3'](http://ww4.sinaimg.cn/mw690/454c4867tw1eh7jckue5ij21kw16i4di.jpg)\n\n!['at4'](http://ww3.sinaimg.cn/mw690/454c4867tw1eh7jd9hmrdj21kw16oard.jpg)\n\n!['at5'](http://ww4.sinaimg.cn/mw690/454c4867tw1eh7jdwwe68j21kw16m4dc.jpg)\n\n!['at6'](http://ww1.sinaimg.cn/mw690/454c4867tw1eh7jekivd4j21kw16f4f4.jpg)\n\n!['at7'](http://ww2.sinaimg.cn/mw690/454c4867tw1eh7jf7bxdqj21kw16lwty.jpg)\n\n!['at8'](http://ww1.sinaimg.cn/mw690/454c4867tw1eh7jfykgw8j21kw16ined.jpg)\n","source":"_posts/2014-01-10-The-Summary-of-At.md","raw":"---\nlayout: post\ntitle : 微博等SNS@功能探索技术验证总结\ncategory : blog\ntagline: \"\"\ntags : [分享, 总结]\ndescription : 公司阶段技术预言项，推特微博等@人员功能，断断续续3-4天时间，做了一些总结在Blog中和大家分享\ndate: 2014-01-10 00:00:01\n---\n\n公司阶段技术预言项，推特微博等@人员功能，断断续续3-4天时间，做了一些总结在Blog中和大家分享\n\n<!-- more -->\n\n### 功能对比\n\n!['at1'](http://ww1.sinaimg.cn/mw690/454c4867tw1eh7jb40u64j21kw16jwun.jpg)\n\n!['at2'](http://ww3.sinaimg.cn/mw690/454c4867tw1eh7jbxfjq2j21kw16l7ji.jpg)\n\n!['at3'](http://ww4.sinaimg.cn/mw690/454c4867tw1eh7jckue5ij21kw16i4di.jpg)\n\n!['at4'](http://ww3.sinaimg.cn/mw690/454c4867tw1eh7jd9hmrdj21kw16oard.jpg)\n\n!['at5'](http://ww4.sinaimg.cn/mw690/454c4867tw1eh7jdwwe68j21kw16m4dc.jpg)\n\n!['at6'](http://ww1.sinaimg.cn/mw690/454c4867tw1eh7jekivd4j21kw16f4f4.jpg)\n\n!['at7'](http://ww2.sinaimg.cn/mw690/454c4867tw1eh7jf7bxdqj21kw16lwty.jpg)\n\n!['at8'](http://ww1.sinaimg.cn/mw690/454c4867tw1eh7jfykgw8j21kw16ined.jpg)\n","slug":"The-Summary-of-At","published":1,"updated":"2017-11-04T11:09:17.000Z","comments":1,"photos":[],"link":"","_id":"cjc31n1ff0012gey5mi8k7fjw","content":"<p>公司阶段技术预言项，推特微博等@人员功能，断断续续3-4天时间，做了一些总结在Blog中和大家分享</p>\n<a id=\"more\"></a>\n<h3 id=\"功能对比\"><a href=\"#功能对比\" class=\"headerlink\" title=\"功能对比\"></a>功能对比</h3><p><img src=\"http://ww1.sinaimg.cn/mw690/454c4867tw1eh7jb40u64j21kw16jwun.jpg\" alt=\"&#39;at1&#39;\"></p>\n<p><img src=\"http://ww3.sinaimg.cn/mw690/454c4867tw1eh7jbxfjq2j21kw16l7ji.jpg\" alt=\"&#39;at2&#39;\"></p>\n<p><img src=\"http://ww4.sinaimg.cn/mw690/454c4867tw1eh7jckue5ij21kw16i4di.jpg\" alt=\"&#39;at3&#39;\"></p>\n<p><img src=\"http://ww3.sinaimg.cn/mw690/454c4867tw1eh7jd9hmrdj21kw16oard.jpg\" alt=\"&#39;at4&#39;\"></p>\n<p><img src=\"http://ww4.sinaimg.cn/mw690/454c4867tw1eh7jdwwe68j21kw16m4dc.jpg\" alt=\"&#39;at5&#39;\"></p>\n<p><img src=\"http://ww1.sinaimg.cn/mw690/454c4867tw1eh7jekivd4j21kw16f4f4.jpg\" alt=\"&#39;at6&#39;\"></p>\n<p><img src=\"http://ww2.sinaimg.cn/mw690/454c4867tw1eh7jf7bxdqj21kw16lwty.jpg\" alt=\"&#39;at7&#39;\"></p>\n<p><img src=\"http://ww1.sinaimg.cn/mw690/454c4867tw1eh7jfykgw8j21kw16ined.jpg\" alt=\"&#39;at8&#39;\"></p>\n","site":{"data":{}},"excerpt":"<p>公司阶段技术预言项，推特微博等@人员功能，断断续续3-4天时间，做了一些总结在Blog中和大家分享</p>","more":"<h3 id=\"功能对比\"><a href=\"#功能对比\" class=\"headerlink\" title=\"功能对比\"></a>功能对比</h3><p><img src=\"http://ww1.sinaimg.cn/mw690/454c4867tw1eh7jb40u64j21kw16jwun.jpg\" alt=\"&#39;at1&#39;\"></p>\n<p><img src=\"http://ww3.sinaimg.cn/mw690/454c4867tw1eh7jbxfjq2j21kw16l7ji.jpg\" alt=\"&#39;at2&#39;\"></p>\n<p><img src=\"http://ww4.sinaimg.cn/mw690/454c4867tw1eh7jckue5ij21kw16i4di.jpg\" alt=\"&#39;at3&#39;\"></p>\n<p><img src=\"http://ww3.sinaimg.cn/mw690/454c4867tw1eh7jd9hmrdj21kw16oard.jpg\" alt=\"&#39;at4&#39;\"></p>\n<p><img src=\"http://ww4.sinaimg.cn/mw690/454c4867tw1eh7jdwwe68j21kw16m4dc.jpg\" alt=\"&#39;at5&#39;\"></p>\n<p><img src=\"http://ww1.sinaimg.cn/mw690/454c4867tw1eh7jekivd4j21kw16f4f4.jpg\" alt=\"&#39;at6&#39;\"></p>\n<p><img src=\"http://ww2.sinaimg.cn/mw690/454c4867tw1eh7jf7bxdqj21kw16lwty.jpg\" alt=\"&#39;at7&#39;\"></p>\n<p><img src=\"http://ww1.sinaimg.cn/mw690/454c4867tw1eh7jfykgw8j21kw16ined.jpg\" alt=\"&#39;at8&#39;\"></p>"},{"layout":"post","title":"书摘随笔","tagline":"","description":"读《创业时，我们在知乎聊什么》书摘随笔一","date":"2014-03-19T16:00:01.000Z","_content":"\n读《创业时，我们在知乎聊什么》书摘随笔一\n\n> 最小化可行产品 汪华说，你一开始的所有计划其实只是对用户和市场的假定而已，小团队的钱和资源也都有限，必须先快速地找个办法验证方向。 所以产品的第一个版本的目的，是验证用户需求和反馈，而不是做一个完美无缺、功能丰富的版本。第一版应该集中于开发出产品的核心功能和核心需求，也就是那个用户。\n\n<!-- more -->\n\n建议：\n\n* 1、尽量地使用现成的代码框架、末班、开源项目、API，使用现成的工具，哪怕不是100%符合需要，有了用户量之后再重构。\n* 2、第一版可以简单解决，部分可用静态页面或者人工干预。\n* 3、在完成功能的过程中考虑后续版本的可升级性，但不要过分专注，否则会影响进度。\n* 4、找到所有相似、相关、上下游产品重新学习。\n* 5、如果是互联网产品想清楚需要验证什么用户行为和数据，并在产品中跟踪收集，不要盲目收集。\n* 6、界面简洁，保证核心功能在主要位置，且一键访问无歧义最好。\n* 7、专注80%精力在核心功能上，核心要完美，其余部分可以后完善，否则顾此失彼。\n* 8、快速、稳定，很多东西不是一定必须，能砍则砍。\n* 9、重视用户反馈，建立社区或者有效沟通平台。\n* 10、外围也不可忽视，类似门户网站等尽量有新意。\n* 11、如果专职严格进度，日毕日清，不为严重问题拖延。","source":"_posts/2014-03-20-Read-The-Book-Of-Zhihu.md","raw":"---\nlayout: post\ntitle : 书摘随笔\ncategory : blog\ntagline: \"\"\ntags : [reading]\ndescription : 读《创业时，我们在知乎聊什么》书摘随笔一\ndate: 2014-03-20 00:00:01\n---\n\n读《创业时，我们在知乎聊什么》书摘随笔一\n\n> 最小化可行产品 汪华说，你一开始的所有计划其实只是对用户和市场的假定而已，小团队的钱和资源也都有限，必须先快速地找个办法验证方向。 所以产品的第一个版本的目的，是验证用户需求和反馈，而不是做一个完美无缺、功能丰富的版本。第一版应该集中于开发出产品的核心功能和核心需求，也就是那个用户。\n\n<!-- more -->\n\n建议：\n\n* 1、尽量地使用现成的代码框架、末班、开源项目、API，使用现成的工具，哪怕不是100%符合需要，有了用户量之后再重构。\n* 2、第一版可以简单解决，部分可用静态页面或者人工干预。\n* 3、在完成功能的过程中考虑后续版本的可升级性，但不要过分专注，否则会影响进度。\n* 4、找到所有相似、相关、上下游产品重新学习。\n* 5、如果是互联网产品想清楚需要验证什么用户行为和数据，并在产品中跟踪收集，不要盲目收集。\n* 6、界面简洁，保证核心功能在主要位置，且一键访问无歧义最好。\n* 7、专注80%精力在核心功能上，核心要完美，其余部分可以后完善，否则顾此失彼。\n* 8、快速、稳定，很多东西不是一定必须，能砍则砍。\n* 9、重视用户反馈，建立社区或者有效沟通平台。\n* 10、外围也不可忽视，类似门户网站等尽量有新意。\n* 11、如果专职严格进度，日毕日清，不为严重问题拖延。","slug":"Read-The-Book-Of-Zhihu","published":1,"updated":"2017-11-04T11:09:17.000Z","comments":1,"photos":[],"link":"","_id":"cjc31n1fg0016gey56z0bvzl7","content":"<p>读《创业时，我们在知乎聊什么》书摘随笔一</p>\n<blockquote>\n<p>最小化可行产品 汪华说，你一开始的所有计划其实只是对用户和市场的假定而已，小团队的钱和资源也都有限，必须先快速地找个办法验证方向。 所以产品的第一个版本的目的，是验证用户需求和反馈，而不是做一个完美无缺、功能丰富的版本。第一版应该集中于开发出产品的核心功能和核心需求，也就是那个用户。</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>建议：</p>\n<ul>\n<li>1、尽量地使用现成的代码框架、末班、开源项目、API，使用现成的工具，哪怕不是100%符合需要，有了用户量之后再重构。</li>\n<li>2、第一版可以简单解决，部分可用静态页面或者人工干预。</li>\n<li>3、在完成功能的过程中考虑后续版本的可升级性，但不要过分专注，否则会影响进度。</li>\n<li>4、找到所有相似、相关、上下游产品重新学习。</li>\n<li>5、如果是互联网产品想清楚需要验证什么用户行为和数据，并在产品中跟踪收集，不要盲目收集。</li>\n<li>6、界面简洁，保证核心功能在主要位置，且一键访问无歧义最好。</li>\n<li>7、专注80%精力在核心功能上，核心要完美，其余部分可以后完善，否则顾此失彼。</li>\n<li>8、快速、稳定，很多东西不是一定必须，能砍则砍。</li>\n<li>9、重视用户反馈，建立社区或者有效沟通平台。</li>\n<li>10、外围也不可忽视，类似门户网站等尽量有新意。</li>\n<li>11、如果专职严格进度，日毕日清，不为严重问题拖延。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>读《创业时，我们在知乎聊什么》书摘随笔一</p>\n<blockquote>\n<p>最小化可行产品 汪华说，你一开始的所有计划其实只是对用户和市场的假定而已，小团队的钱和资源也都有限，必须先快速地找个办法验证方向。 所以产品的第一个版本的目的，是验证用户需求和反馈，而不是做一个完美无缺、功能丰富的版本。第一版应该集中于开发出产品的核心功能和核心需求，也就是那个用户。</p>\n</blockquote>","more":"<p>建议：</p>\n<ul>\n<li>1、尽量地使用现成的代码框架、末班、开源项目、API，使用现成的工具，哪怕不是100%符合需要，有了用户量之后再重构。</li>\n<li>2、第一版可以简单解决，部分可用静态页面或者人工干预。</li>\n<li>3、在完成功能的过程中考虑后续版本的可升级性，但不要过分专注，否则会影响进度。</li>\n<li>4、找到所有相似、相关、上下游产品重新学习。</li>\n<li>5、如果是互联网产品想清楚需要验证什么用户行为和数据，并在产品中跟踪收集，不要盲目收集。</li>\n<li>6、界面简洁，保证核心功能在主要位置，且一键访问无歧义最好。</li>\n<li>7、专注80%精力在核心功能上，核心要完美，其余部分可以后完善，否则顾此失彼。</li>\n<li>8、快速、稳定，很多东西不是一定必须，能砍则砍。</li>\n<li>9、重视用户反馈，建立社区或者有效沟通平台。</li>\n<li>10、外围也不可忽视，类似门户网站等尽量有新意。</li>\n<li>11、如果专职严格进度，日毕日清，不为严重问题拖延。</li>\n</ul>"},{"layout":"post","title":"有设计感的数码产品才能打动人心","tagline":"","description":"夏日来袭，笔者对比了几款运动手环，最终入手Misfit Shine带来开箱图文和简单对比分享","date":"2014-04-11T16:00:01.000Z","_content":"\n夏日来袭，笔者对比了几款运动手环，最终入手Misfit Shine带来开箱图文和简单对比分享\n\n<!-- more -->\n\n### 运动快乐\n笔者很喜爱有氧运动，偏爱足球和跑步，小时候就经常抱着足球跟着一帮小伙伴去虽然满是尘土的足球场。（PS.这里吐槽一下，很多人吐槽国足，国内的足球氛围不浓，连基础设备完善的足球场都很少，尤其是在二三线城市）\n\n先来和各位分享一下当时购买这款运动手环的初衷，应该说早在2012年的Google Glass在全球兴起了穿戴式数码设备的热潮，诸多厂商都在各自的领域跟进，这其中运动检测类的运动手环，种类颇为丰富。笔者一直是个夜跑爱好者，期初对此并没有太大需求也就没有关注。直到时隔2年后，无意间在网络中看到百度旗下公司也有一款运动手环，即将发布的新闻才再次被勾起兴趣，通过网络搜索一些资料查阅了解，越发感觉穿戴式数码产品对生活的重要性越来越大，因此决定购入，以此激励自己加强运动，运动最快乐！\n\n### 简单介绍\n根据Shine的名字自行Google :)\n\n### 三款手环简单对比\n笔者的数码硬件消费级别，尚处于“屌丝”级别，包括每次买很多数码电子产品都要经过一段时间研究和对比，纠结过才会购买，这款也同样不例外。这里只简单说明一下三种智能手环的差异。\n\n* Jawbone UP\n* Fitbit Flex\n* Misfit Shine\n\n!['compare'](http://ww4.sinaimg.cn/mw690/454c4867gw1efc2f6n55ij20ug0ee41k.jpg)\n\n### Some Pics\n\n!['misfit'](http://ww3.sinaimg.cn/mw690/454c4867gw1efc2cbmd5lj20qo140wor.jpg)\n\n### Shine优缺点\n\n### 优点\n * 科技感、设计感十足，硬币大小戴在手上非常酷，通过几天的使用测试，运动记忆比较精准，包括睡眠模式中记录深度睡眠的时长，相对比较准确。\n * 在2013年获得红点设计奖，小小的运动检测器，戴的时间长了存在感非常小，不会影响正常生活，在收集资料的过程中，笔者看到很多网上的朋友甚至丢了好几天，想起来同步运动信息的时候才发现找不到的情况。（这也可能变相的算是一种缺点吧:P）\n * Shine没有具象的显示器或者曲面屏幕，而且采用防水设计材质非常好的金属，用激光蚀刻的小孔伴随着小小的LED，轻拍两下，显示目前完成了当天既定目标的百分比，和很酷的点数时间，初看有些摸不到头脑但笔者使用几天下来基本习惯快速时间时间；轻拍三下，就可以自动切换运动模式，比如跑步、游泳、足球等。\n\n### 缺点\n * 缺少其他手环中比较方便实用的智能唤醒闹钟，通过在手腕上的轻微震动达到闹钟作用的功能，相信不少上班族的朋友每天清晨都偶尔会被刺耳的闹铃叫醒，非常不爽！PS.如果想永远不再想听一首歌，那就把它设置成闹钟吧！\n * 与手机App同步没有实现真正的自动同步，由于新鲜感，笔者会每天多次拿起手机点开Shine的App点击同步，相信以后频率会下降，目前每天早上打开App看自己前一天晚上深度睡眠时间倒是一件非常有意思的事。\n * App的SNS特性，相比国内相似运动类App略差，但换个思路，也许Shine团队是为了人们更加关注运动，他们比较和互动不应该喧宾夺主也说不定。\n\n\n\n### The End\n\nMisfit Shine对于笔者来说是个很好的选择，我可以接受它的全部优缺点，并且在使用过程中会把自己的意见和体验结果通过邮件的方式反馈给Misfit的团队。（天晓得我的邮件中的英文他们能不能看懂或者根本被忽视掉也说不定）\n\n原本想在这篇写完之前可以戴着Shine踢球，看看记录是什么样的，碰巧本周没有机会","source":"_posts/2014-04-12-Misfit-Shine.md","raw":"---\nlayout: post\ntitle : 有设计感的数码产品才能打动人心\ncategory : blog\ntagline: \"\"\ntags : [digital, 数码]\ndescription : 夏日来袭，笔者对比了几款运动手环，最终入手Misfit Shine带来开箱图文和简单对比分享\ndate: 2014-04-12 00:00:01\n---\n\n夏日来袭，笔者对比了几款运动手环，最终入手Misfit Shine带来开箱图文和简单对比分享\n\n<!-- more -->\n\n### 运动快乐\n笔者很喜爱有氧运动，偏爱足球和跑步，小时候就经常抱着足球跟着一帮小伙伴去虽然满是尘土的足球场。（PS.这里吐槽一下，很多人吐槽国足，国内的足球氛围不浓，连基础设备完善的足球场都很少，尤其是在二三线城市）\n\n先来和各位分享一下当时购买这款运动手环的初衷，应该说早在2012年的Google Glass在全球兴起了穿戴式数码设备的热潮，诸多厂商都在各自的领域跟进，这其中运动检测类的运动手环，种类颇为丰富。笔者一直是个夜跑爱好者，期初对此并没有太大需求也就没有关注。直到时隔2年后，无意间在网络中看到百度旗下公司也有一款运动手环，即将发布的新闻才再次被勾起兴趣，通过网络搜索一些资料查阅了解，越发感觉穿戴式数码产品对生活的重要性越来越大，因此决定购入，以此激励自己加强运动，运动最快乐！\n\n### 简单介绍\n根据Shine的名字自行Google :)\n\n### 三款手环简单对比\n笔者的数码硬件消费级别，尚处于“屌丝”级别，包括每次买很多数码电子产品都要经过一段时间研究和对比，纠结过才会购买，这款也同样不例外。这里只简单说明一下三种智能手环的差异。\n\n* Jawbone UP\n* Fitbit Flex\n* Misfit Shine\n\n!['compare'](http://ww4.sinaimg.cn/mw690/454c4867gw1efc2f6n55ij20ug0ee41k.jpg)\n\n### Some Pics\n\n!['misfit'](http://ww3.sinaimg.cn/mw690/454c4867gw1efc2cbmd5lj20qo140wor.jpg)\n\n### Shine优缺点\n\n### 优点\n * 科技感、设计感十足，硬币大小戴在手上非常酷，通过几天的使用测试，运动记忆比较精准，包括睡眠模式中记录深度睡眠的时长，相对比较准确。\n * 在2013年获得红点设计奖，小小的运动检测器，戴的时间长了存在感非常小，不会影响正常生活，在收集资料的过程中，笔者看到很多网上的朋友甚至丢了好几天，想起来同步运动信息的时候才发现找不到的情况。（这也可能变相的算是一种缺点吧:P）\n * Shine没有具象的显示器或者曲面屏幕，而且采用防水设计材质非常好的金属，用激光蚀刻的小孔伴随着小小的LED，轻拍两下，显示目前完成了当天既定目标的百分比，和很酷的点数时间，初看有些摸不到头脑但笔者使用几天下来基本习惯快速时间时间；轻拍三下，就可以自动切换运动模式，比如跑步、游泳、足球等。\n\n### 缺点\n * 缺少其他手环中比较方便实用的智能唤醒闹钟，通过在手腕上的轻微震动达到闹钟作用的功能，相信不少上班族的朋友每天清晨都偶尔会被刺耳的闹铃叫醒，非常不爽！PS.如果想永远不再想听一首歌，那就把它设置成闹钟吧！\n * 与手机App同步没有实现真正的自动同步，由于新鲜感，笔者会每天多次拿起手机点开Shine的App点击同步，相信以后频率会下降，目前每天早上打开App看自己前一天晚上深度睡眠时间倒是一件非常有意思的事。\n * App的SNS特性，相比国内相似运动类App略差，但换个思路，也许Shine团队是为了人们更加关注运动，他们比较和互动不应该喧宾夺主也说不定。\n\n\n\n### The End\n\nMisfit Shine对于笔者来说是个很好的选择，我可以接受它的全部优缺点，并且在使用过程中会把自己的意见和体验结果通过邮件的方式反馈给Misfit的团队。（天晓得我的邮件中的英文他们能不能看懂或者根本被忽视掉也说不定）\n\n原本想在这篇写完之前可以戴着Shine踢球，看看记录是什么样的，碰巧本周没有机会","slug":"Misfit-Shine","published":1,"updated":"2017-11-04T11:09:17.000Z","comments":1,"photos":[],"link":"","_id":"cjc31n1fh0019gey5pzi6k7vl","content":"<p>夏日来袭，笔者对比了几款运动手环，最终入手Misfit Shine带来开箱图文和简单对比分享</p>\n<a id=\"more\"></a>\n<h3 id=\"运动快乐\"><a href=\"#运动快乐\" class=\"headerlink\" title=\"运动快乐\"></a>运动快乐</h3><p>笔者很喜爱有氧运动，偏爱足球和跑步，小时候就经常抱着足球跟着一帮小伙伴去虽然满是尘土的足球场。（PS.这里吐槽一下，很多人吐槽国足，国内的足球氛围不浓，连基础设备完善的足球场都很少，尤其是在二三线城市）</p>\n<p>先来和各位分享一下当时购买这款运动手环的初衷，应该说早在2012年的Google Glass在全球兴起了穿戴式数码设备的热潮，诸多厂商都在各自的领域跟进，这其中运动检测类的运动手环，种类颇为丰富。笔者一直是个夜跑爱好者，期初对此并没有太大需求也就没有关注。直到时隔2年后，无意间在网络中看到百度旗下公司也有一款运动手环，即将发布的新闻才再次被勾起兴趣，通过网络搜索一些资料查阅了解，越发感觉穿戴式数码产品对生活的重要性越来越大，因此决定购入，以此激励自己加强运动，运动最快乐！</p>\n<h3 id=\"简单介绍\"><a href=\"#简单介绍\" class=\"headerlink\" title=\"简单介绍\"></a>简单介绍</h3><p>根据Shine的名字自行Google :)</p>\n<h3 id=\"三款手环简单对比\"><a href=\"#三款手环简单对比\" class=\"headerlink\" title=\"三款手环简单对比\"></a>三款手环简单对比</h3><p>笔者的数码硬件消费级别，尚处于“屌丝”级别，包括每次买很多数码电子产品都要经过一段时间研究和对比，纠结过才会购买，这款也同样不例外。这里只简单说明一下三种智能手环的差异。</p>\n<ul>\n<li>Jawbone UP</li>\n<li>Fitbit Flex</li>\n<li>Misfit Shine</li>\n</ul>\n<p><img src=\"http://ww4.sinaimg.cn/mw690/454c4867gw1efc2f6n55ij20ug0ee41k.jpg\" alt=\"&#39;compare&#39;\"></p>\n<h3 id=\"Some-Pics\"><a href=\"#Some-Pics\" class=\"headerlink\" title=\"Some Pics\"></a>Some Pics</h3><p><img src=\"http://ww3.sinaimg.cn/mw690/454c4867gw1efc2cbmd5lj20qo140wor.jpg\" alt=\"&#39;misfit&#39;\"></p>\n<h3 id=\"Shine优缺点\"><a href=\"#Shine优缺点\" class=\"headerlink\" title=\"Shine优缺点\"></a>Shine优缺点</h3><h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ul>\n<li>科技感、设计感十足，硬币大小戴在手上非常酷，通过几天的使用测试，运动记忆比较精准，包括睡眠模式中记录深度睡眠的时长，相对比较准确。</li>\n<li>在2013年获得红点设计奖，小小的运动检测器，戴的时间长了存在感非常小，不会影响正常生活，在收集资料的过程中，笔者看到很多网上的朋友甚至丢了好几天，想起来同步运动信息的时候才发现找不到的情况。（这也可能变相的算是一种缺点吧:P）</li>\n<li>Shine没有具象的显示器或者曲面屏幕，而且采用防水设计材质非常好的金属，用激光蚀刻的小孔伴随着小小的LED，轻拍两下，显示目前完成了当天既定目标的百分比，和很酷的点数时间，初看有些摸不到头脑但笔者使用几天下来基本习惯快速时间时间；轻拍三下，就可以自动切换运动模式，比如跑步、游泳、足球等。</li>\n</ul>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><ul>\n<li>缺少其他手环中比较方便实用的智能唤醒闹钟，通过在手腕上的轻微震动达到闹钟作用的功能，相信不少上班族的朋友每天清晨都偶尔会被刺耳的闹铃叫醒，非常不爽！PS.如果想永远不再想听一首歌，那就把它设置成闹钟吧！</li>\n<li>与手机App同步没有实现真正的自动同步，由于新鲜感，笔者会每天多次拿起手机点开Shine的App点击同步，相信以后频率会下降，目前每天早上打开App看自己前一天晚上深度睡眠时间倒是一件非常有意思的事。</li>\n<li>App的SNS特性，相比国内相似运动类App略差，但换个思路，也许Shine团队是为了人们更加关注运动，他们比较和互动不应该喧宾夺主也说不定。</li>\n</ul>\n<h3 id=\"The-End\"><a href=\"#The-End\" class=\"headerlink\" title=\"The End\"></a>The End</h3><p>Misfit Shine对于笔者来说是个很好的选择，我可以接受它的全部优缺点，并且在使用过程中会把自己的意见和体验结果通过邮件的方式反馈给Misfit的团队。（天晓得我的邮件中的英文他们能不能看懂或者根本被忽视掉也说不定）</p>\n<p>原本想在这篇写完之前可以戴着Shine踢球，看看记录是什么样的，碰巧本周没有机会</p>\n","site":{"data":{}},"excerpt":"<p>夏日来袭，笔者对比了几款运动手环，最终入手Misfit Shine带来开箱图文和简单对比分享</p>","more":"<h3 id=\"运动快乐\"><a href=\"#运动快乐\" class=\"headerlink\" title=\"运动快乐\"></a>运动快乐</h3><p>笔者很喜爱有氧运动，偏爱足球和跑步，小时候就经常抱着足球跟着一帮小伙伴去虽然满是尘土的足球场。（PS.这里吐槽一下，很多人吐槽国足，国内的足球氛围不浓，连基础设备完善的足球场都很少，尤其是在二三线城市）</p>\n<p>先来和各位分享一下当时购买这款运动手环的初衷，应该说早在2012年的Google Glass在全球兴起了穿戴式数码设备的热潮，诸多厂商都在各自的领域跟进，这其中运动检测类的运动手环，种类颇为丰富。笔者一直是个夜跑爱好者，期初对此并没有太大需求也就没有关注。直到时隔2年后，无意间在网络中看到百度旗下公司也有一款运动手环，即将发布的新闻才再次被勾起兴趣，通过网络搜索一些资料查阅了解，越发感觉穿戴式数码产品对生活的重要性越来越大，因此决定购入，以此激励自己加强运动，运动最快乐！</p>\n<h3 id=\"简单介绍\"><a href=\"#简单介绍\" class=\"headerlink\" title=\"简单介绍\"></a>简单介绍</h3><p>根据Shine的名字自行Google :)</p>\n<h3 id=\"三款手环简单对比\"><a href=\"#三款手环简单对比\" class=\"headerlink\" title=\"三款手环简单对比\"></a>三款手环简单对比</h3><p>笔者的数码硬件消费级别，尚处于“屌丝”级别，包括每次买很多数码电子产品都要经过一段时间研究和对比，纠结过才会购买，这款也同样不例外。这里只简单说明一下三种智能手环的差异。</p>\n<ul>\n<li>Jawbone UP</li>\n<li>Fitbit Flex</li>\n<li>Misfit Shine</li>\n</ul>\n<p><img src=\"http://ww4.sinaimg.cn/mw690/454c4867gw1efc2f6n55ij20ug0ee41k.jpg\" alt=\"&#39;compare&#39;\"></p>\n<h3 id=\"Some-Pics\"><a href=\"#Some-Pics\" class=\"headerlink\" title=\"Some Pics\"></a>Some Pics</h3><p><img src=\"http://ww3.sinaimg.cn/mw690/454c4867gw1efc2cbmd5lj20qo140wor.jpg\" alt=\"&#39;misfit&#39;\"></p>\n<h3 id=\"Shine优缺点\"><a href=\"#Shine优缺点\" class=\"headerlink\" title=\"Shine优缺点\"></a>Shine优缺点</h3><h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ul>\n<li>科技感、设计感十足，硬币大小戴在手上非常酷，通过几天的使用测试，运动记忆比较精准，包括睡眠模式中记录深度睡眠的时长，相对比较准确。</li>\n<li>在2013年获得红点设计奖，小小的运动检测器，戴的时间长了存在感非常小，不会影响正常生活，在收集资料的过程中，笔者看到很多网上的朋友甚至丢了好几天，想起来同步运动信息的时候才发现找不到的情况。（这也可能变相的算是一种缺点吧:P）</li>\n<li>Shine没有具象的显示器或者曲面屏幕，而且采用防水设计材质非常好的金属，用激光蚀刻的小孔伴随着小小的LED，轻拍两下，显示目前完成了当天既定目标的百分比，和很酷的点数时间，初看有些摸不到头脑但笔者使用几天下来基本习惯快速时间时间；轻拍三下，就可以自动切换运动模式，比如跑步、游泳、足球等。</li>\n</ul>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><ul>\n<li>缺少其他手环中比较方便实用的智能唤醒闹钟，通过在手腕上的轻微震动达到闹钟作用的功能，相信不少上班族的朋友每天清晨都偶尔会被刺耳的闹铃叫醒，非常不爽！PS.如果想永远不再想听一首歌，那就把它设置成闹钟吧！</li>\n<li>与手机App同步没有实现真正的自动同步，由于新鲜感，笔者会每天多次拿起手机点开Shine的App点击同步，相信以后频率会下降，目前每天早上打开App看自己前一天晚上深度睡眠时间倒是一件非常有意思的事。</li>\n<li>App的SNS特性，相比国内相似运动类App略差，但换个思路，也许Shine团队是为了人们更加关注运动，他们比较和互动不应该喧宾夺主也说不定。</li>\n</ul>\n<h3 id=\"The-End\"><a href=\"#The-End\" class=\"headerlink\" title=\"The End\"></a>The End</h3><p>Misfit Shine对于笔者来说是个很好的选择，我可以接受它的全部优缺点，并且在使用过程中会把自己的意见和体验结果通过邮件的方式反馈给Misfit的团队。（天晓得我的邮件中的英文他们能不能看懂或者根本被忽视掉也说不定）</p>\n<p>原本想在这篇写完之前可以戴着Shine踢球，看看记录是什么样的，碰巧本周没有机会</p>"},{"layout":"post","title":"Java基础集合类复习","tagline":"","description":"Java基础集合类的问题简单整理","date":"2014-06-05T16:00:01.000Z","_content":"\nJava基础集合类的问题简单整理\n\n<!--more-->\n\n# JAVA基础集合类Review\n\n##JAVA集合类分类\n* Collection：通常是一组有一定规律的独立元素。List必须按照特定的顺序持有这些元素，而Set则不能保存重复的元素。\n* Map：一组以“键－－值”（key-value）形式出现的pairs。\n\n\n### Collection Interface\nCollection是最基本的集合接口，它下面的实现类包括List(LinkedList, ArrayList,Vector)、Set等。\n\n* List接口是有序的Collection，每一个元素都能够被用户使用索引来访问，类似Java中的数组。与Set不同，List允许存在相同的元素。\n\n  LinkedList:它是有序的允许元素为null，并且提供额外的get，remove，insert方法来操作LinkedList的首或尾部，类似链表的结构，可以用来实现堆栈（Stack）、队列（Queue）或者双向队列（Deque），它是不同步的。\n\n  ArrayList:它的内部实现机制实际上使用的是Object数组，且一个大小可变，但是每一个ArrayList在初始化时都有一个容量，外部看这个容量是可以根据元素的添加自动增加。当容量不够时，系统就会创建一个更大的数组（1.5倍左右）并且把老的数组完全拷贝到新的数组中，同时老数组就自动进入GC待处理状态，等待垃圾回收。\n\n  相比LinkedList，ArrayList中的get(index)的方法速度较快，效率高。\n\n  Vector:线程同步的ArrayList，当一个线程开始迭代Vector时，另一个线程来添加、删除等改变Vector时，就会抛出ConcurrentModificationException。\n\n  Stack:继承自Vector，从名字可以看出堆栈，它实现了一个后进先出的堆栈。\n\n\n* Set接口是一种不允许重复的Collection，即任意的两个元素e1和e2都有e1.equals(e2)=false，Set最多有一个null元素。这其中equals方法就是依靠元素的hashCode来判断是否相等，有时可以通过重写一些对象的HashCode方法来改变判断相等的判断逻辑。\n\n### Map Interface\n\n* HashTable\n  \n  HashTable集成Map接口，实现了一个key-value映射的哈希表。任何非空（non-null）的对象都可以作为key或value。HashTable是线程同步的。\n  \n  不了解的知识点：Hashtable通过initial capacity和load factor两个参数调整性能。通常缺省的load factor 0.75较好地实现了时间和空间的均衡。增大load factor可以节省空间但相应的查找时间将增大，这会影响像get和put这样的操作。\n  \n  hashCode和equals方法是否重写相关：\n  \n* HashMap\n  \n  HashMap和Hashtable类似，不同之处在于HashMap是非同步的，并且允许null，即null value和null key。，但是将HashMap视为Collection时（values()方法可返回Collection），其迭代子操作时间开销和HashMap 的容量成比例。因此，如果迭代操作的性能相当重要的话，不要将HashMap的初始化容量设得过高，或者load factor过低。\n  \n* WeakHashMap\n\n  WeakHashMap是一种改进的HashMap，它对key实行“弱引用”，如果一个key不再被外部所引用，那么该key可以被GC回收。实际开发中还没有用过，可以尝试用一下。\n\n## 总结\n\n* List集合是有序集合，集合中的元素可以重复，访问集合中的元素可以根据元素的索引来访问。\n* Set集合是无序集合，集合中的元素不可以重复，访问集合中的元素只能根据元素本身来访问（也是不能集合里元素不允许重复的原因）。\n* Map集合中保存Key-value对形式的元素，访问时只能根据每项元素的key来访问其value。\n* 如果涉及到堆栈，队列等操作，应该考虑用List，对于需要快速插入，删除元素，应该使用LinkedList，如果需要快速随机访问元素，应该使用ArrayList。\n* 如果程序在单线程环境中，或者访问仅仅在一个线程中进行，考虑非同步的类，其效率较高，如果多个线程可能同时操作一个类，应该使用同步的类。要特别注意对哈希表的操作，作为key的对象要正确复写equals和hashCode方法。\n* 尽量返回接口而非实际的类型，如返回List而非ArrayList，这样如果以后需要将ArrayList换成LinkedList时，客户端代码不用改变。这就是针对抽象编程。\n\n## 参考\n[柳志超Blog中一篇文章《Java集合类》](http://liuzhichao.com/p/652.html)\n\n","source":"_posts/2014-06-06-Java-Collection-Review.md","raw":"---\nlayout: post\ntitle : Java基础集合类复习\ncategory : blog\ntagline: \"\"\ntags : [Java, 总结]\ndescription : Java基础集合类的问题简单整理\ndate: 2014-06-06 00:00:01\n---\n\nJava基础集合类的问题简单整理\n\n<!--more-->\n\n# JAVA基础集合类Review\n\n##JAVA集合类分类\n* Collection：通常是一组有一定规律的独立元素。List必须按照特定的顺序持有这些元素，而Set则不能保存重复的元素。\n* Map：一组以“键－－值”（key-value）形式出现的pairs。\n\n\n### Collection Interface\nCollection是最基本的集合接口，它下面的实现类包括List(LinkedList, ArrayList,Vector)、Set等。\n\n* List接口是有序的Collection，每一个元素都能够被用户使用索引来访问，类似Java中的数组。与Set不同，List允许存在相同的元素。\n\n  LinkedList:它是有序的允许元素为null，并且提供额外的get，remove，insert方法来操作LinkedList的首或尾部，类似链表的结构，可以用来实现堆栈（Stack）、队列（Queue）或者双向队列（Deque），它是不同步的。\n\n  ArrayList:它的内部实现机制实际上使用的是Object数组，且一个大小可变，但是每一个ArrayList在初始化时都有一个容量，外部看这个容量是可以根据元素的添加自动增加。当容量不够时，系统就会创建一个更大的数组（1.5倍左右）并且把老的数组完全拷贝到新的数组中，同时老数组就自动进入GC待处理状态，等待垃圾回收。\n\n  相比LinkedList，ArrayList中的get(index)的方法速度较快，效率高。\n\n  Vector:线程同步的ArrayList，当一个线程开始迭代Vector时，另一个线程来添加、删除等改变Vector时，就会抛出ConcurrentModificationException。\n\n  Stack:继承自Vector，从名字可以看出堆栈，它实现了一个后进先出的堆栈。\n\n\n* Set接口是一种不允许重复的Collection，即任意的两个元素e1和e2都有e1.equals(e2)=false，Set最多有一个null元素。这其中equals方法就是依靠元素的hashCode来判断是否相等，有时可以通过重写一些对象的HashCode方法来改变判断相等的判断逻辑。\n\n### Map Interface\n\n* HashTable\n  \n  HashTable集成Map接口，实现了一个key-value映射的哈希表。任何非空（non-null）的对象都可以作为key或value。HashTable是线程同步的。\n  \n  不了解的知识点：Hashtable通过initial capacity和load factor两个参数调整性能。通常缺省的load factor 0.75较好地实现了时间和空间的均衡。增大load factor可以节省空间但相应的查找时间将增大，这会影响像get和put这样的操作。\n  \n  hashCode和equals方法是否重写相关：\n  \n* HashMap\n  \n  HashMap和Hashtable类似，不同之处在于HashMap是非同步的，并且允许null，即null value和null key。，但是将HashMap视为Collection时（values()方法可返回Collection），其迭代子操作时间开销和HashMap 的容量成比例。因此，如果迭代操作的性能相当重要的话，不要将HashMap的初始化容量设得过高，或者load factor过低。\n  \n* WeakHashMap\n\n  WeakHashMap是一种改进的HashMap，它对key实行“弱引用”，如果一个key不再被外部所引用，那么该key可以被GC回收。实际开发中还没有用过，可以尝试用一下。\n\n## 总结\n\n* List集合是有序集合，集合中的元素可以重复，访问集合中的元素可以根据元素的索引来访问。\n* Set集合是无序集合，集合中的元素不可以重复，访问集合中的元素只能根据元素本身来访问（也是不能集合里元素不允许重复的原因）。\n* Map集合中保存Key-value对形式的元素，访问时只能根据每项元素的key来访问其value。\n* 如果涉及到堆栈，队列等操作，应该考虑用List，对于需要快速插入，删除元素，应该使用LinkedList，如果需要快速随机访问元素，应该使用ArrayList。\n* 如果程序在单线程环境中，或者访问仅仅在一个线程中进行，考虑非同步的类，其效率较高，如果多个线程可能同时操作一个类，应该使用同步的类。要特别注意对哈希表的操作，作为key的对象要正确复写equals和hashCode方法。\n* 尽量返回接口而非实际的类型，如返回List而非ArrayList，这样如果以后需要将ArrayList换成LinkedList时，客户端代码不用改变。这就是针对抽象编程。\n\n## 参考\n[柳志超Blog中一篇文章《Java集合类》](http://liuzhichao.com/p/652.html)\n\n","slug":"Java-Collection-Review","published":1,"updated":"2017-11-04T11:09:17.000Z","comments":1,"photos":[],"link":"","_id":"cjc31n1fj001dgey55m4qdzs5","content":"<p>Java基础集合类的问题简单整理</p>\n<a id=\"more\"></a>\n<h1 id=\"JAVA基础集合类Review\"><a href=\"#JAVA基础集合类Review\" class=\"headerlink\" title=\"JAVA基础集合类Review\"></a>JAVA基础集合类Review</h1><p>##JAVA集合类分类</p>\n<ul>\n<li>Collection：通常是一组有一定规律的独立元素。List必须按照特定的顺序持有这些元素，而Set则不能保存重复的元素。</li>\n<li>Map：一组以“键－－值”（key-value）形式出现的pairs。</li>\n</ul>\n<h3 id=\"Collection-Interface\"><a href=\"#Collection-Interface\" class=\"headerlink\" title=\"Collection Interface\"></a>Collection Interface</h3><p>Collection是最基本的集合接口，它下面的实现类包括List(LinkedList, ArrayList,Vector)、Set等。</p>\n<ul>\n<li><p>List接口是有序的Collection，每一个元素都能够被用户使用索引来访问，类似Java中的数组。与Set不同，List允许存在相同的元素。</p>\n<p>LinkedList:它是有序的允许元素为null，并且提供额外的get，remove，insert方法来操作LinkedList的首或尾部，类似链表的结构，可以用来实现堆栈（Stack）、队列（Queue）或者双向队列（Deque），它是不同步的。</p>\n<p>ArrayList:它的内部实现机制实际上使用的是Object数组，且一个大小可变，但是每一个ArrayList在初始化时都有一个容量，外部看这个容量是可以根据元素的添加自动增加。当容量不够时，系统就会创建一个更大的数组（1.5倍左右）并且把老的数组完全拷贝到新的数组中，同时老数组就自动进入GC待处理状态，等待垃圾回收。</p>\n<p>相比LinkedList，ArrayList中的get(index)的方法速度较快，效率高。</p>\n<p>Vector:线程同步的ArrayList，当一个线程开始迭代Vector时，另一个线程来添加、删除等改变Vector时，就会抛出ConcurrentModificationException。</p>\n<p>Stack:继承自Vector，从名字可以看出堆栈，它实现了一个后进先出的堆栈。</p>\n</li>\n</ul>\n<ul>\n<li>Set接口是一种不允许重复的Collection，即任意的两个元素e1和e2都有e1.equals(e2)=false，Set最多有一个null元素。这其中equals方法就是依靠元素的hashCode来判断是否相等，有时可以通过重写一些对象的HashCode方法来改变判断相等的判断逻辑。</li>\n</ul>\n<h3 id=\"Map-Interface\"><a href=\"#Map-Interface\" class=\"headerlink\" title=\"Map Interface\"></a>Map Interface</h3><ul>\n<li><p>HashTable</p>\n<p>HashTable集成Map接口，实现了一个key-value映射的哈希表。任何非空（non-null）的对象都可以作为key或value。HashTable是线程同步的。</p>\n<p>不了解的知识点：Hashtable通过initial capacity和load factor两个参数调整性能。通常缺省的load factor 0.75较好地实现了时间和空间的均衡。增大load factor可以节省空间但相应的查找时间将增大，这会影响像get和put这样的操作。</p>\n<p>hashCode和equals方法是否重写相关：</p>\n</li>\n<li><p>HashMap</p>\n<p>HashMap和Hashtable类似，不同之处在于HashMap是非同步的，并且允许null，即null value和null key。，但是将HashMap视为Collection时（values()方法可返回Collection），其迭代子操作时间开销和HashMap 的容量成比例。因此，如果迭代操作的性能相当重要的话，不要将HashMap的初始化容量设得过高，或者load factor过低。</p>\n</li>\n<li><p>WeakHashMap</p>\n<p>WeakHashMap是一种改进的HashMap，它对key实行“弱引用”，如果一个key不再被外部所引用，那么该key可以被GC回收。实际开发中还没有用过，可以尝试用一下。</p>\n</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>List集合是有序集合，集合中的元素可以重复，访问集合中的元素可以根据元素的索引来访问。</li>\n<li>Set集合是无序集合，集合中的元素不可以重复，访问集合中的元素只能根据元素本身来访问（也是不能集合里元素不允许重复的原因）。</li>\n<li>Map集合中保存Key-value对形式的元素，访问时只能根据每项元素的key来访问其value。</li>\n<li>如果涉及到堆栈，队列等操作，应该考虑用List，对于需要快速插入，删除元素，应该使用LinkedList，如果需要快速随机访问元素，应该使用ArrayList。</li>\n<li>如果程序在单线程环境中，或者访问仅仅在一个线程中进行，考虑非同步的类，其效率较高，如果多个线程可能同时操作一个类，应该使用同步的类。要特别注意对哈希表的操作，作为key的对象要正确复写equals和hashCode方法。</li>\n<li>尽量返回接口而非实际的类型，如返回List而非ArrayList，这样如果以后需要将ArrayList换成LinkedList时，客户端代码不用改变。这就是针对抽象编程。</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://liuzhichao.com/p/652.html\" target=\"_blank\" rel=\"noopener\">柳志超Blog中一篇文章《Java集合类》</a></p>\n","site":{"data":{}},"excerpt":"<p>Java基础集合类的问题简单整理</p>","more":"<h1 id=\"JAVA基础集合类Review\"><a href=\"#JAVA基础集合类Review\" class=\"headerlink\" title=\"JAVA基础集合类Review\"></a>JAVA基础集合类Review</h1><p>##JAVA集合类分类</p>\n<ul>\n<li>Collection：通常是一组有一定规律的独立元素。List必须按照特定的顺序持有这些元素，而Set则不能保存重复的元素。</li>\n<li>Map：一组以“键－－值”（key-value）形式出现的pairs。</li>\n</ul>\n<h3 id=\"Collection-Interface\"><a href=\"#Collection-Interface\" class=\"headerlink\" title=\"Collection Interface\"></a>Collection Interface</h3><p>Collection是最基本的集合接口，它下面的实现类包括List(LinkedList, ArrayList,Vector)、Set等。</p>\n<ul>\n<li><p>List接口是有序的Collection，每一个元素都能够被用户使用索引来访问，类似Java中的数组。与Set不同，List允许存在相同的元素。</p>\n<p>LinkedList:它是有序的允许元素为null，并且提供额外的get，remove，insert方法来操作LinkedList的首或尾部，类似链表的结构，可以用来实现堆栈（Stack）、队列（Queue）或者双向队列（Deque），它是不同步的。</p>\n<p>ArrayList:它的内部实现机制实际上使用的是Object数组，且一个大小可变，但是每一个ArrayList在初始化时都有一个容量，外部看这个容量是可以根据元素的添加自动增加。当容量不够时，系统就会创建一个更大的数组（1.5倍左右）并且把老的数组完全拷贝到新的数组中，同时老数组就自动进入GC待处理状态，等待垃圾回收。</p>\n<p>相比LinkedList，ArrayList中的get(index)的方法速度较快，效率高。</p>\n<p>Vector:线程同步的ArrayList，当一个线程开始迭代Vector时，另一个线程来添加、删除等改变Vector时，就会抛出ConcurrentModificationException。</p>\n<p>Stack:继承自Vector，从名字可以看出堆栈，它实现了一个后进先出的堆栈。</p>\n</li>\n</ul>\n<ul>\n<li>Set接口是一种不允许重复的Collection，即任意的两个元素e1和e2都有e1.equals(e2)=false，Set最多有一个null元素。这其中equals方法就是依靠元素的hashCode来判断是否相等，有时可以通过重写一些对象的HashCode方法来改变判断相等的判断逻辑。</li>\n</ul>\n<h3 id=\"Map-Interface\"><a href=\"#Map-Interface\" class=\"headerlink\" title=\"Map Interface\"></a>Map Interface</h3><ul>\n<li><p>HashTable</p>\n<p>HashTable集成Map接口，实现了一个key-value映射的哈希表。任何非空（non-null）的对象都可以作为key或value。HashTable是线程同步的。</p>\n<p>不了解的知识点：Hashtable通过initial capacity和load factor两个参数调整性能。通常缺省的load factor 0.75较好地实现了时间和空间的均衡。增大load factor可以节省空间但相应的查找时间将增大，这会影响像get和put这样的操作。</p>\n<p>hashCode和equals方法是否重写相关：</p>\n</li>\n<li><p>HashMap</p>\n<p>HashMap和Hashtable类似，不同之处在于HashMap是非同步的，并且允许null，即null value和null key。，但是将HashMap视为Collection时（values()方法可返回Collection），其迭代子操作时间开销和HashMap 的容量成比例。因此，如果迭代操作的性能相当重要的话，不要将HashMap的初始化容量设得过高，或者load factor过低。</p>\n</li>\n<li><p>WeakHashMap</p>\n<p>WeakHashMap是一种改进的HashMap，它对key实行“弱引用”，如果一个key不再被外部所引用，那么该key可以被GC回收。实际开发中还没有用过，可以尝试用一下。</p>\n</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>List集合是有序集合，集合中的元素可以重复，访问集合中的元素可以根据元素的索引来访问。</li>\n<li>Set集合是无序集合，集合中的元素不可以重复，访问集合中的元素只能根据元素本身来访问（也是不能集合里元素不允许重复的原因）。</li>\n<li>Map集合中保存Key-value对形式的元素，访问时只能根据每项元素的key来访问其value。</li>\n<li>如果涉及到堆栈，队列等操作，应该考虑用List，对于需要快速插入，删除元素，应该使用LinkedList，如果需要快速随机访问元素，应该使用ArrayList。</li>\n<li>如果程序在单线程环境中，或者访问仅仅在一个线程中进行，考虑非同步的类，其效率较高，如果多个线程可能同时操作一个类，应该使用同步的类。要特别注意对哈希表的操作，作为key的对象要正确复写equals和hashCode方法。</li>\n<li>尽量返回接口而非实际的类型，如返回List而非ArrayList，这样如果以后需要将ArrayList换成LinkedList时，客户端代码不用改变。这就是针对抽象编程。</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://liuzhichao.com/p/652.html\" target=\"_blank\" rel=\"noopener\">柳志超Blog中一篇文章《Java集合类》</a></p>"},{"layout":"post","title":"Swift Study 1","description":"Swift is an important chance to find coding passion back to me. So Do Not Lose It! Come on!","date":"2014-06-07T16:00:01.000Z","_content":"\nSwift is an important chance to find coding passion back to me. So Do Not Lose It! Come on!\n\n<!--more-->\n\n## Swift 学习笔记 一\n从2014-06-09开始每日更新，督促自己学习坚持，一周为一篇周期，加油！\n\n### 材料收集\n[官方iBook版](https://itunes.apple.com/us/book/the-swift-programming-language/id881256329?mt=11)\n\nIDE Xcode 6 Beta\n\n### Hello World\n```swift\n    println(\"Hello World!\")\n```\n### 2014-06-09记录\n学习常量(let)、变量(var)定义的方法，字符串参数传递\\()，Swift类型推导 var numValue = 123, strValue = \"abc\"，数组和字典定义方式等等。\n\n函数的定义func，如:\n```swift\n    func hello(name: String, day: String) -> String {\n         return \"Hello \\(name), Today is \\(day) !\"\n    }\n```\n可变参数的函数定义，如：\n```swift\n    func sumOf(numbers: Int...) -> Int {\n        var sum = 0\n        for number in numbers {\n            sum += number\n        }\n        return sum\n    }\n    sumOf()\n    sumOf(42, 597, 12)”\n```\n正在看极客学院的 Weather App 的教学视频，看来需要恶补的一些交互还有很多，加油！\n\n### 2014-06-10记录\n看完做Weather App的Demo视频，熟悉一个可以解析JSON的工具API\n\n    NSJSONSerialization\n\n重新回头继续看文档，最近加班和参加Interview，阅读的时间少了，要坚持看！\n\n[GitBook 中文版Swift文档](http://numbbbbb.github.io/the-swift-programming-language-in-chinese/)\n\n#### 控制流\n\n使用if和switch来进行条件操作，使用for-in、for、while和do-while来进行循环。包裹条件和循环变量括号可以省略，但是语句体的大括号是必须的。\n\n在类型后面加一个问号来标记这个变量的值是可选的。\n```swift\n    var optionalString: String? = \"Hello\"\n    optionalString == nil\n\n    var optionalName: String? = \"John Appleseed\"\n    var greeting = \"Hello!\"\n    if let name = optionalName {\n        greeting = \"Hello, \\(name)\"\n    }\n```\nif的条件如果是 nil 就是false。\n\nswitch case中一定要有default否则编译会报错，因为进入这个条件操作可能会没有出口。\n\n循环中使用 .. 创建的范围不包含上界，如果想包含的话需要使用 ... ，如（0...10 表达从0开始到10，且包括10；0..10 则表单从0开始到10但不包括10）\n\n#### 函数与闭包\n\n前面在视频里面看到了函数的定义方法，这里通过文档再整理一下。\n\n使用func来声明一个函数，使用名字和参数来调用函数。使用->来指定函数返回值。\n```swift\n    func greet(name: String, day: String) -> String {\n        return \"Hello \\(name), today is \\(day).\"\n    }\n    greet(\"Bob\", \"Tuesday\")\n```\n### 2014-06-11\n枚举、闭包实践。\n\n今天公司足球赛，太累就暂时依照视频教程做了个读取天气的demo，明天继续！\n\n### 2014-06-15\n遇上公司加班延误了三天，世界杯开幕熬夜看比赛又导致晚上需要稍微早一点睡，最近学习计划有些延后，今天反省一下！Swift学习今天暂缓停一下，整理了一下个人Resume，同时在这期间了解Mac一个很有用的软件[Dash](https://itunes.apple.com/us/app/dash-docs-snippets/id458034879?mt=12)（汇集SDK文档和Sheets快速查询查看工具），推荐给在Mac环境下做开发的各位朋友！\n\nto be continue...\n\n\n\n","source":"_posts/2014-06-08-Study-Swift-1.md","raw":"---\nlayout: post\ntitle : Swift Study 1\ncategory : blog\ntags : [Apple, Swift]\ndescription : Swift is an important chance to find coding passion back to me. So Do Not Lose It! Come on!\ndate: 2014-06-08 00:00:01\n---\n\nSwift is an important chance to find coding passion back to me. So Do Not Lose It! Come on!\n\n<!--more-->\n\n## Swift 学习笔记 一\n从2014-06-09开始每日更新，督促自己学习坚持，一周为一篇周期，加油！\n\n### 材料收集\n[官方iBook版](https://itunes.apple.com/us/book/the-swift-programming-language/id881256329?mt=11)\n\nIDE Xcode 6 Beta\n\n### Hello World\n```swift\n    println(\"Hello World!\")\n```\n### 2014-06-09记录\n学习常量(let)、变量(var)定义的方法，字符串参数传递\\()，Swift类型推导 var numValue = 123, strValue = \"abc\"，数组和字典定义方式等等。\n\n函数的定义func，如:\n```swift\n    func hello(name: String, day: String) -> String {\n         return \"Hello \\(name), Today is \\(day) !\"\n    }\n```\n可变参数的函数定义，如：\n```swift\n    func sumOf(numbers: Int...) -> Int {\n        var sum = 0\n        for number in numbers {\n            sum += number\n        }\n        return sum\n    }\n    sumOf()\n    sumOf(42, 597, 12)”\n```\n正在看极客学院的 Weather App 的教学视频，看来需要恶补的一些交互还有很多，加油！\n\n### 2014-06-10记录\n看完做Weather App的Demo视频，熟悉一个可以解析JSON的工具API\n\n    NSJSONSerialization\n\n重新回头继续看文档，最近加班和参加Interview，阅读的时间少了，要坚持看！\n\n[GitBook 中文版Swift文档](http://numbbbbb.github.io/the-swift-programming-language-in-chinese/)\n\n#### 控制流\n\n使用if和switch来进行条件操作，使用for-in、for、while和do-while来进行循环。包裹条件和循环变量括号可以省略，但是语句体的大括号是必须的。\n\n在类型后面加一个问号来标记这个变量的值是可选的。\n```swift\n    var optionalString: String? = \"Hello\"\n    optionalString == nil\n\n    var optionalName: String? = \"John Appleseed\"\n    var greeting = \"Hello!\"\n    if let name = optionalName {\n        greeting = \"Hello, \\(name)\"\n    }\n```\nif的条件如果是 nil 就是false。\n\nswitch case中一定要有default否则编译会报错，因为进入这个条件操作可能会没有出口。\n\n循环中使用 .. 创建的范围不包含上界，如果想包含的话需要使用 ... ，如（0...10 表达从0开始到10，且包括10；0..10 则表单从0开始到10但不包括10）\n\n#### 函数与闭包\n\n前面在视频里面看到了函数的定义方法，这里通过文档再整理一下。\n\n使用func来声明一个函数，使用名字和参数来调用函数。使用->来指定函数返回值。\n```swift\n    func greet(name: String, day: String) -> String {\n        return \"Hello \\(name), today is \\(day).\"\n    }\n    greet(\"Bob\", \"Tuesday\")\n```\n### 2014-06-11\n枚举、闭包实践。\n\n今天公司足球赛，太累就暂时依照视频教程做了个读取天气的demo，明天继续！\n\n### 2014-06-15\n遇上公司加班延误了三天，世界杯开幕熬夜看比赛又导致晚上需要稍微早一点睡，最近学习计划有些延后，今天反省一下！Swift学习今天暂缓停一下，整理了一下个人Resume，同时在这期间了解Mac一个很有用的软件[Dash](https://itunes.apple.com/us/app/dash-docs-snippets/id458034879?mt=12)（汇集SDK文档和Sheets快速查询查看工具），推荐给在Mac环境下做开发的各位朋友！\n\nto be continue...\n\n\n\n","slug":"Study-Swift-1","published":1,"updated":"2017-11-04T11:09:17.000Z","comments":1,"photos":[],"link":"","_id":"cjc31n1fl001fgey52kocxmz1","content":"<p>Swift is an important chance to find coding passion back to me. So Do Not Lose It! Come on!</p>\n<a id=\"more\"></a>\n<h2 id=\"Swift-学习笔记-一\"><a href=\"#Swift-学习笔记-一\" class=\"headerlink\" title=\"Swift 学习笔记 一\"></a>Swift 学习笔记 一</h2><p>从2014-06-09开始每日更新，督促自己学习坚持，一周为一篇周期，加油！</p>\n<h3 id=\"材料收集\"><a href=\"#材料收集\" class=\"headerlink\" title=\"材料收集\"></a>材料收集</h3><p><a href=\"https://itunes.apple.com/us/book/the-swift-programming-language/id881256329?mt=11\" target=\"_blank\" rel=\"noopener\">官方iBook版</a></p>\n<p>IDE Xcode 6 Beta</p>\n<h3 id=\"Hello-World\"><a href=\"#Hello-World\" class=\"headerlink\" title=\"Hello World\"></a>Hello World</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">println</span>(<span class=\"string\">\"Hello World!\"</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"2014-06-09记录\"><a href=\"#2014-06-09记录\" class=\"headerlink\" title=\"2014-06-09记录\"></a>2014-06-09记录</h3><p>学习常量(let)、变量(var)定义的方法，字符串参数传递()，Swift类型推导 var numValue = 123, strValue = “abc”，数组和字典定义方式等等。</p>\n<p>函数的定义func，如:<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">hello</span><span class=\"params\">(name: String, day: String)</span></span> -&gt; <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"string\">\"Hello <span class=\"subst\">\\(name)</span>, Today is <span class=\"subst\">\\(day)</span> !\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可变参数的函数定义，如：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sumOf</span><span class=\"params\">(numbers: Int...)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> sum = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> number <span class=\"keyword\">in</span> numbers &#123;</span><br><span class=\"line\">        sum += number</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sumOf()</span><br><span class=\"line\">sumOf(<span class=\"number\">42</span>, <span class=\"number\">597</span>, <span class=\"number\">12</span>)”</span><br></pre></td></tr></table></figure></p>\n<p>正在看极客学院的 Weather App 的教学视频，看来需要恶补的一些交互还有很多，加油！</p>\n<h3 id=\"2014-06-10记录\"><a href=\"#2014-06-10记录\" class=\"headerlink\" title=\"2014-06-10记录\"></a>2014-06-10记录</h3><p>看完做Weather App的Demo视频，熟悉一个可以解析JSON的工具API</p>\n<pre><code>NSJSONSerialization\n</code></pre><p>重新回头继续看文档，最近加班和参加Interview，阅读的时间少了，要坚持看！</p>\n<p><a href=\"http://numbbbbb.github.io/the-swift-programming-language-in-chinese/\" target=\"_blank\" rel=\"noopener\">GitBook 中文版Swift文档</a></p>\n<h4 id=\"控制流\"><a href=\"#控制流\" class=\"headerlink\" title=\"控制流\"></a>控制流</h4><p>使用if和switch来进行条件操作，使用for-in、for、while和do-while来进行循环。包裹条件和循环变量括号可以省略，但是语句体的大括号是必须的。</p>\n<p>在类型后面加一个问号来标记这个变量的值是可选的。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> optionalString: <span class=\"type\">String</span>? = <span class=\"string\">\"Hello\"</span></span><br><span class=\"line\">optionalString == <span class=\"literal\">nil</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> optionalName: <span class=\"type\">String</span>? = <span class=\"string\">\"John Appleseed\"</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> greeting = <span class=\"string\">\"Hello!\"</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> name = optionalName &#123;</span><br><span class=\"line\">    greeting = <span class=\"string\">\"Hello, <span class=\"subst\">\\(name)</span>\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>if的条件如果是 nil 就是false。</p>\n<p>switch case中一定要有default否则编译会报错，因为进入这个条件操作可能会没有出口。</p>\n<p>循环中使用 .. 创建的范围不包含上界，如果想包含的话需要使用 … ，如（0…10 表达从0开始到10，且包括10；0..10 则表单从0开始到10但不包括10）</p>\n<h4 id=\"函数与闭包\"><a href=\"#函数与闭包\" class=\"headerlink\" title=\"函数与闭包\"></a>函数与闭包</h4><p>前面在视频里面看到了函数的定义方法，这里通过文档再整理一下。</p>\n<p>使用func来声明一个函数，使用名字和参数来调用函数。使用-&gt;来指定函数返回值。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">greet</span><span class=\"params\">(name: String, day: String)</span></span> -&gt; <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"Hello <span class=\"subst\">\\(name)</span>, today is <span class=\"subst\">\\(day)</span>.\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">greet(<span class=\"string\">\"Bob\"</span>, <span class=\"string\">\"Tuesday\"</span>)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2014-06-11\"><a href=\"#2014-06-11\" class=\"headerlink\" title=\"2014-06-11\"></a>2014-06-11</h3><p>枚举、闭包实践。</p>\n<p>今天公司足球赛，太累就暂时依照视频教程做了个读取天气的demo，明天继续！</p>\n<h3 id=\"2014-06-15\"><a href=\"#2014-06-15\" class=\"headerlink\" title=\"2014-06-15\"></a>2014-06-15</h3><p>遇上公司加班延误了三天，世界杯开幕熬夜看比赛又导致晚上需要稍微早一点睡，最近学习计划有些延后，今天反省一下！Swift学习今天暂缓停一下，整理了一下个人Resume，同时在这期间了解Mac一个很有用的软件<a href=\"https://itunes.apple.com/us/app/dash-docs-snippets/id458034879?mt=12\" target=\"_blank\" rel=\"noopener\">Dash</a>（汇集SDK文档和Sheets快速查询查看工具），推荐给在Mac环境下做开发的各位朋友！</p>\n<p>to be continue…</p>\n","site":{"data":{}},"excerpt":"<p>Swift is an important chance to find coding passion back to me. So Do Not Lose It! Come on!</p>","more":"<h2 id=\"Swift-学习笔记-一\"><a href=\"#Swift-学习笔记-一\" class=\"headerlink\" title=\"Swift 学习笔记 一\"></a>Swift 学习笔记 一</h2><p>从2014-06-09开始每日更新，督促自己学习坚持，一周为一篇周期，加油！</p>\n<h3 id=\"材料收集\"><a href=\"#材料收集\" class=\"headerlink\" title=\"材料收集\"></a>材料收集</h3><p><a href=\"https://itunes.apple.com/us/book/the-swift-programming-language/id881256329?mt=11\" target=\"_blank\" rel=\"noopener\">官方iBook版</a></p>\n<p>IDE Xcode 6 Beta</p>\n<h3 id=\"Hello-World\"><a href=\"#Hello-World\" class=\"headerlink\" title=\"Hello World\"></a>Hello World</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">println</span>(<span class=\"string\">\"Hello World!\"</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"2014-06-09记录\"><a href=\"#2014-06-09记录\" class=\"headerlink\" title=\"2014-06-09记录\"></a>2014-06-09记录</h3><p>学习常量(let)、变量(var)定义的方法，字符串参数传递()，Swift类型推导 var numValue = 123, strValue = “abc”，数组和字典定义方式等等。</p>\n<p>函数的定义func，如:<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">hello</span><span class=\"params\">(name: String, day: String)</span></span> -&gt; <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"string\">\"Hello <span class=\"subst\">\\(name)</span>, Today is <span class=\"subst\">\\(day)</span> !\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可变参数的函数定义，如：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sumOf</span><span class=\"params\">(numbers: Int...)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> sum = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> number <span class=\"keyword\">in</span> numbers &#123;</span><br><span class=\"line\">        sum += number</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sumOf()</span><br><span class=\"line\">sumOf(<span class=\"number\">42</span>, <span class=\"number\">597</span>, <span class=\"number\">12</span>)”</span><br></pre></td></tr></table></figure></p>\n<p>正在看极客学院的 Weather App 的教学视频，看来需要恶补的一些交互还有很多，加油！</p>\n<h3 id=\"2014-06-10记录\"><a href=\"#2014-06-10记录\" class=\"headerlink\" title=\"2014-06-10记录\"></a>2014-06-10记录</h3><p>看完做Weather App的Demo视频，熟悉一个可以解析JSON的工具API</p>\n<pre><code>NSJSONSerialization\n</code></pre><p>重新回头继续看文档，最近加班和参加Interview，阅读的时间少了，要坚持看！</p>\n<p><a href=\"http://numbbbbb.github.io/the-swift-programming-language-in-chinese/\" target=\"_blank\" rel=\"noopener\">GitBook 中文版Swift文档</a></p>\n<h4 id=\"控制流\"><a href=\"#控制流\" class=\"headerlink\" title=\"控制流\"></a>控制流</h4><p>使用if和switch来进行条件操作，使用for-in、for、while和do-while来进行循环。包裹条件和循环变量括号可以省略，但是语句体的大括号是必须的。</p>\n<p>在类型后面加一个问号来标记这个变量的值是可选的。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> optionalString: <span class=\"type\">String</span>? = <span class=\"string\">\"Hello\"</span></span><br><span class=\"line\">optionalString == <span class=\"literal\">nil</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> optionalName: <span class=\"type\">String</span>? = <span class=\"string\">\"John Appleseed\"</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> greeting = <span class=\"string\">\"Hello!\"</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> name = optionalName &#123;</span><br><span class=\"line\">    greeting = <span class=\"string\">\"Hello, <span class=\"subst\">\\(name)</span>\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>if的条件如果是 nil 就是false。</p>\n<p>switch case中一定要有default否则编译会报错，因为进入这个条件操作可能会没有出口。</p>\n<p>循环中使用 .. 创建的范围不包含上界，如果想包含的话需要使用 … ，如（0…10 表达从0开始到10，且包括10；0..10 则表单从0开始到10但不包括10）</p>\n<h4 id=\"函数与闭包\"><a href=\"#函数与闭包\" class=\"headerlink\" title=\"函数与闭包\"></a>函数与闭包</h4><p>前面在视频里面看到了函数的定义方法，这里通过文档再整理一下。</p>\n<p>使用func来声明一个函数，使用名字和参数来调用函数。使用-&gt;来指定函数返回值。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">greet</span><span class=\"params\">(name: String, day: String)</span></span> -&gt; <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"Hello <span class=\"subst\">\\(name)</span>, today is <span class=\"subst\">\\(day)</span>.\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">greet(<span class=\"string\">\"Bob\"</span>, <span class=\"string\">\"Tuesday\"</span>)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2014-06-11\"><a href=\"#2014-06-11\" class=\"headerlink\" title=\"2014-06-11\"></a>2014-06-11</h3><p>枚举、闭包实践。</p>\n<p>今天公司足球赛，太累就暂时依照视频教程做了个读取天气的demo，明天继续！</p>\n<h3 id=\"2014-06-15\"><a href=\"#2014-06-15\" class=\"headerlink\" title=\"2014-06-15\"></a>2014-06-15</h3><p>遇上公司加班延误了三天，世界杯开幕熬夜看比赛又导致晚上需要稍微早一点睡，最近学习计划有些延后，今天反省一下！Swift学习今天暂缓停一下，整理了一下个人Resume，同时在这期间了解Mac一个很有用的软件<a href=\"https://itunes.apple.com/us/app/dash-docs-snippets/id458034879?mt=12\" target=\"_blank\" rel=\"noopener\">Dash</a>（汇集SDK文档和Sheets快速查询查看工具），推荐给在Mac环境下做开发的各位朋友！</p>\n<p>to be continue…</p>"},{"layout":"post","title":"Mac Tool","description":"Mac OSX 下佳软推荐 Dash 和 CheatSheet","date":"2014-06-18T16:00:01.000Z","_content":"\n推荐的两款软件，它们有助于我提高效率，因此来完成这篇推介文。\nDash 一款用来集成快速查阅文档；CheatSheet 一款用来提示快捷键。\n\n<!--more-->\n\n!['tools_1'](http://ww3.sinaimg.cn/mw690/454c4867jw9ehyt3n7t8tj20g407lq42.jpg)\n\n# Dash\n\n相信日常工作或者做个人开发的朋友，浏览器的收藏夹中一定有一个文件夹，里面收藏了n个技术类的在线文档以及各种代码片段，Dash就是这样一款专注于提供各类API文档和收藏代码片段的工具。\n\n### 值得推荐\n\n* 推荐点1-内容丰富\n具备丰富的Docsets，并且都是提供官方原版材料。\n\n!['tools_dash_1'](http://ww2.sinaimg.cn/mw690/454c4867jw1emgqaa8qw6j21ki0zw489.jpg)\n\n* 推荐点2-快速查询\nDash提供快速的查询，这其中包括多文档的联合查询，以及在某一个Docset中查询，查询流畅度很好。\n\n图片TODO\n\n* 缺点\n售价昂贵，目前Dash Full Version要RMB128，在淘宝上购买是个不错的选择；如果可以忍受偶尔查询等待8s时间出结果，可以使用免费版；一些SDK和API受限于系统，只提供链接，如Objective-C等，值得高兴的是Swift可以直接查询很下载查阅。\n\n# CheatSheet\n\n这是一款可以显示当前应用所有快捷键列表的软件，使用者只需要按住Command就能见识到他的强大之处。在笔者还没有Mac的时候，关注[小众软件](http://www.appinn.com)的时候看到他的推荐，于是就在[CheatSheet官网](http://www.cheatsheetapp.com/CheatSheet/)下载收藏了这款可以提高效率的软件。\nPS.顾名思义快捷键是可以帮助使用者提高效率，善用、习惯快捷键，以及调整自己数字的快捷键可以更有效的提高自己的效率，这无疑也是帮助我们自己提高的方式之一。","source":"_posts/2014-06-19-Mac-Tool-Series-1.md","raw":"---\nlayout: post\ntitle : Mac Tool \ncategory : blog\ntags : [Tool, Mac]\ndescription : Mac OSX 下佳软推荐 Dash 和 CheatSheet\ndate: 2014-06-19 00:00:01\n---\n\n推荐的两款软件，它们有助于我提高效率，因此来完成这篇推介文。\nDash 一款用来集成快速查阅文档；CheatSheet 一款用来提示快捷键。\n\n<!--more-->\n\n!['tools_1'](http://ww3.sinaimg.cn/mw690/454c4867jw9ehyt3n7t8tj20g407lq42.jpg)\n\n# Dash\n\n相信日常工作或者做个人开发的朋友，浏览器的收藏夹中一定有一个文件夹，里面收藏了n个技术类的在线文档以及各种代码片段，Dash就是这样一款专注于提供各类API文档和收藏代码片段的工具。\n\n### 值得推荐\n\n* 推荐点1-内容丰富\n具备丰富的Docsets，并且都是提供官方原版材料。\n\n!['tools_dash_1'](http://ww2.sinaimg.cn/mw690/454c4867jw1emgqaa8qw6j21ki0zw489.jpg)\n\n* 推荐点2-快速查询\nDash提供快速的查询，这其中包括多文档的联合查询，以及在某一个Docset中查询，查询流畅度很好。\n\n图片TODO\n\n* 缺点\n售价昂贵，目前Dash Full Version要RMB128，在淘宝上购买是个不错的选择；如果可以忍受偶尔查询等待8s时间出结果，可以使用免费版；一些SDK和API受限于系统，只提供链接，如Objective-C等，值得高兴的是Swift可以直接查询很下载查阅。\n\n# CheatSheet\n\n这是一款可以显示当前应用所有快捷键列表的软件，使用者只需要按住Command就能见识到他的强大之处。在笔者还没有Mac的时候，关注[小众软件](http://www.appinn.com)的时候看到他的推荐，于是就在[CheatSheet官网](http://www.cheatsheetapp.com/CheatSheet/)下载收藏了这款可以提高效率的软件。\nPS.顾名思义快捷键是可以帮助使用者提高效率，善用、习惯快捷键，以及调整自己数字的快捷键可以更有效的提高自己的效率，这无疑也是帮助我们自己提高的方式之一。","slug":"Mac-Tool-Series-1","published":1,"updated":"2017-11-04T11:09:17.000Z","comments":1,"photos":[],"link":"","_id":"cjc31n1fo001igey5skgjsen2","content":"<p>推荐的两款软件，它们有助于我提高效率，因此来完成这篇推介文。<br>Dash 一款用来集成快速查阅文档；CheatSheet 一款用来提示快捷键。</p>\n<a id=\"more\"></a>\n<p><img src=\"http://ww3.sinaimg.cn/mw690/454c4867jw9ehyt3n7t8tj20g407lq42.jpg\" alt=\"&#39;tools_1&#39;\"></p>\n<h1 id=\"Dash\"><a href=\"#Dash\" class=\"headerlink\" title=\"Dash\"></a>Dash</h1><p>相信日常工作或者做个人开发的朋友，浏览器的收藏夹中一定有一个文件夹，里面收藏了n个技术类的在线文档以及各种代码片段，Dash就是这样一款专注于提供各类API文档和收藏代码片段的工具。</p>\n<h3 id=\"值得推荐\"><a href=\"#值得推荐\" class=\"headerlink\" title=\"值得推荐\"></a>值得推荐</h3><ul>\n<li>推荐点1-内容丰富<br>具备丰富的Docsets，并且都是提供官方原版材料。</li>\n</ul>\n<p><img src=\"http://ww2.sinaimg.cn/mw690/454c4867jw1emgqaa8qw6j21ki0zw489.jpg\" alt=\"&#39;tools_dash_1&#39;\"></p>\n<ul>\n<li>推荐点2-快速查询<br>Dash提供快速的查询，这其中包括多文档的联合查询，以及在某一个Docset中查询，查询流畅度很好。</li>\n</ul>\n<p>图片TODO</p>\n<ul>\n<li>缺点<br>售价昂贵，目前Dash Full Version要RMB128，在淘宝上购买是个不错的选择；如果可以忍受偶尔查询等待8s时间出结果，可以使用免费版；一些SDK和API受限于系统，只提供链接，如Objective-C等，值得高兴的是Swift可以直接查询很下载查阅。</li>\n</ul>\n<h1 id=\"CheatSheet\"><a href=\"#CheatSheet\" class=\"headerlink\" title=\"CheatSheet\"></a>CheatSheet</h1><p>这是一款可以显示当前应用所有快捷键列表的软件，使用者只需要按住Command就能见识到他的强大之处。在笔者还没有Mac的时候，关注<a href=\"http://www.appinn.com\" target=\"_blank\" rel=\"noopener\">小众软件</a>的时候看到他的推荐，于是就在<a href=\"http://www.cheatsheetapp.com/CheatSheet/\" target=\"_blank\" rel=\"noopener\">CheatSheet官网</a>下载收藏了这款可以提高效率的软件。<br>PS.顾名思义快捷键是可以帮助使用者提高效率，善用、习惯快捷键，以及调整自己数字的快捷键可以更有效的提高自己的效率，这无疑也是帮助我们自己提高的方式之一。</p>\n","site":{"data":{}},"excerpt":"<p>推荐的两款软件，它们有助于我提高效率，因此来完成这篇推介文。<br>Dash 一款用来集成快速查阅文档；CheatSheet 一款用来提示快捷键。</p>","more":"<p><img src=\"http://ww3.sinaimg.cn/mw690/454c4867jw9ehyt3n7t8tj20g407lq42.jpg\" alt=\"&#39;tools_1&#39;\"></p>\n<h1 id=\"Dash\"><a href=\"#Dash\" class=\"headerlink\" title=\"Dash\"></a>Dash</h1><p>相信日常工作或者做个人开发的朋友，浏览器的收藏夹中一定有一个文件夹，里面收藏了n个技术类的在线文档以及各种代码片段，Dash就是这样一款专注于提供各类API文档和收藏代码片段的工具。</p>\n<h3 id=\"值得推荐\"><a href=\"#值得推荐\" class=\"headerlink\" title=\"值得推荐\"></a>值得推荐</h3><ul>\n<li>推荐点1-内容丰富<br>具备丰富的Docsets，并且都是提供官方原版材料。</li>\n</ul>\n<p><img src=\"http://ww2.sinaimg.cn/mw690/454c4867jw1emgqaa8qw6j21ki0zw489.jpg\" alt=\"&#39;tools_dash_1&#39;\"></p>\n<ul>\n<li>推荐点2-快速查询<br>Dash提供快速的查询，这其中包括多文档的联合查询，以及在某一个Docset中查询，查询流畅度很好。</li>\n</ul>\n<p>图片TODO</p>\n<ul>\n<li>缺点<br>售价昂贵，目前Dash Full Version要RMB128，在淘宝上购买是个不错的选择；如果可以忍受偶尔查询等待8s时间出结果，可以使用免费版；一些SDK和API受限于系统，只提供链接，如Objective-C等，值得高兴的是Swift可以直接查询很下载查阅。</li>\n</ul>\n<h1 id=\"CheatSheet\"><a href=\"#CheatSheet\" class=\"headerlink\" title=\"CheatSheet\"></a>CheatSheet</h1><p>这是一款可以显示当前应用所有快捷键列表的软件，使用者只需要按住Command就能见识到他的强大之处。在笔者还没有Mac的时候，关注<a href=\"http://www.appinn.com\" target=\"_blank\" rel=\"noopener\">小众软件</a>的时候看到他的推荐，于是就在<a href=\"http://www.cheatsheetapp.com/CheatSheet/\" target=\"_blank\" rel=\"noopener\">CheatSheet官网</a>下载收藏了这款可以提高效率的软件。<br>PS.顾名思义快捷键是可以帮助使用者提高效率，善用、习惯快捷键，以及调整自己数字的快捷键可以更有效的提高自己的效率，这无疑也是帮助我们自己提高的方式之一。</p>"},{"layout":"post","title":"科学上网之VPN推荐系列","tagline":"","description":"“工欲善其事，必先利其器” 今天笔者来和大家一起分享，最近查阅资料整理后的一些关于VPN的那点事儿。","date":"2014-06-27T16:00:01.000Z","_content":"\n“工欲善其事，必先利其器” 今天笔者来和大家一起分享，最近查阅资料整理后的一些关于VPN的那点事儿。\n\n<!--more-->\n\n刚刚加班到家，整理一下这篇最近在查阅资料关于VPN的一些内容，以及一些付费VPN的简单介绍。\n\n### 什么是VPN\n\nVPN 可以通过特殊的加密通讯协议，在连接 Internet 上位于不同地方的两个或多个企业内部网之间建立一条专有的通讯线路；就好比是架设了一条专线，但它并不需要真正的去铺设光缆之类的物理线路；就像去电信局申请专线，但是不用给铺设线路的费用，也不用购买路由器等硬件设备。\n\nVPN 技术原是路由器的重要技术之一，在交换机、防火墙设备或各大操作系统里也都支持 VPN 功能，VPN 的核心就是利用公共网络建立虚拟私有网。\n\n通俗的说，如果你想不被别人探查到你的 IP 地址，如果你想访问大量原本无法登录的国外网站，如果你想更安全进行数据传输，请使用 VPN。\n\n### PPTP和L2TP区别\n\n最常见最流行的 VPN 协议包含 PPTP 协议和 L2TP/IPSec 协议。如果你希望设置简单，对通信安全没有太大的要求，那么你配置 PPTP 连接即可；如果你的网络里 PPTP 协议未被允许，或者希望数据通信更安全的话，就推荐设置 L2TP/IPSec 连接。在设置上，步骤基本一致，只是 L2TP/IPSec 协议需要输入共享密钥。\n\n* PPTP（Point to Point Tunneling Protocol）点对点隧道协议：是一种主要用于 VPN 的数据链路层网络协议，PPTP 的协议规范本身并未描述加密或身份验证的特性。\n* L2TP（Layer Two Tunneling Protocol) 第二层隧道协议：是一种数据链路层隧道协议，通常用于虚拟专用网。L2TP 协议自身不对传输的数据进行加密，但是可以和加密协议搭配使用，从而实现数据的加密传输。经常与 L2TP 协议搭配的加密协议是 IPsec，当这两个协议搭配使用时，通常合称 L2TP/IPsec。\n\n### 优点\n\n* 科学上网\n* 配置方便，配置好以后，直接连接，就可以使用\n* 安全，一把双刃剑，因为VPN连接，我们的数据包都是通过中间服务器转发，VPN提供了很多种加密的方式，这样就可以很好地保护我们的隐私，隐藏IP等。\n\n### 缺点\n\n* 受GFW干扰较大，由于使用UDP技术，连接可能受干扰\n* 比较依赖本地的网络环境\n* ISP网络的可能会阻止VPN的连接，导致连不上或者速度慢\n* VPN是保持连接，不是特别灵活，要断要连在使用过程中难免有麻烦\n* 安全，不能排除我们的数据包被中间服务器抓包或者截取的可能。\n\n## 选择VPN\n\n\n前面一些“科普”的文字给大家码好字之后，下面笔者在选购VPN的时候主要关注一下几点，在这里和各位分享一下，可能与各位不同，欢迎读者朋友讨论吐槽！\n\n* **稳定性**：这是我比较重视一点，所以放在第一个，VPN的连接速度以及连接的稳定性，直接影响到使用者的感受，之所以找付费版VPN，最重要的就是想享受稳定的连接，不希望遇到经常掉线重连，或者经常不得不被动地切换多个连接。\n* **终端支持**：我的需求是希望支持Mac、iPhone、iPad至少三台终端同时连接，这样在多端就可以无缝享受网络。\n* **连接速度**（上行/下行）：不知道读者朋友有没有跟笔者一样的感受，网络慢得时候电脑也会有慢得错觉。当然了，“慢”一定有很多原因，也可能是错觉，但是连接VPN后同样拥有普通连接相同或者不会降低很多的网络速度，是非常重要的一点，也同样是申请VPN退款的原因之一。\n* **价格**（按量付费/按时付费）以及**支付方式**：按时 or 按量，这个取决于使用者的需求，如果像笔者一样是新手或者换种说法是首次希望通过付费VPN的方式“科学上网”，偶尔登录Google查阅资料，而且不用刷Twitter，暂时没有部署在国外服务器上的网站需要维护的话，可以选择价位不高且流量不大的服务；支付方式也被我放在这里，国内的很多朋友可能没有双币信用卡，Paypal付款难免有些麻烦，查了好几个VPN的服务商都已经支持支付宝付款了，还是很方便的。\n* **配置难易度、客服响应速度**：\n* **隐私安全**：毕竟我们在通过VPN连接时，本地的数据包是发送到远方服务器再跳转的，这期间是否会被抓包，窃取资料就是一个值得考虑的问题，笔者建议不用在VPN连接时使用网银等，即使VPN已经声明了数据信息已经加密，要保持警惕，保护隐私。\n* **服务器地点**：这点可能目前阶段不是笔者比较在意的一点，无论VPN服务商提供的是美国、日本、加拿大、台湾等何地的服务器，对于笔者来说不是特别重要，只要可以达到稳定的连接就可以。但是对于一些对服务地有强烈需求的朋友来说，比如一些游戏玩家，PS4和XBOX必须要连接当地的服务才能玩，这时服务器所在的地点就成了比较重要的考虑因素之一了。\n\n## 付费VPN收集\n\n\n很幸运在微博上认识一位朋友[聆听潇湘雨](http://weibo.com/liwei198870)，请教了一些知识，也很感谢他推荐了几个付费VPN给我，包括我自己查阅的资料在下面罗列一下，具体服务需要等各位用户先自己试用，稍后再提供我的使用报告：\n\n* [熊猫翻滚](https://www.pandafan.org/?r=2885) 顾名思义，熊猫天朝特产，朋友推荐说智能分流做的很好，就是国内和国外的网站可以自动区分，这样连接VPN的同时国内网站的访问速度影响有效降低。\n* [云梯](https://www.ytvpn.com/)  在V2EX社区看到有人推荐过，也注册了一下，同学有需求想下载Google Android文档和源码，于是就买了这家的服务，速度还是很快的，支持3天内退款。\n* [曲径](https://getqujing.com/zh-CN)  官网介绍是为了国外音乐类流量服务，有一些大V也在各自的推文中有介绍，想必也积累了一些人气，服务应该做的还是不错的，要不然也不会这么多人推荐。可月付或者季付、限流量，其【冬月】套餐比较适合多终端的用户。\n* [轻云](https://theqingyun.co/r/ncmbi3)  资费比较合理，支持的设备较多，同时允许7台设备在线。\n* [YesVPN](http://98.126.129.242/index.php)  包月10RMB，包年100RMB\n* [鲨鱼VPN](https://www.shayujsq.net/index.php) \n* Google搜索 付费VPN 关键字 : )\n\n## VPN FOR FREE\n\n* Chrome插件 - [红杏](http://honx.in/i/U7DdTYKo11MoCLEP) 浏览器上的插件，使用者仅仅通过安装Chrome浏览器插件，使用邮箱注册用户，就可以直接访问Google、Facebook和Twitter了。简单使用，缺点非VIP版服务器不是特别稳定，笔者在最近3天的使用过程中有一天下午基本无法使用，服务断断续续。当然也可以购买VIP版，笔者还没有购买体验就不便在这里细说，如果仅限浏览器翻墙，查看网页或者单线程下载一些小文件的话，这颗“红杏”是个不错的选择。\n\n文章还没写完，今天红杏免费版就挂了，但是红杏VIP版还是很受欢迎的。\n\n* Google搜索 免费VPN 关键字即可 : )\n\n## 补充\n\n在完成这篇Blog的过程中，查阅的信息逐渐像水滴波纹一样散开，信息量过大，越来越害怕，觉得这里需要做功课的东西还是太多，有些不敢写了，因此标题也是改了又改，缩小范围。后面补补课再给各位带来其他科学上网的方式。\n\n因为目前对科学上网需求不是那么强烈，因此在写完这篇Blog后，我觉得先买一个熊猫翻滚之学术熊猫试用一个月（这其中也有微博朋友极力推荐的因素）。\n\n其他科学上网收集如下，以后有机会在研究跟大家分享：\n\n* [eurekavpt](https://eurekavpt.com)\n* [ShadowSocks](http://ippotsuko.com/blog/shadowsocks/)\n* [PowerConnect](https://pcnt.in/) && [官方 Twitter](https://twitter.com/PowerPACNetwork) 会不定时放出邀请码\n* ....","source":"_posts/2014-06-28-How-To-Connect-Internet-With-VPN.md","raw":"---\nlayout: post\ntitle : 科学上网之VPN推荐系列\ncategory : blog\ntagline: \"\"\ntags : [VPN, Share]\ndescription : “工欲善其事，必先利其器” 今天笔者来和大家一起分享，最近查阅资料整理后的一些关于VPN的那点事儿。\ndate: 2014-06-28 00:00:01\n---\n\n“工欲善其事，必先利其器” 今天笔者来和大家一起分享，最近查阅资料整理后的一些关于VPN的那点事儿。\n\n<!--more-->\n\n刚刚加班到家，整理一下这篇最近在查阅资料关于VPN的一些内容，以及一些付费VPN的简单介绍。\n\n### 什么是VPN\n\nVPN 可以通过特殊的加密通讯协议，在连接 Internet 上位于不同地方的两个或多个企业内部网之间建立一条专有的通讯线路；就好比是架设了一条专线，但它并不需要真正的去铺设光缆之类的物理线路；就像去电信局申请专线，但是不用给铺设线路的费用，也不用购买路由器等硬件设备。\n\nVPN 技术原是路由器的重要技术之一，在交换机、防火墙设备或各大操作系统里也都支持 VPN 功能，VPN 的核心就是利用公共网络建立虚拟私有网。\n\n通俗的说，如果你想不被别人探查到你的 IP 地址，如果你想访问大量原本无法登录的国外网站，如果你想更安全进行数据传输，请使用 VPN。\n\n### PPTP和L2TP区别\n\n最常见最流行的 VPN 协议包含 PPTP 协议和 L2TP/IPSec 协议。如果你希望设置简单，对通信安全没有太大的要求，那么你配置 PPTP 连接即可；如果你的网络里 PPTP 协议未被允许，或者希望数据通信更安全的话，就推荐设置 L2TP/IPSec 连接。在设置上，步骤基本一致，只是 L2TP/IPSec 协议需要输入共享密钥。\n\n* PPTP（Point to Point Tunneling Protocol）点对点隧道协议：是一种主要用于 VPN 的数据链路层网络协议，PPTP 的协议规范本身并未描述加密或身份验证的特性。\n* L2TP（Layer Two Tunneling Protocol) 第二层隧道协议：是一种数据链路层隧道协议，通常用于虚拟专用网。L2TP 协议自身不对传输的数据进行加密，但是可以和加密协议搭配使用，从而实现数据的加密传输。经常与 L2TP 协议搭配的加密协议是 IPsec，当这两个协议搭配使用时，通常合称 L2TP/IPsec。\n\n### 优点\n\n* 科学上网\n* 配置方便，配置好以后，直接连接，就可以使用\n* 安全，一把双刃剑，因为VPN连接，我们的数据包都是通过中间服务器转发，VPN提供了很多种加密的方式，这样就可以很好地保护我们的隐私，隐藏IP等。\n\n### 缺点\n\n* 受GFW干扰较大，由于使用UDP技术，连接可能受干扰\n* 比较依赖本地的网络环境\n* ISP网络的可能会阻止VPN的连接，导致连不上或者速度慢\n* VPN是保持连接，不是特别灵活，要断要连在使用过程中难免有麻烦\n* 安全，不能排除我们的数据包被中间服务器抓包或者截取的可能。\n\n## 选择VPN\n\n\n前面一些“科普”的文字给大家码好字之后，下面笔者在选购VPN的时候主要关注一下几点，在这里和各位分享一下，可能与各位不同，欢迎读者朋友讨论吐槽！\n\n* **稳定性**：这是我比较重视一点，所以放在第一个，VPN的连接速度以及连接的稳定性，直接影响到使用者的感受，之所以找付费版VPN，最重要的就是想享受稳定的连接，不希望遇到经常掉线重连，或者经常不得不被动地切换多个连接。\n* **终端支持**：我的需求是希望支持Mac、iPhone、iPad至少三台终端同时连接，这样在多端就可以无缝享受网络。\n* **连接速度**（上行/下行）：不知道读者朋友有没有跟笔者一样的感受，网络慢得时候电脑也会有慢得错觉。当然了，“慢”一定有很多原因，也可能是错觉，但是连接VPN后同样拥有普通连接相同或者不会降低很多的网络速度，是非常重要的一点，也同样是申请VPN退款的原因之一。\n* **价格**（按量付费/按时付费）以及**支付方式**：按时 or 按量，这个取决于使用者的需求，如果像笔者一样是新手或者换种说法是首次希望通过付费VPN的方式“科学上网”，偶尔登录Google查阅资料，而且不用刷Twitter，暂时没有部署在国外服务器上的网站需要维护的话，可以选择价位不高且流量不大的服务；支付方式也被我放在这里，国内的很多朋友可能没有双币信用卡，Paypal付款难免有些麻烦，查了好几个VPN的服务商都已经支持支付宝付款了，还是很方便的。\n* **配置难易度、客服响应速度**：\n* **隐私安全**：毕竟我们在通过VPN连接时，本地的数据包是发送到远方服务器再跳转的，这期间是否会被抓包，窃取资料就是一个值得考虑的问题，笔者建议不用在VPN连接时使用网银等，即使VPN已经声明了数据信息已经加密，要保持警惕，保护隐私。\n* **服务器地点**：这点可能目前阶段不是笔者比较在意的一点，无论VPN服务商提供的是美国、日本、加拿大、台湾等何地的服务器，对于笔者来说不是特别重要，只要可以达到稳定的连接就可以。但是对于一些对服务地有强烈需求的朋友来说，比如一些游戏玩家，PS4和XBOX必须要连接当地的服务才能玩，这时服务器所在的地点就成了比较重要的考虑因素之一了。\n\n## 付费VPN收集\n\n\n很幸运在微博上认识一位朋友[聆听潇湘雨](http://weibo.com/liwei198870)，请教了一些知识，也很感谢他推荐了几个付费VPN给我，包括我自己查阅的资料在下面罗列一下，具体服务需要等各位用户先自己试用，稍后再提供我的使用报告：\n\n* [熊猫翻滚](https://www.pandafan.org/?r=2885) 顾名思义，熊猫天朝特产，朋友推荐说智能分流做的很好，就是国内和国外的网站可以自动区分，这样连接VPN的同时国内网站的访问速度影响有效降低。\n* [云梯](https://www.ytvpn.com/)  在V2EX社区看到有人推荐过，也注册了一下，同学有需求想下载Google Android文档和源码，于是就买了这家的服务，速度还是很快的，支持3天内退款。\n* [曲径](https://getqujing.com/zh-CN)  官网介绍是为了国外音乐类流量服务，有一些大V也在各自的推文中有介绍，想必也积累了一些人气，服务应该做的还是不错的，要不然也不会这么多人推荐。可月付或者季付、限流量，其【冬月】套餐比较适合多终端的用户。\n* [轻云](https://theqingyun.co/r/ncmbi3)  资费比较合理，支持的设备较多，同时允许7台设备在线。\n* [YesVPN](http://98.126.129.242/index.php)  包月10RMB，包年100RMB\n* [鲨鱼VPN](https://www.shayujsq.net/index.php) \n* Google搜索 付费VPN 关键字 : )\n\n## VPN FOR FREE\n\n* Chrome插件 - [红杏](http://honx.in/i/U7DdTYKo11MoCLEP) 浏览器上的插件，使用者仅仅通过安装Chrome浏览器插件，使用邮箱注册用户，就可以直接访问Google、Facebook和Twitter了。简单使用，缺点非VIP版服务器不是特别稳定，笔者在最近3天的使用过程中有一天下午基本无法使用，服务断断续续。当然也可以购买VIP版，笔者还没有购买体验就不便在这里细说，如果仅限浏览器翻墙，查看网页或者单线程下载一些小文件的话，这颗“红杏”是个不错的选择。\n\n文章还没写完，今天红杏免费版就挂了，但是红杏VIP版还是很受欢迎的。\n\n* Google搜索 免费VPN 关键字即可 : )\n\n## 补充\n\n在完成这篇Blog的过程中，查阅的信息逐渐像水滴波纹一样散开，信息量过大，越来越害怕，觉得这里需要做功课的东西还是太多，有些不敢写了，因此标题也是改了又改，缩小范围。后面补补课再给各位带来其他科学上网的方式。\n\n因为目前对科学上网需求不是那么强烈，因此在写完这篇Blog后，我觉得先买一个熊猫翻滚之学术熊猫试用一个月（这其中也有微博朋友极力推荐的因素）。\n\n其他科学上网收集如下，以后有机会在研究跟大家分享：\n\n* [eurekavpt](https://eurekavpt.com)\n* [ShadowSocks](http://ippotsuko.com/blog/shadowsocks/)\n* [PowerConnect](https://pcnt.in/) && [官方 Twitter](https://twitter.com/PowerPACNetwork) 会不定时放出邀请码\n* ....","slug":"How-To-Connect-Internet-With-VPN","published":1,"updated":"2017-11-04T11:09:17.000Z","comments":1,"photos":[],"link":"","_id":"cjc31n1fq001lgey5eiyurgff","content":"<p>“工欲善其事，必先利其器” 今天笔者来和大家一起分享，最近查阅资料整理后的一些关于VPN的那点事儿。</p>\n<a id=\"more\"></a>\n<p>刚刚加班到家，整理一下这篇最近在查阅资料关于VPN的一些内容，以及一些付费VPN的简单介绍。</p>\n<h3 id=\"什么是VPN\"><a href=\"#什么是VPN\" class=\"headerlink\" title=\"什么是VPN\"></a>什么是VPN</h3><p>VPN 可以通过特殊的加密通讯协议，在连接 Internet 上位于不同地方的两个或多个企业内部网之间建立一条专有的通讯线路；就好比是架设了一条专线，但它并不需要真正的去铺设光缆之类的物理线路；就像去电信局申请专线，但是不用给铺设线路的费用，也不用购买路由器等硬件设备。</p>\n<p>VPN 技术原是路由器的重要技术之一，在交换机、防火墙设备或各大操作系统里也都支持 VPN 功能，VPN 的核心就是利用公共网络建立虚拟私有网。</p>\n<p>通俗的说，如果你想不被别人探查到你的 IP 地址，如果你想访问大量原本无法登录的国外网站，如果你想更安全进行数据传输，请使用 VPN。</p>\n<h3 id=\"PPTP和L2TP区别\"><a href=\"#PPTP和L2TP区别\" class=\"headerlink\" title=\"PPTP和L2TP区别\"></a>PPTP和L2TP区别</h3><p>最常见最流行的 VPN 协议包含 PPTP 协议和 L2TP/IPSec 协议。如果你希望设置简单，对通信安全没有太大的要求，那么你配置 PPTP 连接即可；如果你的网络里 PPTP 协议未被允许，或者希望数据通信更安全的话，就推荐设置 L2TP/IPSec 连接。在设置上，步骤基本一致，只是 L2TP/IPSec 协议需要输入共享密钥。</p>\n<ul>\n<li>PPTP（Point to Point Tunneling Protocol）点对点隧道协议：是一种主要用于 VPN 的数据链路层网络协议，PPTP 的协议规范本身并未描述加密或身份验证的特性。</li>\n<li>L2TP（Layer Two Tunneling Protocol) 第二层隧道协议：是一种数据链路层隧道协议，通常用于虚拟专用网。L2TP 协议自身不对传输的数据进行加密，但是可以和加密协议搭配使用，从而实现数据的加密传输。经常与 L2TP 协议搭配的加密协议是 IPsec，当这两个协议搭配使用时，通常合称 L2TP/IPsec。</li>\n</ul>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ul>\n<li>科学上网</li>\n<li>配置方便，配置好以后，直接连接，就可以使用</li>\n<li>安全，一把双刃剑，因为VPN连接，我们的数据包都是通过中间服务器转发，VPN提供了很多种加密的方式，这样就可以很好地保护我们的隐私，隐藏IP等。</li>\n</ul>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><ul>\n<li>受GFW干扰较大，由于使用UDP技术，连接可能受干扰</li>\n<li>比较依赖本地的网络环境</li>\n<li>ISP网络的可能会阻止VPN的连接，导致连不上或者速度慢</li>\n<li>VPN是保持连接，不是特别灵活，要断要连在使用过程中难免有麻烦</li>\n<li>安全，不能排除我们的数据包被中间服务器抓包或者截取的可能。</li>\n</ul>\n<h2 id=\"选择VPN\"><a href=\"#选择VPN\" class=\"headerlink\" title=\"选择VPN\"></a>选择VPN</h2><p>前面一些“科普”的文字给大家码好字之后，下面笔者在选购VPN的时候主要关注一下几点，在这里和各位分享一下，可能与各位不同，欢迎读者朋友讨论吐槽！</p>\n<ul>\n<li><strong>稳定性</strong>：这是我比较重视一点，所以放在第一个，VPN的连接速度以及连接的稳定性，直接影响到使用者的感受，之所以找付费版VPN，最重要的就是想享受稳定的连接，不希望遇到经常掉线重连，或者经常不得不被动地切换多个连接。</li>\n<li><strong>终端支持</strong>：我的需求是希望支持Mac、iPhone、iPad至少三台终端同时连接，这样在多端就可以无缝享受网络。</li>\n<li><strong>连接速度</strong>（上行/下行）：不知道读者朋友有没有跟笔者一样的感受，网络慢得时候电脑也会有慢得错觉。当然了，“慢”一定有很多原因，也可能是错觉，但是连接VPN后同样拥有普通连接相同或者不会降低很多的网络速度，是非常重要的一点，也同样是申请VPN退款的原因之一。</li>\n<li><strong>价格</strong>（按量付费/按时付费）以及<strong>支付方式</strong>：按时 or 按量，这个取决于使用者的需求，如果像笔者一样是新手或者换种说法是首次希望通过付费VPN的方式“科学上网”，偶尔登录Google查阅资料，而且不用刷Twitter，暂时没有部署在国外服务器上的网站需要维护的话，可以选择价位不高且流量不大的服务；支付方式也被我放在这里，国内的很多朋友可能没有双币信用卡，Paypal付款难免有些麻烦，查了好几个VPN的服务商都已经支持支付宝付款了，还是很方便的。</li>\n<li><strong>配置难易度、客服响应速度</strong>：</li>\n<li><strong>隐私安全</strong>：毕竟我们在通过VPN连接时，本地的数据包是发送到远方服务器再跳转的，这期间是否会被抓包，窃取资料就是一个值得考虑的问题，笔者建议不用在VPN连接时使用网银等，即使VPN已经声明了数据信息已经加密，要保持警惕，保护隐私。</li>\n<li><strong>服务器地点</strong>：这点可能目前阶段不是笔者比较在意的一点，无论VPN服务商提供的是美国、日本、加拿大、台湾等何地的服务器，对于笔者来说不是特别重要，只要可以达到稳定的连接就可以。但是对于一些对服务地有强烈需求的朋友来说，比如一些游戏玩家，PS4和XBOX必须要连接当地的服务才能玩，这时服务器所在的地点就成了比较重要的考虑因素之一了。</li>\n</ul>\n<h2 id=\"付费VPN收集\"><a href=\"#付费VPN收集\" class=\"headerlink\" title=\"付费VPN收集\"></a>付费VPN收集</h2><p>很幸运在微博上认识一位朋友<a href=\"http://weibo.com/liwei198870\" target=\"_blank\" rel=\"noopener\">聆听潇湘雨</a>，请教了一些知识，也很感谢他推荐了几个付费VPN给我，包括我自己查阅的资料在下面罗列一下，具体服务需要等各位用户先自己试用，稍后再提供我的使用报告：</p>\n<ul>\n<li><a href=\"https://www.pandafan.org/?r=2885\" target=\"_blank\" rel=\"noopener\">熊猫翻滚</a> 顾名思义，熊猫天朝特产，朋友推荐说智能分流做的很好，就是国内和国外的网站可以自动区分，这样连接VPN的同时国内网站的访问速度影响有效降低。</li>\n<li><a href=\"https://www.ytvpn.com/\" target=\"_blank\" rel=\"noopener\">云梯</a>  在V2EX社区看到有人推荐过，也注册了一下，同学有需求想下载Google Android文档和源码，于是就买了这家的服务，速度还是很快的，支持3天内退款。</li>\n<li><a href=\"https://getqujing.com/zh-CN\" target=\"_blank\" rel=\"noopener\">曲径</a>  官网介绍是为了国外音乐类流量服务，有一些大V也在各自的推文中有介绍，想必也积累了一些人气，服务应该做的还是不错的，要不然也不会这么多人推荐。可月付或者季付、限流量，其【冬月】套餐比较适合多终端的用户。</li>\n<li><a href=\"https://theqingyun.co/r/ncmbi3\" target=\"_blank\" rel=\"noopener\">轻云</a>  资费比较合理，支持的设备较多，同时允许7台设备在线。</li>\n<li><a href=\"http://98.126.129.242/index.php\" target=\"_blank\" rel=\"noopener\">YesVPN</a>  包月10RMB，包年100RMB</li>\n<li><a href=\"https://www.shayujsq.net/index.php\" target=\"_blank\" rel=\"noopener\">鲨鱼VPN</a> </li>\n<li>Google搜索 付费VPN 关键字 : )</li>\n</ul>\n<h2 id=\"VPN-FOR-FREE\"><a href=\"#VPN-FOR-FREE\" class=\"headerlink\" title=\"VPN FOR FREE\"></a>VPN FOR FREE</h2><ul>\n<li>Chrome插件 - <a href=\"http://honx.in/i/U7DdTYKo11MoCLEP\" target=\"_blank\" rel=\"noopener\">红杏</a> 浏览器上的插件，使用者仅仅通过安装Chrome浏览器插件，使用邮箱注册用户，就可以直接访问Google、Facebook和Twitter了。简单使用，缺点非VIP版服务器不是特别稳定，笔者在最近3天的使用过程中有一天下午基本无法使用，服务断断续续。当然也可以购买VIP版，笔者还没有购买体验就不便在这里细说，如果仅限浏览器翻墙，查看网页或者单线程下载一些小文件的话，这颗“红杏”是个不错的选择。</li>\n</ul>\n<p>文章还没写完，今天红杏免费版就挂了，但是红杏VIP版还是很受欢迎的。</p>\n<ul>\n<li>Google搜索 免费VPN 关键字即可 : )</li>\n</ul>\n<h2 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h2><p>在完成这篇Blog的过程中，查阅的信息逐渐像水滴波纹一样散开，信息量过大，越来越害怕，觉得这里需要做功课的东西还是太多，有些不敢写了，因此标题也是改了又改，缩小范围。后面补补课再给各位带来其他科学上网的方式。</p>\n<p>因为目前对科学上网需求不是那么强烈，因此在写完这篇Blog后，我觉得先买一个熊猫翻滚之学术熊猫试用一个月（这其中也有微博朋友极力推荐的因素）。</p>\n<p>其他科学上网收集如下，以后有机会在研究跟大家分享：</p>\n<ul>\n<li><a href=\"https://eurekavpt.com\" target=\"_blank\" rel=\"noopener\">eurekavpt</a></li>\n<li><a href=\"http://ippotsuko.com/blog/shadowsocks/\" target=\"_blank\" rel=\"noopener\">ShadowSocks</a></li>\n<li><a href=\"https://pcnt.in/\" target=\"_blank\" rel=\"noopener\">PowerConnect</a> &amp;&amp; <a href=\"https://twitter.com/PowerPACNetwork\" target=\"_blank\" rel=\"noopener\">官方 Twitter</a> 会不定时放出邀请码</li>\n<li>….</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>“工欲善其事，必先利其器” 今天笔者来和大家一起分享，最近查阅资料整理后的一些关于VPN的那点事儿。</p>","more":"<p>刚刚加班到家，整理一下这篇最近在查阅资料关于VPN的一些内容，以及一些付费VPN的简单介绍。</p>\n<h3 id=\"什么是VPN\"><a href=\"#什么是VPN\" class=\"headerlink\" title=\"什么是VPN\"></a>什么是VPN</h3><p>VPN 可以通过特殊的加密通讯协议，在连接 Internet 上位于不同地方的两个或多个企业内部网之间建立一条专有的通讯线路；就好比是架设了一条专线，但它并不需要真正的去铺设光缆之类的物理线路；就像去电信局申请专线，但是不用给铺设线路的费用，也不用购买路由器等硬件设备。</p>\n<p>VPN 技术原是路由器的重要技术之一，在交换机、防火墙设备或各大操作系统里也都支持 VPN 功能，VPN 的核心就是利用公共网络建立虚拟私有网。</p>\n<p>通俗的说，如果你想不被别人探查到你的 IP 地址，如果你想访问大量原本无法登录的国外网站，如果你想更安全进行数据传输，请使用 VPN。</p>\n<h3 id=\"PPTP和L2TP区别\"><a href=\"#PPTP和L2TP区别\" class=\"headerlink\" title=\"PPTP和L2TP区别\"></a>PPTP和L2TP区别</h3><p>最常见最流行的 VPN 协议包含 PPTP 协议和 L2TP/IPSec 协议。如果你希望设置简单，对通信安全没有太大的要求，那么你配置 PPTP 连接即可；如果你的网络里 PPTP 协议未被允许，或者希望数据通信更安全的话，就推荐设置 L2TP/IPSec 连接。在设置上，步骤基本一致，只是 L2TP/IPSec 协议需要输入共享密钥。</p>\n<ul>\n<li>PPTP（Point to Point Tunneling Protocol）点对点隧道协议：是一种主要用于 VPN 的数据链路层网络协议，PPTP 的协议规范本身并未描述加密或身份验证的特性。</li>\n<li>L2TP（Layer Two Tunneling Protocol) 第二层隧道协议：是一种数据链路层隧道协议，通常用于虚拟专用网。L2TP 协议自身不对传输的数据进行加密，但是可以和加密协议搭配使用，从而实现数据的加密传输。经常与 L2TP 协议搭配的加密协议是 IPsec，当这两个协议搭配使用时，通常合称 L2TP/IPsec。</li>\n</ul>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ul>\n<li>科学上网</li>\n<li>配置方便，配置好以后，直接连接，就可以使用</li>\n<li>安全，一把双刃剑，因为VPN连接，我们的数据包都是通过中间服务器转发，VPN提供了很多种加密的方式，这样就可以很好地保护我们的隐私，隐藏IP等。</li>\n</ul>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><ul>\n<li>受GFW干扰较大，由于使用UDP技术，连接可能受干扰</li>\n<li>比较依赖本地的网络环境</li>\n<li>ISP网络的可能会阻止VPN的连接，导致连不上或者速度慢</li>\n<li>VPN是保持连接，不是特别灵活，要断要连在使用过程中难免有麻烦</li>\n<li>安全，不能排除我们的数据包被中间服务器抓包或者截取的可能。</li>\n</ul>\n<h2 id=\"选择VPN\"><a href=\"#选择VPN\" class=\"headerlink\" title=\"选择VPN\"></a>选择VPN</h2><p>前面一些“科普”的文字给大家码好字之后，下面笔者在选购VPN的时候主要关注一下几点，在这里和各位分享一下，可能与各位不同，欢迎读者朋友讨论吐槽！</p>\n<ul>\n<li><strong>稳定性</strong>：这是我比较重视一点，所以放在第一个，VPN的连接速度以及连接的稳定性，直接影响到使用者的感受，之所以找付费版VPN，最重要的就是想享受稳定的连接，不希望遇到经常掉线重连，或者经常不得不被动地切换多个连接。</li>\n<li><strong>终端支持</strong>：我的需求是希望支持Mac、iPhone、iPad至少三台终端同时连接，这样在多端就可以无缝享受网络。</li>\n<li><strong>连接速度</strong>（上行/下行）：不知道读者朋友有没有跟笔者一样的感受，网络慢得时候电脑也会有慢得错觉。当然了，“慢”一定有很多原因，也可能是错觉，但是连接VPN后同样拥有普通连接相同或者不会降低很多的网络速度，是非常重要的一点，也同样是申请VPN退款的原因之一。</li>\n<li><strong>价格</strong>（按量付费/按时付费）以及<strong>支付方式</strong>：按时 or 按量，这个取决于使用者的需求，如果像笔者一样是新手或者换种说法是首次希望通过付费VPN的方式“科学上网”，偶尔登录Google查阅资料，而且不用刷Twitter，暂时没有部署在国外服务器上的网站需要维护的话，可以选择价位不高且流量不大的服务；支付方式也被我放在这里，国内的很多朋友可能没有双币信用卡，Paypal付款难免有些麻烦，查了好几个VPN的服务商都已经支持支付宝付款了，还是很方便的。</li>\n<li><strong>配置难易度、客服响应速度</strong>：</li>\n<li><strong>隐私安全</strong>：毕竟我们在通过VPN连接时，本地的数据包是发送到远方服务器再跳转的，这期间是否会被抓包，窃取资料就是一个值得考虑的问题，笔者建议不用在VPN连接时使用网银等，即使VPN已经声明了数据信息已经加密，要保持警惕，保护隐私。</li>\n<li><strong>服务器地点</strong>：这点可能目前阶段不是笔者比较在意的一点，无论VPN服务商提供的是美国、日本、加拿大、台湾等何地的服务器，对于笔者来说不是特别重要，只要可以达到稳定的连接就可以。但是对于一些对服务地有强烈需求的朋友来说，比如一些游戏玩家，PS4和XBOX必须要连接当地的服务才能玩，这时服务器所在的地点就成了比较重要的考虑因素之一了。</li>\n</ul>\n<h2 id=\"付费VPN收集\"><a href=\"#付费VPN收集\" class=\"headerlink\" title=\"付费VPN收集\"></a>付费VPN收集</h2><p>很幸运在微博上认识一位朋友<a href=\"http://weibo.com/liwei198870\" target=\"_blank\" rel=\"noopener\">聆听潇湘雨</a>，请教了一些知识，也很感谢他推荐了几个付费VPN给我，包括我自己查阅的资料在下面罗列一下，具体服务需要等各位用户先自己试用，稍后再提供我的使用报告：</p>\n<ul>\n<li><a href=\"https://www.pandafan.org/?r=2885\" target=\"_blank\" rel=\"noopener\">熊猫翻滚</a> 顾名思义，熊猫天朝特产，朋友推荐说智能分流做的很好，就是国内和国外的网站可以自动区分，这样连接VPN的同时国内网站的访问速度影响有效降低。</li>\n<li><a href=\"https://www.ytvpn.com/\" target=\"_blank\" rel=\"noopener\">云梯</a>  在V2EX社区看到有人推荐过，也注册了一下，同学有需求想下载Google Android文档和源码，于是就买了这家的服务，速度还是很快的，支持3天内退款。</li>\n<li><a href=\"https://getqujing.com/zh-CN\" target=\"_blank\" rel=\"noopener\">曲径</a>  官网介绍是为了国外音乐类流量服务，有一些大V也在各自的推文中有介绍，想必也积累了一些人气，服务应该做的还是不错的，要不然也不会这么多人推荐。可月付或者季付、限流量，其【冬月】套餐比较适合多终端的用户。</li>\n<li><a href=\"https://theqingyun.co/r/ncmbi3\" target=\"_blank\" rel=\"noopener\">轻云</a>  资费比较合理，支持的设备较多，同时允许7台设备在线。</li>\n<li><a href=\"http://98.126.129.242/index.php\" target=\"_blank\" rel=\"noopener\">YesVPN</a>  包月10RMB，包年100RMB</li>\n<li><a href=\"https://www.shayujsq.net/index.php\" target=\"_blank\" rel=\"noopener\">鲨鱼VPN</a> </li>\n<li>Google搜索 付费VPN 关键字 : )</li>\n</ul>\n<h2 id=\"VPN-FOR-FREE\"><a href=\"#VPN-FOR-FREE\" class=\"headerlink\" title=\"VPN FOR FREE\"></a>VPN FOR FREE</h2><ul>\n<li>Chrome插件 - <a href=\"http://honx.in/i/U7DdTYKo11MoCLEP\" target=\"_blank\" rel=\"noopener\">红杏</a> 浏览器上的插件，使用者仅仅通过安装Chrome浏览器插件，使用邮箱注册用户，就可以直接访问Google、Facebook和Twitter了。简单使用，缺点非VIP版服务器不是特别稳定，笔者在最近3天的使用过程中有一天下午基本无法使用，服务断断续续。当然也可以购买VIP版，笔者还没有购买体验就不便在这里细说，如果仅限浏览器翻墙，查看网页或者单线程下载一些小文件的话，这颗“红杏”是个不错的选择。</li>\n</ul>\n<p>文章还没写完，今天红杏免费版就挂了，但是红杏VIP版还是很受欢迎的。</p>\n<ul>\n<li>Google搜索 免费VPN 关键字即可 : )</li>\n</ul>\n<h2 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h2><p>在完成这篇Blog的过程中，查阅的信息逐渐像水滴波纹一样散开，信息量过大，越来越害怕，觉得这里需要做功课的东西还是太多，有些不敢写了，因此标题也是改了又改，缩小范围。后面补补课再给各位带来其他科学上网的方式。</p>\n<p>因为目前对科学上网需求不是那么强烈，因此在写完这篇Blog后，我觉得先买一个熊猫翻滚之学术熊猫试用一个月（这其中也有微博朋友极力推荐的因素）。</p>\n<p>其他科学上网收集如下，以后有机会在研究跟大家分享：</p>\n<ul>\n<li><a href=\"https://eurekavpt.com\" target=\"_blank\" rel=\"noopener\">eurekavpt</a></li>\n<li><a href=\"http://ippotsuko.com/blog/shadowsocks/\" target=\"_blank\" rel=\"noopener\">ShadowSocks</a></li>\n<li><a href=\"https://pcnt.in/\" target=\"_blank\" rel=\"noopener\">PowerConnect</a> &amp;&amp; <a href=\"https://twitter.com/PowerPACNetwork\" target=\"_blank\" rel=\"noopener\">官方 Twitter</a> 会不定时放出邀请码</li>\n<li>….</li>\n</ul>"},{"title":"OSC源创回年终盛典","date":"2014-11-25T21:25:50.000Z","_content":"\n开源中国2014年终盛典大会参会笔记\n\n<!-- more -->\n\n# OSC源创会年终盛典\n\n## 开源中国的志向 - 马越\nGit，Sonar，Team……JFinal\n互联网之子-施瓦茨，一切皆开源，要参与其中；年轻人，OSCer“我们就是梦想！”；感谢阿里巴巴、华为贡献开源的力量\n\n## RDS 阿里云 数据通道挑战与实现 褚霸\n\n功能\n* 高可用/屏蔽后端变化/安全、数据路由，冷热数据区分、数据操作，分库分表、支持多种数据后端，MySQL MSSQL\n\n约束\n* 普通PC服务器、高可用、规模/可横向拓展、可运维可控\n\n可用性\n* LVS商业版 SLBv3流量层 ---- Proxy负载均衡 ---- Master\n* 流量层：VIP漂移保证用户不要切换DNS，session同步解决单机down机影响\n* Proxy层：Erlang VM作为中间件、支持热升级，不用切分流量\n* DB层：主备结构、跨机房/跨机架、主备同步/异步复制减少延迟、数据安全\n\n性能：RT、吞吐量、QPS、短链接性能\n\n## 剖析开源技术趋势&华为开源现状\n\n* 趋势：互联网化、平台级、推动硬件电信系统等发展、社区运营公司化、标准化\n* 华为开源者能力中心，鼓励、支持\n* 使用策略和原则：参考自行实现，架构解耦、社区同源减少维护成本\n\n# 云计算专场\n\n## 开源分布式对象存储 OpenStack Swift - 李明宇microwise\n\nOpenStack : A cloud operation system\nIt's  a group system. 11 projects so huge, but the biggest user use 3.5 projects  . Install in CentOS 7.\nOpenStack Swift: RESTfull Web API 直接从存储提供REST服务，解决访问无业务的文件的需求\nArchitecture of Swift: 图见CSDN Proxy Server接收请求 -- Controller 通过hash等算法保证请求均匀分布 -- 存储层\nStory Policy: 可配置存储，比如保存位置，可靠性\nOpenStack & Docker\nReading: OpenStack 云计算实战手册，OpenStack 企业云\nProxy Server 不存在单节点问题，proxy无状态\n\n## CoreOS 与容器管理\n\n","source":"_posts/2014-11-25-OSC-Party.md","raw":"---\ntitle: OSC源创回年终盛典\ncategory : Note\ndate: 2014-11-26 05:25:50\ntags: [note]\n---\n\n开源中国2014年终盛典大会参会笔记\n\n<!-- more -->\n\n# OSC源创会年终盛典\n\n## 开源中国的志向 - 马越\nGit，Sonar，Team……JFinal\n互联网之子-施瓦茨，一切皆开源，要参与其中；年轻人，OSCer“我们就是梦想！”；感谢阿里巴巴、华为贡献开源的力量\n\n## RDS 阿里云 数据通道挑战与实现 褚霸\n\n功能\n* 高可用/屏蔽后端变化/安全、数据路由，冷热数据区分、数据操作，分库分表、支持多种数据后端，MySQL MSSQL\n\n约束\n* 普通PC服务器、高可用、规模/可横向拓展、可运维可控\n\n可用性\n* LVS商业版 SLBv3流量层 ---- Proxy负载均衡 ---- Master\n* 流量层：VIP漂移保证用户不要切换DNS，session同步解决单机down机影响\n* Proxy层：Erlang VM作为中间件、支持热升级，不用切分流量\n* DB层：主备结构、跨机房/跨机架、主备同步/异步复制减少延迟、数据安全\n\n性能：RT、吞吐量、QPS、短链接性能\n\n## 剖析开源技术趋势&华为开源现状\n\n* 趋势：互联网化、平台级、推动硬件电信系统等发展、社区运营公司化、标准化\n* 华为开源者能力中心，鼓励、支持\n* 使用策略和原则：参考自行实现，架构解耦、社区同源减少维护成本\n\n# 云计算专场\n\n## 开源分布式对象存储 OpenStack Swift - 李明宇microwise\n\nOpenStack : A cloud operation system\nIt's  a group system. 11 projects so huge, but the biggest user use 3.5 projects  . Install in CentOS 7.\nOpenStack Swift: RESTfull Web API 直接从存储提供REST服务，解决访问无业务的文件的需求\nArchitecture of Swift: 图见CSDN Proxy Server接收请求 -- Controller 通过hash等算法保证请求均匀分布 -- 存储层\nStory Policy: 可配置存储，比如保存位置，可靠性\nOpenStack & Docker\nReading: OpenStack 云计算实战手册，OpenStack 企业云\nProxy Server 不存在单节点问题，proxy无状态\n\n## CoreOS 与容器管理\n\n","slug":"OSC-Party","published":1,"updated":"2017-11-04T11:09:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc31n1fs001pgey5fs7578kt","content":"<p>开源中国2014年终盛典大会参会笔记</p>\n<a id=\"more\"></a>\n<h1 id=\"OSC源创会年终盛典\"><a href=\"#OSC源创会年终盛典\" class=\"headerlink\" title=\"OSC源创会年终盛典\"></a>OSC源创会年终盛典</h1><h2 id=\"开源中国的志向-马越\"><a href=\"#开源中国的志向-马越\" class=\"headerlink\" title=\"开源中国的志向 - 马越\"></a>开源中国的志向 - 马越</h2><p>Git，Sonar，Team……JFinal<br>互联网之子-施瓦茨，一切皆开源，要参与其中；年轻人，OSCer“我们就是梦想！”；感谢阿里巴巴、华为贡献开源的力量</p>\n<h2 id=\"RDS-阿里云-数据通道挑战与实现-褚霸\"><a href=\"#RDS-阿里云-数据通道挑战与实现-褚霸\" class=\"headerlink\" title=\"RDS 阿里云 数据通道挑战与实现 褚霸\"></a>RDS 阿里云 数据通道挑战与实现 褚霸</h2><p>功能</p>\n<ul>\n<li>高可用/屏蔽后端变化/安全、数据路由，冷热数据区分、数据操作，分库分表、支持多种数据后端，MySQL MSSQL</li>\n</ul>\n<p>约束</p>\n<ul>\n<li>普通PC服务器、高可用、规模/可横向拓展、可运维可控</li>\n</ul>\n<p>可用性</p>\n<ul>\n<li>LVS商业版 SLBv3流量层 —- Proxy负载均衡 —- Master</li>\n<li>流量层：VIP漂移保证用户不要切换DNS，session同步解决单机down机影响</li>\n<li>Proxy层：Erlang VM作为中间件、支持热升级，不用切分流量</li>\n<li>DB层：主备结构、跨机房/跨机架、主备同步/异步复制减少延迟、数据安全</li>\n</ul>\n<p>性能：RT、吞吐量、QPS、短链接性能</p>\n<h2 id=\"剖析开源技术趋势-amp-华为开源现状\"><a href=\"#剖析开源技术趋势-amp-华为开源现状\" class=\"headerlink\" title=\"剖析开源技术趋势&amp;华为开源现状\"></a>剖析开源技术趋势&amp;华为开源现状</h2><ul>\n<li>趋势：互联网化、平台级、推动硬件电信系统等发展、社区运营公司化、标准化</li>\n<li>华为开源者能力中心，鼓励、支持</li>\n<li>使用策略和原则：参考自行实现，架构解耦、社区同源减少维护成本</li>\n</ul>\n<h1 id=\"云计算专场\"><a href=\"#云计算专场\" class=\"headerlink\" title=\"云计算专场\"></a>云计算专场</h1><h2 id=\"开源分布式对象存储-OpenStack-Swift-李明宇microwise\"><a href=\"#开源分布式对象存储-OpenStack-Swift-李明宇microwise\" class=\"headerlink\" title=\"开源分布式对象存储 OpenStack Swift - 李明宇microwise\"></a>开源分布式对象存储 OpenStack Swift - 李明宇microwise</h2><p>OpenStack : A cloud operation system<br>It’s  a group system. 11 projects so huge, but the biggest user use 3.5 projects  . Install in CentOS 7.<br>OpenStack Swift: RESTfull Web API 直接从存储提供REST服务，解决访问无业务的文件的需求<br>Architecture of Swift: 图见CSDN Proxy Server接收请求 – Controller 通过hash等算法保证请求均匀分布 – 存储层<br>Story Policy: 可配置存储，比如保存位置，可靠性<br>OpenStack &amp; Docker<br>Reading: OpenStack 云计算实战手册，OpenStack 企业云<br>Proxy Server 不存在单节点问题，proxy无状态</p>\n<h2 id=\"CoreOS-与容器管理\"><a href=\"#CoreOS-与容器管理\" class=\"headerlink\" title=\"CoreOS 与容器管理\"></a>CoreOS 与容器管理</h2>","site":{"data":{}},"excerpt":"<p>开源中国2014年终盛典大会参会笔记</p>","more":"<h1 id=\"OSC源创会年终盛典\"><a href=\"#OSC源创会年终盛典\" class=\"headerlink\" title=\"OSC源创会年终盛典\"></a>OSC源创会年终盛典</h1><h2 id=\"开源中国的志向-马越\"><a href=\"#开源中国的志向-马越\" class=\"headerlink\" title=\"开源中国的志向 - 马越\"></a>开源中国的志向 - 马越</h2><p>Git，Sonar，Team……JFinal<br>互联网之子-施瓦茨，一切皆开源，要参与其中；年轻人，OSCer“我们就是梦想！”；感谢阿里巴巴、华为贡献开源的力量</p>\n<h2 id=\"RDS-阿里云-数据通道挑战与实现-褚霸\"><a href=\"#RDS-阿里云-数据通道挑战与实现-褚霸\" class=\"headerlink\" title=\"RDS 阿里云 数据通道挑战与实现 褚霸\"></a>RDS 阿里云 数据通道挑战与实现 褚霸</h2><p>功能</p>\n<ul>\n<li>高可用/屏蔽后端变化/安全、数据路由，冷热数据区分、数据操作，分库分表、支持多种数据后端，MySQL MSSQL</li>\n</ul>\n<p>约束</p>\n<ul>\n<li>普通PC服务器、高可用、规模/可横向拓展、可运维可控</li>\n</ul>\n<p>可用性</p>\n<ul>\n<li>LVS商业版 SLBv3流量层 —- Proxy负载均衡 —- Master</li>\n<li>流量层：VIP漂移保证用户不要切换DNS，session同步解决单机down机影响</li>\n<li>Proxy层：Erlang VM作为中间件、支持热升级，不用切分流量</li>\n<li>DB层：主备结构、跨机房/跨机架、主备同步/异步复制减少延迟、数据安全</li>\n</ul>\n<p>性能：RT、吞吐量、QPS、短链接性能</p>\n<h2 id=\"剖析开源技术趋势-amp-华为开源现状\"><a href=\"#剖析开源技术趋势-amp-华为开源现状\" class=\"headerlink\" title=\"剖析开源技术趋势&amp;华为开源现状\"></a>剖析开源技术趋势&amp;华为开源现状</h2><ul>\n<li>趋势：互联网化、平台级、推动硬件电信系统等发展、社区运营公司化、标准化</li>\n<li>华为开源者能力中心，鼓励、支持</li>\n<li>使用策略和原则：参考自行实现，架构解耦、社区同源减少维护成本</li>\n</ul>\n<h1 id=\"云计算专场\"><a href=\"#云计算专场\" class=\"headerlink\" title=\"云计算专场\"></a>云计算专场</h1><h2 id=\"开源分布式对象存储-OpenStack-Swift-李明宇microwise\"><a href=\"#开源分布式对象存储-OpenStack-Swift-李明宇microwise\" class=\"headerlink\" title=\"开源分布式对象存储 OpenStack Swift - 李明宇microwise\"></a>开源分布式对象存储 OpenStack Swift - 李明宇microwise</h2><p>OpenStack : A cloud operation system<br>It’s  a group system. 11 projects so huge, but the biggest user use 3.5 projects  . Install in CentOS 7.<br>OpenStack Swift: RESTfull Web API 直接从存储提供REST服务，解决访问无业务的文件的需求<br>Architecture of Swift: 图见CSDN Proxy Server接收请求 – Controller 通过hash等算法保证请求均匀分布 – 存储层<br>Story Policy: 可配置存储，比如保存位置，可靠性<br>OpenStack &amp; Docker<br>Reading: OpenStack 云计算实战手册，OpenStack 企业云<br>Proxy Server 不存在单节点问题，proxy无状态</p>\n<h2 id=\"CoreOS-与容器管理\"><a href=\"#CoreOS-与容器管理\" class=\"headerlink\" title=\"CoreOS 与容器管理\"></a>CoreOS 与容器管理</h2>"},{"title":"Questions Of Front-End","date":"2015-06-27T00:32:19.000Z","_content":"\n前端问题总结整理，持续更新和学习，找到想做的就加油做个行动派吧！\n\n<!--more-->\n\n> 千万不要为了当前不好而跳槽，一定是要因为将来会更好而跳槽！\n\n# HTML\n\n+ 盒子模型\nmargin - border - padding - content - padding - border - margin\n上下两个元素之间会有margin合并问题\n\n+ 块级元素和行内元素区别\nhttp://blog.csdn.net/chen_zw/article/details/8713205\nhttp://segmentfault.com/a/1190000000654770\n\n# CSS\n\n+ 实现一个叉号有几种实现方式\n1.切图 2.先用一个span画一个长方形，圆角，然后使用transform倾斜 3.CSS3中使用Webfont 4.伪类\n```css\nTODO 代码实现\n```\n\n+ CSS常用选择器\nID、类、伪类、父子选择器等等\n\n# Javascript\n\n+ 原型链 prototype\n[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain)\n\n实现的本质是重新原型对象。\n\n+ 原生ajax写法\nXMLHttpRequest, XMLHttpResponse\n\n+ 事件模型和事件传播机制问题\n浏览器中事件可以分为三种：鼠标事件；键盘事件；HTML事件；\n捕获和冒泡的顺序在不同浏览器中不同，IE下事件流采用的是冒泡，基于DOM标准兼容浏览器通常采用先捕获后冒泡方式。\n\n``addEventListener() & removeEventListener()``\n所有 DOM 节点都包含这两个方法，都接受三个参数：要处理的事件名，作为事件处理程序的函数，一个布尔值。最后这个参数布尔值，``true``表示在捕获时调用事件处理函数，``false``表示在冒泡时调用时间处理函数。\n\n```javascript\nvar btn = document.getElementById(\"myBtn\");\nbtn.addEventListener(\"click\", function(){\n  alert(\"click\");\n}, flase);\n```\n\n+ 跨域 JSONP 实现原理\n原理：回调函数\nJSONP 由两部分组成：回调函数和数据。\n\nFor Example:\n```javascript\nfunction handleResponse(response) {\n  alert(\"You're at IP \" + response.ip + \", which is in \" + response.city);\n}\nvar script = document.createElement(\"script\");\nscript.src = \"http://freegeoip.net/json/?callback=handleResponse\";\ndocument.body.insertBefore(script, document.body.fisrtChild);\n```\n\n+ ``<script>``中defer和asyc区别和加载顺序\n  - asyc: ``异步脚本``虽然立即下载脚本，不应该方案页面中其他操作，比如下载其他资源或等待加载其他脚本。只对外部脚本有效。不能保证按照指定的先后顺序执行，建议异步脚本不要在加载期间修改 DOM。\n  - defer: ``延迟脚本``可以延迟到文档完全被解析和显示之后再执行。只针对外部脚本有效。在现实当中，延迟脚本不一定按照顺序执行，不一定会在 DOMContentLoaded 事件触发前执行，因此最好只包含一个延迟脚本\n\n+ 闭包：指有权访问另一个函数作用域中的变量和函数。\n\n+ 作用域：当代码在一个环境执行时，会创建变量对象的一个作用域。\n理解：类似 Java 的成员变量\n```javascript\nvar color = \"blue\";\nfunction changeColor() {\n  var anotherColor = \"red\";\n\n  function swapColor() {\n    var tempColor = anotherColor;\n    anotherColor = color;\n    color = tempColor;\n    // 这里可以访问 color, anotherColor 和 tempColor\n  }\n  // 这里可以访问 color, anotherColor\n  swapColor();\n}\n// 这里只能访问 color\nchangeColor();\n```\n\n\n","source":"_posts/2015-06-27-Question-Of-Front-End.md","raw":"title: Questions Of Front-End\ncategory : Note\ndate: 2015-06-27 08:32:19\ntags: [Javascript, HTML, CSS, Front-End]\n---\n\n前端问题总结整理，持续更新和学习，找到想做的就加油做个行动派吧！\n\n<!--more-->\n\n> 千万不要为了当前不好而跳槽，一定是要因为将来会更好而跳槽！\n\n# HTML\n\n+ 盒子模型\nmargin - border - padding - content - padding - border - margin\n上下两个元素之间会有margin合并问题\n\n+ 块级元素和行内元素区别\nhttp://blog.csdn.net/chen_zw/article/details/8713205\nhttp://segmentfault.com/a/1190000000654770\n\n# CSS\n\n+ 实现一个叉号有几种实现方式\n1.切图 2.先用一个span画一个长方形，圆角，然后使用transform倾斜 3.CSS3中使用Webfont 4.伪类\n```css\nTODO 代码实现\n```\n\n+ CSS常用选择器\nID、类、伪类、父子选择器等等\n\n# Javascript\n\n+ 原型链 prototype\n[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain)\n\n实现的本质是重新原型对象。\n\n+ 原生ajax写法\nXMLHttpRequest, XMLHttpResponse\n\n+ 事件模型和事件传播机制问题\n浏览器中事件可以分为三种：鼠标事件；键盘事件；HTML事件；\n捕获和冒泡的顺序在不同浏览器中不同，IE下事件流采用的是冒泡，基于DOM标准兼容浏览器通常采用先捕获后冒泡方式。\n\n``addEventListener() & removeEventListener()``\n所有 DOM 节点都包含这两个方法，都接受三个参数：要处理的事件名，作为事件处理程序的函数，一个布尔值。最后这个参数布尔值，``true``表示在捕获时调用事件处理函数，``false``表示在冒泡时调用时间处理函数。\n\n```javascript\nvar btn = document.getElementById(\"myBtn\");\nbtn.addEventListener(\"click\", function(){\n  alert(\"click\");\n}, flase);\n```\n\n+ 跨域 JSONP 实现原理\n原理：回调函数\nJSONP 由两部分组成：回调函数和数据。\n\nFor Example:\n```javascript\nfunction handleResponse(response) {\n  alert(\"You're at IP \" + response.ip + \", which is in \" + response.city);\n}\nvar script = document.createElement(\"script\");\nscript.src = \"http://freegeoip.net/json/?callback=handleResponse\";\ndocument.body.insertBefore(script, document.body.fisrtChild);\n```\n\n+ ``<script>``中defer和asyc区别和加载顺序\n  - asyc: ``异步脚本``虽然立即下载脚本，不应该方案页面中其他操作，比如下载其他资源或等待加载其他脚本。只对外部脚本有效。不能保证按照指定的先后顺序执行，建议异步脚本不要在加载期间修改 DOM。\n  - defer: ``延迟脚本``可以延迟到文档完全被解析和显示之后再执行。只针对外部脚本有效。在现实当中，延迟脚本不一定按照顺序执行，不一定会在 DOMContentLoaded 事件触发前执行，因此最好只包含一个延迟脚本\n\n+ 闭包：指有权访问另一个函数作用域中的变量和函数。\n\n+ 作用域：当代码在一个环境执行时，会创建变量对象的一个作用域。\n理解：类似 Java 的成员变量\n```javascript\nvar color = \"blue\";\nfunction changeColor() {\n  var anotherColor = \"red\";\n\n  function swapColor() {\n    var tempColor = anotherColor;\n    anotherColor = color;\n    color = tempColor;\n    // 这里可以访问 color, anotherColor 和 tempColor\n  }\n  // 这里可以访问 color, anotherColor\n  swapColor();\n}\n// 这里只能访问 color\nchangeColor();\n```\n\n\n","slug":"Question-Of-Front-End","published":1,"updated":"2017-11-04T11:09:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc31n1fu001sgey56cwdwn1j","content":"<p>前端问题总结整理，持续更新和学习，找到想做的就加油做个行动派吧！</p>\n<a id=\"more\"></a>\n<blockquote>\n<p>千万不要为了当前不好而跳槽，一定是要因为将来会更好而跳槽！</p>\n</blockquote>\n<h1 id=\"HTML\"><a href=\"#HTML\" class=\"headerlink\" title=\"HTML\"></a>HTML</h1><ul>\n<li><p>盒子模型<br>margin - border - padding - content - padding - border - margin<br>上下两个元素之间会有margin合并问题</p>\n</li>\n<li><p>块级元素和行内元素区别<br><a href=\"http://blog.csdn.net/chen_zw/article/details/8713205\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chen_zw/article/details/8713205</a><br><a href=\"http://segmentfault.com/a/1190000000654770\" target=\"_blank\" rel=\"noopener\">http://segmentfault.com/a/1190000000654770</a></p>\n</li>\n</ul>\n<h1 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a>CSS</h1><ul>\n<li><p>实现一个叉号有几种实现方式<br>1.切图 2.先用一个span画一个长方形，圆角，然后使用transform倾斜 3.CSS3中使用Webfont 4.伪类</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">TODO</span> 代码实现</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>CSS常用选择器<br>ID、类、伪类、父子选择器等等</p>\n</li>\n</ul>\n<h1 id=\"Javascript\"><a href=\"#Javascript\" class=\"headerlink\" title=\"Javascript\"></a>Javascript</h1><ul>\n<li>原型链 prototype<br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain\" target=\"_blank\" rel=\"noopener\">MDN</a></li>\n</ul>\n<p>实现的本质是重新原型对象。</p>\n<ul>\n<li><p>原生ajax写法<br>XMLHttpRequest, XMLHttpResponse</p>\n</li>\n<li><p>事件模型和事件传播机制问题<br>浏览器中事件可以分为三种：鼠标事件；键盘事件；HTML事件；<br>捕获和冒泡的顺序在不同浏览器中不同，IE下事件流采用的是冒泡，基于DOM标准兼容浏览器通常采用先捕获后冒泡方式。</p>\n</li>\n</ul>\n<p><code>addEventListener() &amp; removeEventListener()</code><br>所有 DOM 节点都包含这两个方法，都接受三个参数：要处理的事件名，作为事件处理程序的函数，一个布尔值。最后这个参数布尔值，<code>true</code>表示在捕获时调用事件处理函数，<code>false</code>表示在冒泡时调用时间处理函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> btn = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"myBtn\"</span>);</span><br><span class=\"line\">btn.addEventListener(<span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  alert(<span class=\"string\">\"click\"</span>);</span><br><span class=\"line\">&#125;, flase);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>跨域 JSONP 实现原理<br>原理：回调函数<br>JSONP 由两部分组成：回调函数和数据。</li>\n</ul>\n<p>For Example:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleResponse</span>(<span class=\"params\">response</span>) </span>&#123;</span><br><span class=\"line\">  alert(<span class=\"string\">\"You're at IP \"</span> + response.ip + <span class=\"string\">\", which is in \"</span> + response.city);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> script = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"script\"</span>);</span><br><span class=\"line\">script.src = <span class=\"string\">\"http://freegeoip.net/json/?callback=handleResponse\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.insertBefore(script, <span class=\"built_in\">document</span>.body.fisrtChild);</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><p><code>&lt;script&gt;</code>中defer和asyc区别和加载顺序</p>\n<ul>\n<li>asyc: <code>异步脚本</code>虽然立即下载脚本，不应该方案页面中其他操作，比如下载其他资源或等待加载其他脚本。只对外部脚本有效。不能保证按照指定的先后顺序执行，建议异步脚本不要在加载期间修改 DOM。</li>\n<li>defer: <code>延迟脚本</code>可以延迟到文档完全被解析和显示之后再执行。只针对外部脚本有效。在现实当中，延迟脚本不一定按照顺序执行，不一定会在 DOMContentLoaded 事件触发前执行，因此最好只包含一个延迟脚本</li>\n</ul>\n</li>\n<li><p>闭包：指有权访问另一个函数作用域中的变量和函数。</p>\n</li>\n<li><p>作用域：当代码在一个环境执行时，会创建变量对象的一个作用域。<br>理解：类似 Java 的成员变量</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> color = <span class=\"string\">\"blue\"</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">changeColor</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> anotherColor = <span class=\"string\">\"red\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">swapColor</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> tempColor = anotherColor;</span><br><span class=\"line\">    anotherColor = color;</span><br><span class=\"line\">    color = tempColor;</span><br><span class=\"line\">    <span class=\"comment\">// 这里可以访问 color, anotherColor 和 tempColor</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 这里可以访问 color, anotherColor</span></span><br><span class=\"line\">  swapColor();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 这里只能访问 color</span></span><br><span class=\"line\">changeColor();</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>前端问题总结整理，持续更新和学习，找到想做的就加油做个行动派吧！</p>","more":"<blockquote>\n<p>千万不要为了当前不好而跳槽，一定是要因为将来会更好而跳槽！</p>\n</blockquote>\n<h1 id=\"HTML\"><a href=\"#HTML\" class=\"headerlink\" title=\"HTML\"></a>HTML</h1><ul>\n<li><p>盒子模型<br>margin - border - padding - content - padding - border - margin<br>上下两个元素之间会有margin合并问题</p>\n</li>\n<li><p>块级元素和行内元素区别<br><a href=\"http://blog.csdn.net/chen_zw/article/details/8713205\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chen_zw/article/details/8713205</a><br><a href=\"http://segmentfault.com/a/1190000000654770\" target=\"_blank\" rel=\"noopener\">http://segmentfault.com/a/1190000000654770</a></p>\n</li>\n</ul>\n<h1 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a>CSS</h1><ul>\n<li><p>实现一个叉号有几种实现方式<br>1.切图 2.先用一个span画一个长方形，圆角，然后使用transform倾斜 3.CSS3中使用Webfont 4.伪类</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">TODO</span> 代码实现</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>CSS常用选择器<br>ID、类、伪类、父子选择器等等</p>\n</li>\n</ul>\n<h1 id=\"Javascript\"><a href=\"#Javascript\" class=\"headerlink\" title=\"Javascript\"></a>Javascript</h1><ul>\n<li>原型链 prototype<br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain\" target=\"_blank\" rel=\"noopener\">MDN</a></li>\n</ul>\n<p>实现的本质是重新原型对象。</p>\n<ul>\n<li><p>原生ajax写法<br>XMLHttpRequest, XMLHttpResponse</p>\n</li>\n<li><p>事件模型和事件传播机制问题<br>浏览器中事件可以分为三种：鼠标事件；键盘事件；HTML事件；<br>捕获和冒泡的顺序在不同浏览器中不同，IE下事件流采用的是冒泡，基于DOM标准兼容浏览器通常采用先捕获后冒泡方式。</p>\n</li>\n</ul>\n<p><code>addEventListener() &amp; removeEventListener()</code><br>所有 DOM 节点都包含这两个方法，都接受三个参数：要处理的事件名，作为事件处理程序的函数，一个布尔值。最后这个参数布尔值，<code>true</code>表示在捕获时调用事件处理函数，<code>false</code>表示在冒泡时调用时间处理函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> btn = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"myBtn\"</span>);</span><br><span class=\"line\">btn.addEventListener(<span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  alert(<span class=\"string\">\"click\"</span>);</span><br><span class=\"line\">&#125;, flase);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>跨域 JSONP 实现原理<br>原理：回调函数<br>JSONP 由两部分组成：回调函数和数据。</li>\n</ul>\n<p>For Example:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleResponse</span>(<span class=\"params\">response</span>) </span>&#123;</span><br><span class=\"line\">  alert(<span class=\"string\">\"You're at IP \"</span> + response.ip + <span class=\"string\">\", which is in \"</span> + response.city);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> script = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"script\"</span>);</span><br><span class=\"line\">script.src = <span class=\"string\">\"http://freegeoip.net/json/?callback=handleResponse\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.insertBefore(script, <span class=\"built_in\">document</span>.body.fisrtChild);</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><p><code>&lt;script&gt;</code>中defer和asyc区别和加载顺序</p>\n<ul>\n<li>asyc: <code>异步脚本</code>虽然立即下载脚本，不应该方案页面中其他操作，比如下载其他资源或等待加载其他脚本。只对外部脚本有效。不能保证按照指定的先后顺序执行，建议异步脚本不要在加载期间修改 DOM。</li>\n<li>defer: <code>延迟脚本</code>可以延迟到文档完全被解析和显示之后再执行。只针对外部脚本有效。在现实当中，延迟脚本不一定按照顺序执行，不一定会在 DOMContentLoaded 事件触发前执行，因此最好只包含一个延迟脚本</li>\n</ul>\n</li>\n<li><p>闭包：指有权访问另一个函数作用域中的变量和函数。</p>\n</li>\n<li><p>作用域：当代码在一个环境执行时，会创建变量对象的一个作用域。<br>理解：类似 Java 的成员变量</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> color = <span class=\"string\">\"blue\"</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">changeColor</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> anotherColor = <span class=\"string\">\"red\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">swapColor</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> tempColor = anotherColor;</span><br><span class=\"line\">    anotherColor = color;</span><br><span class=\"line\">    color = tempColor;</span><br><span class=\"line\">    <span class=\"comment\">// 这里可以访问 color, anotherColor 和 tempColor</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 这里可以访问 color, anotherColor</span></span><br><span class=\"line\">  swapColor();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 这里只能访问 color</span></span><br><span class=\"line\">changeColor();</span><br></pre></td></tr></table></figure>\n</li>\n</ul>"},{"title":"Try My Best","date":"2015-07-19T08:47:21.000Z","_content":"\n> Be who you are and say what you feel, because those who mind don't matter and those who matter don't mind.\n> \n> -- Bernard Baruch\n\n<!-- more -->\n\n## 机遇 Opportunity\n\n这里先要对我拒绝过公司道一声抱歉，也对原公司对我有知遇之恩的前 BOSS 说一声“感谢对我的认可，感谢能够再次给我机会，只可惜‘回归’现在不是我想做的事”。\n\n很幸运的是，高中同学的前同事所在公司有一个岗位空缺，通过多方面的了解和考虑，这是一次非常好的机会。\n\n周四我会参加复试，这家公司之前只在关注移动互联新闻中无意中扫过，由于一直没有在工作中投入到移动互联中，所以也从来没有认真关注过，有一些因缘的是，一起在北京奋斗的同学无意中提醒，如果想转职前端相关。\n\n## 准备 Prepare\n\n整个7月，我都在为寻找新机会而准备（中间抽空和女朋友一起去了一趟厦门短期旅行），早在一年前来到 JD 之前就有朋友跟我说过，要想好为什么跳槽，对于自己而言，为什么要寻找新机会？\n\n- 是否是自己感兴趣想做的？或者说能不能在这份新工作找到乐趣？想清楚要做什么？\n- 在这份新工作有多大的上升空间？\n- 能否满足薪资收入预期？\n\n为了在这次面试，我特别针对这家工作做了很多准备工作，因为电话面之后，有一个 on-site 面试，需要提前在线限时完成三个算法题，于是翻出以前的书恶补了一些算法和数据结构相关的知识，虽然如此还是没有在答题当天表现出让自己满意的水平，还好把题目记下来自己私下里再做一次。\n\n因为是外企，工作语言是英语，因此专门准备口语！``Practice! Practice! Practice!`` \n\n在 Glassdoor, Quora 等等网站查询关于这个公司的信息以及面试经验，在linkedin、V2EX、知乎、微博SNS上搜索他们员工和相关信息。\n\n\n## 尽力 Try\n\n最近一周我已经在充分调整自己，包括公司目前工作进度控制，近期的作息调整，希望能够有一个非常好的状态来参加复试，临阵磨枪一直不是我中意做事的方式，虽然做了很多准备，但更多的还是需要平时的积累、经验以及临场发挥，希望能够有个好结果！如果面试通过，一定要仔细整理一份面经。\n\n\n> 最好的休息，就是重新燃起生活的激情！\n\n---\n\n## 其他 Others\n\n目前公司在做一件事，有一个经验分享：\n网站在支持 http 和 https 双协议，页面开发过程中有一处 tips\n\n``如果静态文件没有单独放在其他服务器上，这种问题可以直接使用相对路径解决。``\n\n```html\n<img src=\"//url/abc/bcd\">\n<script src=\"//url/mnb/xxx.js\" type=\"text/javascript\" charset=\"utf-8\" async defer></script>\n```\n在链接中不必写 ``https://`` 或 ``http://`` Javascript 中也可以通过 document 来获取当前页面的协议``document.location.protocol``\n\n如果一定要在页面写绝对路径包括协议头可以这样写\n```javascript\nvar hp = (\"https:\" == document.location.protocol ? \"https://\" : \"http:\");```\n\n\n访问速度优化策略几个关键步骤：\n请求优化、压缩合并、无状态域名（减少cookie传输）、上传静态服务器如 CDN（推模式响应慢，主动拉模型更新响应快）\n\n---\n\n2015下半年读书单（暂定）\n\n技术方向\n- Javascript 高级程序设计\n- 你不知道的 Javascript（上卷）\n- CSS 权威指南\n- Javascript 设计模式\n\n非技术方向\n- 从0到1\n- 羊毛战记\n- 天才在左，疯子在右\n- 断舍离\n\n\n","source":"_posts/2015-07-19-Try-My-Best.md","raw":"title: Try My Best\ndate: 2015-07-19 16:47:21\ncategory : blog\ntags: [life]\n---\n\n> Be who you are and say what you feel, because those who mind don't matter and those who matter don't mind.\n> \n> -- Bernard Baruch\n\n<!-- more -->\n\n## 机遇 Opportunity\n\n这里先要对我拒绝过公司道一声抱歉，也对原公司对我有知遇之恩的前 BOSS 说一声“感谢对我的认可，感谢能够再次给我机会，只可惜‘回归’现在不是我想做的事”。\n\n很幸运的是，高中同学的前同事所在公司有一个岗位空缺，通过多方面的了解和考虑，这是一次非常好的机会。\n\n周四我会参加复试，这家公司之前只在关注移动互联新闻中无意中扫过，由于一直没有在工作中投入到移动互联中，所以也从来没有认真关注过，有一些因缘的是，一起在北京奋斗的同学无意中提醒，如果想转职前端相关。\n\n## 准备 Prepare\n\n整个7月，我都在为寻找新机会而准备（中间抽空和女朋友一起去了一趟厦门短期旅行），早在一年前来到 JD 之前就有朋友跟我说过，要想好为什么跳槽，对于自己而言，为什么要寻找新机会？\n\n- 是否是自己感兴趣想做的？或者说能不能在这份新工作找到乐趣？想清楚要做什么？\n- 在这份新工作有多大的上升空间？\n- 能否满足薪资收入预期？\n\n为了在这次面试，我特别针对这家工作做了很多准备工作，因为电话面之后，有一个 on-site 面试，需要提前在线限时完成三个算法题，于是翻出以前的书恶补了一些算法和数据结构相关的知识，虽然如此还是没有在答题当天表现出让自己满意的水平，还好把题目记下来自己私下里再做一次。\n\n因为是外企，工作语言是英语，因此专门准备口语！``Practice! Practice! Practice!`` \n\n在 Glassdoor, Quora 等等网站查询关于这个公司的信息以及面试经验，在linkedin、V2EX、知乎、微博SNS上搜索他们员工和相关信息。\n\n\n## 尽力 Try\n\n最近一周我已经在充分调整自己，包括公司目前工作进度控制，近期的作息调整，希望能够有一个非常好的状态来参加复试，临阵磨枪一直不是我中意做事的方式，虽然做了很多准备，但更多的还是需要平时的积累、经验以及临场发挥，希望能够有个好结果！如果面试通过，一定要仔细整理一份面经。\n\n\n> 最好的休息，就是重新燃起生活的激情！\n\n---\n\n## 其他 Others\n\n目前公司在做一件事，有一个经验分享：\n网站在支持 http 和 https 双协议，页面开发过程中有一处 tips\n\n``如果静态文件没有单独放在其他服务器上，这种问题可以直接使用相对路径解决。``\n\n```html\n<img src=\"//url/abc/bcd\">\n<script src=\"//url/mnb/xxx.js\" type=\"text/javascript\" charset=\"utf-8\" async defer></script>\n```\n在链接中不必写 ``https://`` 或 ``http://`` Javascript 中也可以通过 document 来获取当前页面的协议``document.location.protocol``\n\n如果一定要在页面写绝对路径包括协议头可以这样写\n```javascript\nvar hp = (\"https:\" == document.location.protocol ? \"https://\" : \"http:\");```\n\n\n访问速度优化策略几个关键步骤：\n请求优化、压缩合并、无状态域名（减少cookie传输）、上传静态服务器如 CDN（推模式响应慢，主动拉模型更新响应快）\n\n---\n\n2015下半年读书单（暂定）\n\n技术方向\n- Javascript 高级程序设计\n- 你不知道的 Javascript（上卷）\n- CSS 权威指南\n- Javascript 设计模式\n\n非技术方向\n- 从0到1\n- 羊毛战记\n- 天才在左，疯子在右\n- 断舍离\n\n\n","slug":"Try-My-Best","published":1,"updated":"2017-11-04T11:09:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc31n1fx001xgey5egw9iual","content":"<blockquote>\n<p>Be who you are and say what you feel, because those who mind don’t matter and those who matter don’t mind.</p>\n<p>– Bernard Baruch</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"机遇-Opportunity\"><a href=\"#机遇-Opportunity\" class=\"headerlink\" title=\"机遇 Opportunity\"></a>机遇 Opportunity</h2><p>这里先要对我拒绝过公司道一声抱歉，也对原公司对我有知遇之恩的前 BOSS 说一声“感谢对我的认可，感谢能够再次给我机会，只可惜‘回归’现在不是我想做的事”。</p>\n<p>很幸运的是，高中同学的前同事所在公司有一个岗位空缺，通过多方面的了解和考虑，这是一次非常好的机会。</p>\n<p>周四我会参加复试，这家公司之前只在关注移动互联新闻中无意中扫过，由于一直没有在工作中投入到移动互联中，所以也从来没有认真关注过，有一些因缘的是，一起在北京奋斗的同学无意中提醒，如果想转职前端相关。</p>\n<h2 id=\"准备-Prepare\"><a href=\"#准备-Prepare\" class=\"headerlink\" title=\"准备 Prepare\"></a>准备 Prepare</h2><p>整个7月，我都在为寻找新机会而准备（中间抽空和女朋友一起去了一趟厦门短期旅行），早在一年前来到 JD 之前就有朋友跟我说过，要想好为什么跳槽，对于自己而言，为什么要寻找新机会？</p>\n<ul>\n<li>是否是自己感兴趣想做的？或者说能不能在这份新工作找到乐趣？想清楚要做什么？</li>\n<li>在这份新工作有多大的上升空间？</li>\n<li>能否满足薪资收入预期？</li>\n</ul>\n<p>为了在这次面试，我特别针对这家工作做了很多准备工作，因为电话面之后，有一个 on-site 面试，需要提前在线限时完成三个算法题，于是翻出以前的书恶补了一些算法和数据结构相关的知识，虽然如此还是没有在答题当天表现出让自己满意的水平，还好把题目记下来自己私下里再做一次。</p>\n<p>因为是外企，工作语言是英语，因此专门准备口语！<code>Practice! Practice! Practice!</code> </p>\n<p>在 Glassdoor, Quora 等等网站查询关于这个公司的信息以及面试经验，在linkedin、V2EX、知乎、微博SNS上搜索他们员工和相关信息。</p>\n<h2 id=\"尽力-Try\"><a href=\"#尽力-Try\" class=\"headerlink\" title=\"尽力 Try\"></a>尽力 Try</h2><p>最近一周我已经在充分调整自己，包括公司目前工作进度控制，近期的作息调整，希望能够有一个非常好的状态来参加复试，临阵磨枪一直不是我中意做事的方式，虽然做了很多准备，但更多的还是需要平时的积累、经验以及临场发挥，希望能够有个好结果！如果面试通过，一定要仔细整理一份面经。</p>\n<blockquote>\n<p>最好的休息，就是重新燃起生活的激情！</p>\n</blockquote>\n<hr>\n<h2 id=\"其他-Others\"><a href=\"#其他-Others\" class=\"headerlink\" title=\"其他 Others\"></a>其他 Others</h2><p>目前公司在做一件事，有一个经验分享：<br>网站在支持 http 和 https 双协议，页面开发过程中有一处 tips</p>\n<p><code>如果静态文件没有单独放在其他服务器上，这种问题可以直接使用相对路径解决。</code></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"//url/abc/bcd\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"//url/mnb/xxx.js\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"utf-8\"</span> <span class=\"attr\">async</span> <span class=\"attr\">defer</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>在链接中不必写 <code>https://</code> 或 <code>http://</code> Javascript 中也可以通过 document 来获取当前页面的协议<code>document.location.protocol</code></p>\n<p>如果一定要在页面写绝对路径包括协议头可以这样写<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> hp = (<span class=\"string\">\"https:\"</span> == <span class=\"built_in\">document</span>.location.protocol ? <span class=\"string\">\"https://\"</span> : <span class=\"string\">\"http:\"</span>);</span><br></pre></td></tr></table></figure></p>\n<p>访问速度优化策略几个关键步骤：<br>请求优化、压缩合并、无状态域名（减少cookie传输）、上传静态服务器如 CDN（推模式响应慢，主动拉模型更新响应快）</p>\n<hr>\n<p>2015下半年读书单（暂定）</p>\n<p>技术方向</p>\n<ul>\n<li>Javascript 高级程序设计</li>\n<li>你不知道的 Javascript（上卷）</li>\n<li>CSS 权威指南</li>\n<li>Javascript 设计模式</li>\n</ul>\n<p>非技术方向</p>\n<ul>\n<li>从0到1</li>\n<li>羊毛战记</li>\n<li>天才在左，疯子在右</li>\n<li>断舍离</li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Be who you are and say what you feel, because those who mind don’t matter and those who matter don’t mind.</p>\n<p>– Bernard Baruch</p>\n</blockquote>","more":"<h2 id=\"机遇-Opportunity\"><a href=\"#机遇-Opportunity\" class=\"headerlink\" title=\"机遇 Opportunity\"></a>机遇 Opportunity</h2><p>这里先要对我拒绝过公司道一声抱歉，也对原公司对我有知遇之恩的前 BOSS 说一声“感谢对我的认可，感谢能够再次给我机会，只可惜‘回归’现在不是我想做的事”。</p>\n<p>很幸运的是，高中同学的前同事所在公司有一个岗位空缺，通过多方面的了解和考虑，这是一次非常好的机会。</p>\n<p>周四我会参加复试，这家公司之前只在关注移动互联新闻中无意中扫过，由于一直没有在工作中投入到移动互联中，所以也从来没有认真关注过，有一些因缘的是，一起在北京奋斗的同学无意中提醒，如果想转职前端相关。</p>\n<h2 id=\"准备-Prepare\"><a href=\"#准备-Prepare\" class=\"headerlink\" title=\"准备 Prepare\"></a>准备 Prepare</h2><p>整个7月，我都在为寻找新机会而准备（中间抽空和女朋友一起去了一趟厦门短期旅行），早在一年前来到 JD 之前就有朋友跟我说过，要想好为什么跳槽，对于自己而言，为什么要寻找新机会？</p>\n<ul>\n<li>是否是自己感兴趣想做的？或者说能不能在这份新工作找到乐趣？想清楚要做什么？</li>\n<li>在这份新工作有多大的上升空间？</li>\n<li>能否满足薪资收入预期？</li>\n</ul>\n<p>为了在这次面试，我特别针对这家工作做了很多准备工作，因为电话面之后，有一个 on-site 面试，需要提前在线限时完成三个算法题，于是翻出以前的书恶补了一些算法和数据结构相关的知识，虽然如此还是没有在答题当天表现出让自己满意的水平，还好把题目记下来自己私下里再做一次。</p>\n<p>因为是外企，工作语言是英语，因此专门准备口语！<code>Practice! Practice! Practice!</code> </p>\n<p>在 Glassdoor, Quora 等等网站查询关于这个公司的信息以及面试经验，在linkedin、V2EX、知乎、微博SNS上搜索他们员工和相关信息。</p>\n<h2 id=\"尽力-Try\"><a href=\"#尽力-Try\" class=\"headerlink\" title=\"尽力 Try\"></a>尽力 Try</h2><p>最近一周我已经在充分调整自己，包括公司目前工作进度控制，近期的作息调整，希望能够有一个非常好的状态来参加复试，临阵磨枪一直不是我中意做事的方式，虽然做了很多准备，但更多的还是需要平时的积累、经验以及临场发挥，希望能够有个好结果！如果面试通过，一定要仔细整理一份面经。</p>\n<blockquote>\n<p>最好的休息，就是重新燃起生活的激情！</p>\n</blockquote>\n<hr>\n<h2 id=\"其他-Others\"><a href=\"#其他-Others\" class=\"headerlink\" title=\"其他 Others\"></a>其他 Others</h2><p>目前公司在做一件事，有一个经验分享：<br>网站在支持 http 和 https 双协议，页面开发过程中有一处 tips</p>\n<p><code>如果静态文件没有单独放在其他服务器上，这种问题可以直接使用相对路径解决。</code></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"//url/abc/bcd\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"//url/mnb/xxx.js\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"utf-8\"</span> <span class=\"attr\">async</span> <span class=\"attr\">defer</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>在链接中不必写 <code>https://</code> 或 <code>http://</code> Javascript 中也可以通过 document 来获取当前页面的协议<code>document.location.protocol</code></p>\n<p>如果一定要在页面写绝对路径包括协议头可以这样写<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> hp = (<span class=\"string\">\"https:\"</span> == <span class=\"built_in\">document</span>.location.protocol ? <span class=\"string\">\"https://\"</span> : <span class=\"string\">\"http:\"</span>);</span><br></pre></td></tr></table></figure></p>\n<p>访问速度优化策略几个关键步骤：<br>请求优化、压缩合并、无状态域名（减少cookie传输）、上传静态服务器如 CDN（推模式响应慢，主动拉模型更新响应快）</p>\n<hr>\n<p>2015下半年读书单（暂定）</p>\n<p>技术方向</p>\n<ul>\n<li>Javascript 高级程序设计</li>\n<li>你不知道的 Javascript（上卷）</li>\n<li>CSS 权威指南</li>\n<li>Javascript 设计模式</li>\n</ul>\n<p>非技术方向</p>\n<ul>\n<li>从0到1</li>\n<li>羊毛战记</li>\n<li>天才在左，疯子在右</li>\n<li>断舍离</li>\n</ul>"},{"title":"July And August","date":"2015-07-26T07:02:20.000Z","_content":"\n> 糟糕的七月，幸运的八月\n\n<!-- more -->\n\n# 七下八上","source":"_posts/2015-07-26-Jul-And-Aug.md","raw":"title: July And August\ndate: 2015-07-26 15:02:20\ntags: [life]\n---\n\n> 糟糕的七月，幸运的八月\n\n<!-- more -->\n\n# 七下八上","slug":"Jul-And-Aug","published":1,"updated":"2017-11-04T11:09:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc31n1fz0020gey5ngd1bxi3","content":"<blockquote>\n<p>糟糕的七月，幸运的八月</p>\n</blockquote>\n<a id=\"more\"></a>\n<h1 id=\"七下八上\"><a href=\"#七下八上\" class=\"headerlink\" title=\"七下八上\"></a>七下八上</h1>","site":{"data":{}},"excerpt":"<blockquote>\n<p>糟糕的七月，幸运的八月</p>\n</blockquote>","more":"<h1 id=\"七下八上\"><a href=\"#七下八上\" class=\"headerlink\" title=\"七下八上\"></a>七下八上</h1>"},{"title":"Notes Of 360 Front-End Lesson","date":"2015-11-22T15:32:19.000Z","_content":"\n360前端训练营笔记\n<!-- more -->\n\n# 360前端训练营课堂笔记 － 奇舞团与Facebook畅聊大前端\n\n## HTTP/2 深入浅出\n\n* 屈光宇 Ququ老师 [JerryQu 的小站](https://imququ.com)\n\n### Before HTTP/2\n\n应用层协议，基于TCP\nHTTP 0.9 没有请求头，GET\nHTTP 1.0 增加请求／响应头，可以响应media，content-type，refere来源\nHTTP 1.1 支持持久连接，keep-alive，支持传输编码，content-length，请求范围range（断点续传），cache-control,expires\nSPDY协议截止2015\n\n统计：页面大小和连接数，同一个页面多域名\nTCP一个连接对应一个请求\nkeep-alive、管道pipelining（合并请求）、域名散列（多域名增加并发连接数）、协议开销、合并请求（改写Ajax，雪碧图、cssjs合并、cssjs内联、图片和音频内联base64、阻塞渲染，样式内联（多用于移动端，感知缓存）\n\ninput标签type＝text是默认值\nH2O，can I use、cleartext协商，HTTPS，mozilla免费证书，全球已经开通HTTPS网站占63%\n\nchrome在非HTTPS禁用关于设备使用的API，ALPN\nHTTP／2-enabled，net-internals/#http2、Wireshark\n优化，TLS，非对称加密，证书减少层级，ECC证书（很小，但是兼容性问题，vista才开始支持，移动端可以考虑）\nHSTS，强制HTTPS、TLS安全清单SSL\n\n### HTTP/2\n\n* 优化\n\n优化：减少DNS查询，减少域名、启用预读，减少重定向，使用CDN，压缩（PNGout，pngcrush）、HTTP缓存\n不需要：域名散列，资源合并，资源内联\n\n* 最佳实践\n\n对HTTP/2优化的域名散列，多域名指向同一IP\n感知缓存资源内联或者通过 server－push，cookie 标记内联过资源 server-push\n基于node的node-http2\n\nGoogle QUIC协议，基于UDP协议\n\n\n## Why React Matters?\n\n* 為什麼 React 牛？\n* Facebook 黄士旗\n\n+ Predictable/Immutable\n+ React Native For iOS & Android\n+ ImmutableJS\n\n## ES6/ES7 Node Project, ThinkJS\n\n* 如何使用ES6/ES7开发NodeJS项目\n* 李成银 ThinkJS 作者 @360齐舞团\n\n+ callback、promise，async functions\n+ babel javascript compile\n+ 更多特性，class，Arrows，enhanced object literals，template\n+ 性能问题，class，generators\n+ 自动更新，fs.watch（重启node服务），chokidar，nodemonitor；问题，无法保存临时数据\n+ 解决方案，热更新，依赖文件更新\n+ require.cache，解决依赖和缓存，重写require方法\n+ ThinkJS解决方案[ThinkJS](https://www.thinkjs.org)","source":"_posts/2015-11-22-Notes-Of-360FE-Lesson.md","raw":"title: Notes Of 360 Front-End Lesson\ncategory : Note\ndate: 2015-11-22 23:32:19\ntags: [Javascript, ReractJS, NodeJS, Front-End]\n---\n\n360前端训练营笔记\n<!-- more -->\n\n# 360前端训练营课堂笔记 － 奇舞团与Facebook畅聊大前端\n\n## HTTP/2 深入浅出\n\n* 屈光宇 Ququ老师 [JerryQu 的小站](https://imququ.com)\n\n### Before HTTP/2\n\n应用层协议，基于TCP\nHTTP 0.9 没有请求头，GET\nHTTP 1.0 增加请求／响应头，可以响应media，content-type，refere来源\nHTTP 1.1 支持持久连接，keep-alive，支持传输编码，content-length，请求范围range（断点续传），cache-control,expires\nSPDY协议截止2015\n\n统计：页面大小和连接数，同一个页面多域名\nTCP一个连接对应一个请求\nkeep-alive、管道pipelining（合并请求）、域名散列（多域名增加并发连接数）、协议开销、合并请求（改写Ajax，雪碧图、cssjs合并、cssjs内联、图片和音频内联base64、阻塞渲染，样式内联（多用于移动端，感知缓存）\n\ninput标签type＝text是默认值\nH2O，can I use、cleartext协商，HTTPS，mozilla免费证书，全球已经开通HTTPS网站占63%\n\nchrome在非HTTPS禁用关于设备使用的API，ALPN\nHTTP／2-enabled，net-internals/#http2、Wireshark\n优化，TLS，非对称加密，证书减少层级，ECC证书（很小，但是兼容性问题，vista才开始支持，移动端可以考虑）\nHSTS，强制HTTPS、TLS安全清单SSL\n\n### HTTP/2\n\n* 优化\n\n优化：减少DNS查询，减少域名、启用预读，减少重定向，使用CDN，压缩（PNGout，pngcrush）、HTTP缓存\n不需要：域名散列，资源合并，资源内联\n\n* 最佳实践\n\n对HTTP/2优化的域名散列，多域名指向同一IP\n感知缓存资源内联或者通过 server－push，cookie 标记内联过资源 server-push\n基于node的node-http2\n\nGoogle QUIC协议，基于UDP协议\n\n\n## Why React Matters?\n\n* 為什麼 React 牛？\n* Facebook 黄士旗\n\n+ Predictable/Immutable\n+ React Native For iOS & Android\n+ ImmutableJS\n\n## ES6/ES7 Node Project, ThinkJS\n\n* 如何使用ES6/ES7开发NodeJS项目\n* 李成银 ThinkJS 作者 @360齐舞团\n\n+ callback、promise，async functions\n+ babel javascript compile\n+ 更多特性，class，Arrows，enhanced object literals，template\n+ 性能问题，class，generators\n+ 自动更新，fs.watch（重启node服务），chokidar，nodemonitor；问题，无法保存临时数据\n+ 解决方案，热更新，依赖文件更新\n+ require.cache，解决依赖和缓存，重写require方法\n+ ThinkJS解决方案[ThinkJS](https://www.thinkjs.org)","slug":"Notes-Of-360FE-Lesson","published":1,"updated":"2017-11-04T11:09:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc31n1g00021gey54kvcej04","content":"<p>360前端训练营笔记<br><a id=\"more\"></a></p>\n<h1 id=\"360前端训练营课堂笔记-－-奇舞团与Facebook畅聊大前端\"><a href=\"#360前端训练营课堂笔记-－-奇舞团与Facebook畅聊大前端\" class=\"headerlink\" title=\"360前端训练营课堂笔记 － 奇舞团与Facebook畅聊大前端\"></a>360前端训练营课堂笔记 － 奇舞团与Facebook畅聊大前端</h1><h2 id=\"HTTP-2-深入浅出\"><a href=\"#HTTP-2-深入浅出\" class=\"headerlink\" title=\"HTTP/2 深入浅出\"></a>HTTP/2 深入浅出</h2><ul>\n<li>屈光宇 Ququ老师 <a href=\"https://imququ.com\" target=\"_blank\" rel=\"noopener\">JerryQu 的小站</a></li>\n</ul>\n<h3 id=\"Before-HTTP-2\"><a href=\"#Before-HTTP-2\" class=\"headerlink\" title=\"Before HTTP/2\"></a>Before HTTP/2</h3><p>应用层协议，基于TCP<br>HTTP 0.9 没有请求头，GET<br>HTTP 1.0 增加请求／响应头，可以响应media，content-type，refere来源<br>HTTP 1.1 支持持久连接，keep-alive，支持传输编码，content-length，请求范围range（断点续传），cache-control,expires<br>SPDY协议截止2015</p>\n<p>统计：页面大小和连接数，同一个页面多域名<br>TCP一个连接对应一个请求<br>keep-alive、管道pipelining（合并请求）、域名散列（多域名增加并发连接数）、协议开销、合并请求（改写Ajax，雪碧图、cssjs合并、cssjs内联、图片和音频内联base64、阻塞渲染，样式内联（多用于移动端，感知缓存）</p>\n<p>input标签type＝text是默认值<br>H2O，can I use、cleartext协商，HTTPS，mozilla免费证书，全球已经开通HTTPS网站占63%</p>\n<p>chrome在非HTTPS禁用关于设备使用的API，ALPN<br>HTTP／2-enabled，net-internals/#http2、Wireshark<br>优化，TLS，非对称加密，证书减少层级，ECC证书（很小，但是兼容性问题，vista才开始支持，移动端可以考虑）<br>HSTS，强制HTTPS、TLS安全清单SSL</p>\n<h3 id=\"HTTP-2\"><a href=\"#HTTP-2\" class=\"headerlink\" title=\"HTTP/2\"></a>HTTP/2</h3><ul>\n<li>优化</li>\n</ul>\n<p>优化：减少DNS查询，减少域名、启用预读，减少重定向，使用CDN，压缩（PNGout，pngcrush）、HTTP缓存<br>不需要：域名散列，资源合并，资源内联</p>\n<ul>\n<li>最佳实践</li>\n</ul>\n<p>对HTTP/2优化的域名散列，多域名指向同一IP<br>感知缓存资源内联或者通过 server－push，cookie 标记内联过资源 server-push<br>基于node的node-http2</p>\n<p>Google QUIC协议，基于UDP协议</p>\n<h2 id=\"Why-React-Matters\"><a href=\"#Why-React-Matters\" class=\"headerlink\" title=\"Why React Matters?\"></a>Why React Matters?</h2><ul>\n<li>為什麼 React 牛？</li>\n<li>Facebook 黄士旗</li>\n</ul>\n<ul>\n<li>Predictable/Immutable</li>\n<li>React Native For iOS &amp; Android</li>\n<li>ImmutableJS</li>\n</ul>\n<h2 id=\"ES6-ES7-Node-Project-ThinkJS\"><a href=\"#ES6-ES7-Node-Project-ThinkJS\" class=\"headerlink\" title=\"ES6/ES7 Node Project, ThinkJS\"></a>ES6/ES7 Node Project, ThinkJS</h2><ul>\n<li>如何使用ES6/ES7开发NodeJS项目</li>\n<li>李成银 ThinkJS 作者 @360齐舞团</li>\n</ul>\n<ul>\n<li>callback、promise，async functions</li>\n<li>babel javascript compile</li>\n<li>更多特性，class，Arrows，enhanced object literals，template</li>\n<li>性能问题，class，generators</li>\n<li>自动更新，fs.watch（重启node服务），chokidar，nodemonitor；问题，无法保存临时数据</li>\n<li>解决方案，热更新，依赖文件更新</li>\n<li>require.cache，解决依赖和缓存，重写require方法</li>\n<li>ThinkJS解决方案<a href=\"https://www.thinkjs.org\" target=\"_blank\" rel=\"noopener\">ThinkJS</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>360前端训练营笔记<br>","more":"</p>\n<h1 id=\"360前端训练营课堂笔记-－-奇舞团与Facebook畅聊大前端\"><a href=\"#360前端训练营课堂笔记-－-奇舞团与Facebook畅聊大前端\" class=\"headerlink\" title=\"360前端训练营课堂笔记 － 奇舞团与Facebook畅聊大前端\"></a>360前端训练营课堂笔记 － 奇舞团与Facebook畅聊大前端</h1><h2 id=\"HTTP-2-深入浅出\"><a href=\"#HTTP-2-深入浅出\" class=\"headerlink\" title=\"HTTP/2 深入浅出\"></a>HTTP/2 深入浅出</h2><ul>\n<li>屈光宇 Ququ老师 <a href=\"https://imququ.com\" target=\"_blank\" rel=\"noopener\">JerryQu 的小站</a></li>\n</ul>\n<h3 id=\"Before-HTTP-2\"><a href=\"#Before-HTTP-2\" class=\"headerlink\" title=\"Before HTTP/2\"></a>Before HTTP/2</h3><p>应用层协议，基于TCP<br>HTTP 0.9 没有请求头，GET<br>HTTP 1.0 增加请求／响应头，可以响应media，content-type，refere来源<br>HTTP 1.1 支持持久连接，keep-alive，支持传输编码，content-length，请求范围range（断点续传），cache-control,expires<br>SPDY协议截止2015</p>\n<p>统计：页面大小和连接数，同一个页面多域名<br>TCP一个连接对应一个请求<br>keep-alive、管道pipelining（合并请求）、域名散列（多域名增加并发连接数）、协议开销、合并请求（改写Ajax，雪碧图、cssjs合并、cssjs内联、图片和音频内联base64、阻塞渲染，样式内联（多用于移动端，感知缓存）</p>\n<p>input标签type＝text是默认值<br>H2O，can I use、cleartext协商，HTTPS，mozilla免费证书，全球已经开通HTTPS网站占63%</p>\n<p>chrome在非HTTPS禁用关于设备使用的API，ALPN<br>HTTP／2-enabled，net-internals/#http2、Wireshark<br>优化，TLS，非对称加密，证书减少层级，ECC证书（很小，但是兼容性问题，vista才开始支持，移动端可以考虑）<br>HSTS，强制HTTPS、TLS安全清单SSL</p>\n<h3 id=\"HTTP-2\"><a href=\"#HTTP-2\" class=\"headerlink\" title=\"HTTP/2\"></a>HTTP/2</h3><ul>\n<li>优化</li>\n</ul>\n<p>优化：减少DNS查询，减少域名、启用预读，减少重定向，使用CDN，压缩（PNGout，pngcrush）、HTTP缓存<br>不需要：域名散列，资源合并，资源内联</p>\n<ul>\n<li>最佳实践</li>\n</ul>\n<p>对HTTP/2优化的域名散列，多域名指向同一IP<br>感知缓存资源内联或者通过 server－push，cookie 标记内联过资源 server-push<br>基于node的node-http2</p>\n<p>Google QUIC协议，基于UDP协议</p>\n<h2 id=\"Why-React-Matters\"><a href=\"#Why-React-Matters\" class=\"headerlink\" title=\"Why React Matters?\"></a>Why React Matters?</h2><ul>\n<li>為什麼 React 牛？</li>\n<li>Facebook 黄士旗</li>\n</ul>\n<ul>\n<li>Predictable/Immutable</li>\n<li>React Native For iOS &amp; Android</li>\n<li>ImmutableJS</li>\n</ul>\n<h2 id=\"ES6-ES7-Node-Project-ThinkJS\"><a href=\"#ES6-ES7-Node-Project-ThinkJS\" class=\"headerlink\" title=\"ES6/ES7 Node Project, ThinkJS\"></a>ES6/ES7 Node Project, ThinkJS</h2><ul>\n<li>如何使用ES6/ES7开发NodeJS项目</li>\n<li>李成银 ThinkJS 作者 @360齐舞团</li>\n</ul>\n<ul>\n<li>callback、promise，async functions</li>\n<li>babel javascript compile</li>\n<li>更多特性，class，Arrows，enhanced object literals，template</li>\n<li>性能问题，class，generators</li>\n<li>自动更新，fs.watch（重启node服务），chokidar，nodemonitor；问题，无法保存临时数据</li>\n<li>解决方案，热更新，依赖文件更新</li>\n<li>require.cache，解决依赖和缓存，重写require方法</li>\n<li>ThinkJS解决方案<a href=\"https://www.thinkjs.org\" target=\"_blank\" rel=\"noopener\">ThinkJS</a></li>\n</ul>"},{"layout":"post","title":"【译】I know how to program, but I don't know what to program","tagline":"","description":"译文计划","date":"2016-05-19T14:10:01.000Z","_content":"\n> 湾区简评：这是很多初学编程的人，尤其是通过大学里的编程课学习写程序的人面临的问题。除了刷编程竞赛题、做课后编程题外，写程序能做什么？文章给的建议我赞同：先尝试去写自己也会用到的自动化的小工具。如果顺序反过来，已经知道要做什么了（比如做网站、做某个具体功能的app、做某个有实际用途的工具），再去学编程，会不会效果更好？\n\n<!-- more -->\n\n## 【译】我知道如何编程，但是我不知道拿来干什么\n\n[原文链接](http://www.devdungeon.com/content/i-know-how-program-i-dont-know-what-program?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=ios)\n\n当我面对刚入门的开发者时总有一个重复的主题。他们已经把他们的时间投入到学习一门或者两门编程语言的基础上，并且他们轻松地完成一些编程练习，但是他们不知道怎么接受他们已经学习的东西。通常来说，就像“我知道如何编程，但是我不知道编写什么程序”。标志性的回答是“完成一些编程挑战”，“给开源项目贡献代码”或者是“做一款游戏”。\n\n完成编程挑战有益于脑力练习，但是它们却在人们学习如何创建一个新程序上的帮助很少。给开源项目贡献代码是一个提高的方式。你可能会学习到一个真实项目是如何架构的，并且在编程语言方面提升你的技巧，但是不会学习到很多的关于一个项目整个生命环的内容。某些项目非常复杂，这可能会对新手来说是非常恐怖的事。编写一款游戏是另一个提高的方式。游戏是有趣的！我以前曾开始用 QBASIC 编写游戏。然而发生了同样的困境。“我想要做一个游戏，但是我不知道做什么游戏”。\n\n教导音乐系学生跟编程一样，我已经意识到在音乐系学生中存在同样的模式。“我知道全部的和弦，并且我弹奏很熟练，但是我不知道怎么样写一首歌曲。”在音乐中，我们确实有一个很好的解答。在学习创作中有一个途径。音乐家通常不仅仅从一开始就写自己的音乐。有些音乐家永远不会向拼凑音乐和花掉一生时间演奏他人音乐的方向发展。在编程的世界，态度有一点不同。\n\n在软件社区有一个规则是“不要重复发明轮子”。当一个成熟稳定的选择存在时，如果你重写一个库通常是不被赞成的。虽然这对于一般人来说是一个好的规则，但新手不应该害怕重复发明轮子。当为了学习或者练习完成时，发明轮子是可以的！它是学习中一个重要的部分。比如，编写你自己版本的 ls，mv，wget 或者 cowsay 命令。如果你想要走游戏路线那可以克隆 Pong，Tetris 或者 Space Invaders 游戏。它们不需要全部相同的特点或者精确复制，但是你可以带着你的目标和空白的计划开始编程，你要把游戏实现出来。\n\n* [pong](https://github.com/greatcodeclub/pong)\n* [blockrain.js](https://github.com/Aerolab/blockrain.js) & [Hextris](https://github.com/Hextris/hextris)\n* [spaceinvaders](https://github.com/dwmkerr/spaceinvaders) & [space-tweet](https://github.com/fat/space-tweet)\n\n![games](http://78renz.com1.z0.glb.clouddn.com/blog-20160519.png?imageslim)\n\n在你写程序之前不要有'必须有个最佳的 idea 才开始动手'这种念头。我见到过在音乐家中有相同的心态。在他们第一次尝试时就努力创造一个高水平，这花费他们全部的精力投入到一首乐曲中。长远的是你将会写出很多很多乐曲，不仅仅是这一首。你完成的第一支乐曲可能不好，你很可能抛弃它。这没什么。在你第一次尝试时，不要试着想要写出最好的章节。你需要学习谱曲的过程。在你写好程序之前你将会编写出糟糕的程序。迈过它，征服它，获取经验你就能开始在需求上自由创作发挥。\n\n我们告诉人们用“Hello , world”做开端。因为这是他们行程的一个点，完成这个以为这征服了一个基础原理。你就理解了如何编译，如何运行，如何调用一个函数并且给它传递参数。编写一份已经存在软件的克隆版本是另外一个大的进步，跟 hello world 同等重要。当你完成它时，你已经克服了很多挑战。你已经发现哪里开始，如何计划，怎么组织，如何处理 bug ，给它一个人为的处理，并且打包最后它就成为一个可用的版本。即使你编写一个简单程序的克隆版本，你也能学习到全部过程。\n\n你可能会好奇如何克隆已经存在的项目，它将帮助你产生一些新想法。比如像音乐，它需要创新。演奏他人的乐曲怎么做才能帮助你谱写自己的乐谱呢？你必须首先理解其他人。你必须去了解他们如何创作的，还有他们使用了什么模式。当你做完这些足够时间你就开始着眼以后，并且你已经有丰富的知识用来总结。你将从不同地方学习到的小部分音节组合在一起，并且重复一些你了解的模式。你可能改进，组合，或者完全打破你学习到的这些模式。就像他们所说的，你需要了解规则目的是用来突破他们。在编程过程中我们也有通用的模式比如 MVC 。这是一个稳定的被接受的编写软件的模式。在音乐中，我们也有通用的模式。比如 [I-V-vi-IV](https://en.wikipedia.org/wiki/I%E2%80%93V%E2%80%93vi%E2%80%93IV_progression)。当然它不是唯一的一个，但它是已知很好的一个模式。\n\n总而言之，这是经验和创新的一个组合。创新是一部分人们经常在编程过程中被忽略的但他非常重要。你曾留意过有多少程序员也同样是作曲家吗？乐曲包含很多技术上分析，架构，模式尽管很多人认为他是一个纯粹的创作行为。编程是经常被看成技术性的动作尽管它多数是创作性的行为。你可以在复制其他项目过程中培养创新性。伴随着你逐渐完成他们，你将会发现你有了自己新的想法去改进程序，抑或是一个新的带有些许个性的特点被添加进去。它将会为新项目启发思路。创新随时会出现，但是你需要先学习如何把它首先谱写成歌曲。\n\n总有一天，你将会发现你将能够为所有事编程。你可以让任务自动化并且处理问题熟练。当你面对将会使你没有时间应对的诸多事情时，你处理起来也会没有问题的。你也将有能力随时解决问题。“哦，这有一个100个Sheet的表格需要被格式化，拆分成文件，转成一个 CSV 文件？马上就解决！”不要耽误时间去尝试做未来最好的事。编写一些你将会使用到的东西。其他项目的点子也会随之而来。\n\n你们中有多少人已经处于你想象的“我不知道写什么程序？”这种的状态？你是怎么解决它的？如果处于这种状态你有什么建议？\n\n[原文链接](http://www.devdungeon.com/content/i-know-how-program-i-dont-know-what-program?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=ios)\n\n湾区日报推荐\n\n> 豆子简评：对自己有一些启发，现在转职专门做前端相关的工作时间不长，从 J2EE SQL  ... 到 HTML CSS Javascript NodeJS ... 。虽然可以达到基本熟悉一门新的编程语言可以花费不长的时间这样一个状态，但是一直没有找到很好的办法在接触到一个新技术或框架时，短时间地拿着这些“新工具”去做事，其中原因很类似于“I Know how to program, but I don't know what to program.”，先造一些自己能用得上的轮子吧，在自己的 Lab 页多更新。","source":"_posts/2016-05-19-WANQU-Program-Beginning.md","raw":"---\nlayout: post\ntitle : 【译】I know how to program, but I don't know what to program\ncategory : 译文计划\ntagline: \"\"\ntags : [翻译, 英语学习]\ndescription : 译文计划\ndate: 2016-05-19 22:10:01\n---\n\n> 湾区简评：这是很多初学编程的人，尤其是通过大学里的编程课学习写程序的人面临的问题。除了刷编程竞赛题、做课后编程题外，写程序能做什么？文章给的建议我赞同：先尝试去写自己也会用到的自动化的小工具。如果顺序反过来，已经知道要做什么了（比如做网站、做某个具体功能的app、做某个有实际用途的工具），再去学编程，会不会效果更好？\n\n<!-- more -->\n\n## 【译】我知道如何编程，但是我不知道拿来干什么\n\n[原文链接](http://www.devdungeon.com/content/i-know-how-program-i-dont-know-what-program?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=ios)\n\n当我面对刚入门的开发者时总有一个重复的主题。他们已经把他们的时间投入到学习一门或者两门编程语言的基础上，并且他们轻松地完成一些编程练习，但是他们不知道怎么接受他们已经学习的东西。通常来说，就像“我知道如何编程，但是我不知道编写什么程序”。标志性的回答是“完成一些编程挑战”，“给开源项目贡献代码”或者是“做一款游戏”。\n\n完成编程挑战有益于脑力练习，但是它们却在人们学习如何创建一个新程序上的帮助很少。给开源项目贡献代码是一个提高的方式。你可能会学习到一个真实项目是如何架构的，并且在编程语言方面提升你的技巧，但是不会学习到很多的关于一个项目整个生命环的内容。某些项目非常复杂，这可能会对新手来说是非常恐怖的事。编写一款游戏是另一个提高的方式。游戏是有趣的！我以前曾开始用 QBASIC 编写游戏。然而发生了同样的困境。“我想要做一个游戏，但是我不知道做什么游戏”。\n\n教导音乐系学生跟编程一样，我已经意识到在音乐系学生中存在同样的模式。“我知道全部的和弦，并且我弹奏很熟练，但是我不知道怎么样写一首歌曲。”在音乐中，我们确实有一个很好的解答。在学习创作中有一个途径。音乐家通常不仅仅从一开始就写自己的音乐。有些音乐家永远不会向拼凑音乐和花掉一生时间演奏他人音乐的方向发展。在编程的世界，态度有一点不同。\n\n在软件社区有一个规则是“不要重复发明轮子”。当一个成熟稳定的选择存在时，如果你重写一个库通常是不被赞成的。虽然这对于一般人来说是一个好的规则，但新手不应该害怕重复发明轮子。当为了学习或者练习完成时，发明轮子是可以的！它是学习中一个重要的部分。比如，编写你自己版本的 ls，mv，wget 或者 cowsay 命令。如果你想要走游戏路线那可以克隆 Pong，Tetris 或者 Space Invaders 游戏。它们不需要全部相同的特点或者精确复制，但是你可以带着你的目标和空白的计划开始编程，你要把游戏实现出来。\n\n* [pong](https://github.com/greatcodeclub/pong)\n* [blockrain.js](https://github.com/Aerolab/blockrain.js) & [Hextris](https://github.com/Hextris/hextris)\n* [spaceinvaders](https://github.com/dwmkerr/spaceinvaders) & [space-tweet](https://github.com/fat/space-tweet)\n\n![games](http://78renz.com1.z0.glb.clouddn.com/blog-20160519.png?imageslim)\n\n在你写程序之前不要有'必须有个最佳的 idea 才开始动手'这种念头。我见到过在音乐家中有相同的心态。在他们第一次尝试时就努力创造一个高水平，这花费他们全部的精力投入到一首乐曲中。长远的是你将会写出很多很多乐曲，不仅仅是这一首。你完成的第一支乐曲可能不好，你很可能抛弃它。这没什么。在你第一次尝试时，不要试着想要写出最好的章节。你需要学习谱曲的过程。在你写好程序之前你将会编写出糟糕的程序。迈过它，征服它，获取经验你就能开始在需求上自由创作发挥。\n\n我们告诉人们用“Hello , world”做开端。因为这是他们行程的一个点，完成这个以为这征服了一个基础原理。你就理解了如何编译，如何运行，如何调用一个函数并且给它传递参数。编写一份已经存在软件的克隆版本是另外一个大的进步，跟 hello world 同等重要。当你完成它时，你已经克服了很多挑战。你已经发现哪里开始，如何计划，怎么组织，如何处理 bug ，给它一个人为的处理，并且打包最后它就成为一个可用的版本。即使你编写一个简单程序的克隆版本，你也能学习到全部过程。\n\n你可能会好奇如何克隆已经存在的项目，它将帮助你产生一些新想法。比如像音乐，它需要创新。演奏他人的乐曲怎么做才能帮助你谱写自己的乐谱呢？你必须首先理解其他人。你必须去了解他们如何创作的，还有他们使用了什么模式。当你做完这些足够时间你就开始着眼以后，并且你已经有丰富的知识用来总结。你将从不同地方学习到的小部分音节组合在一起，并且重复一些你了解的模式。你可能改进，组合，或者完全打破你学习到的这些模式。就像他们所说的，你需要了解规则目的是用来突破他们。在编程过程中我们也有通用的模式比如 MVC 。这是一个稳定的被接受的编写软件的模式。在音乐中，我们也有通用的模式。比如 [I-V-vi-IV](https://en.wikipedia.org/wiki/I%E2%80%93V%E2%80%93vi%E2%80%93IV_progression)。当然它不是唯一的一个，但它是已知很好的一个模式。\n\n总而言之，这是经验和创新的一个组合。创新是一部分人们经常在编程过程中被忽略的但他非常重要。你曾留意过有多少程序员也同样是作曲家吗？乐曲包含很多技术上分析，架构，模式尽管很多人认为他是一个纯粹的创作行为。编程是经常被看成技术性的动作尽管它多数是创作性的行为。你可以在复制其他项目过程中培养创新性。伴随着你逐渐完成他们，你将会发现你有了自己新的想法去改进程序，抑或是一个新的带有些许个性的特点被添加进去。它将会为新项目启发思路。创新随时会出现，但是你需要先学习如何把它首先谱写成歌曲。\n\n总有一天，你将会发现你将能够为所有事编程。你可以让任务自动化并且处理问题熟练。当你面对将会使你没有时间应对的诸多事情时，你处理起来也会没有问题的。你也将有能力随时解决问题。“哦，这有一个100个Sheet的表格需要被格式化，拆分成文件，转成一个 CSV 文件？马上就解决！”不要耽误时间去尝试做未来最好的事。编写一些你将会使用到的东西。其他项目的点子也会随之而来。\n\n你们中有多少人已经处于你想象的“我不知道写什么程序？”这种的状态？你是怎么解决它的？如果处于这种状态你有什么建议？\n\n[原文链接](http://www.devdungeon.com/content/i-know-how-program-i-dont-know-what-program?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=ios)\n\n湾区日报推荐\n\n> 豆子简评：对自己有一些启发，现在转职专门做前端相关的工作时间不长，从 J2EE SQL  ... 到 HTML CSS Javascript NodeJS ... 。虽然可以达到基本熟悉一门新的编程语言可以花费不长的时间这样一个状态，但是一直没有找到很好的办法在接触到一个新技术或框架时，短时间地拿着这些“新工具”去做事，其中原因很类似于“I Know how to program, but I don't know what to program.”，先造一些自己能用得上的轮子吧，在自己的 Lab 页多更新。","slug":"WANQU-Program-Beginning","published":1,"updated":"2017-11-04T11:09:17.000Z","comments":1,"photos":[],"link":"","_id":"cjc31n1g20025gey58lvghweo","content":"<blockquote>\n<p>湾区简评：这是很多初学编程的人，尤其是通过大学里的编程课学习写程序的人面临的问题。除了刷编程竞赛题、做课后编程题外，写程序能做什么？文章给的建议我赞同：先尝试去写自己也会用到的自动化的小工具。如果顺序反过来，已经知道要做什么了（比如做网站、做某个具体功能的app、做某个有实际用途的工具），再去学编程，会不会效果更好？</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"【译】我知道如何编程，但是我不知道拿来干什么\"><a href=\"#【译】我知道如何编程，但是我不知道拿来干什么\" class=\"headerlink\" title=\"【译】我知道如何编程，但是我不知道拿来干什么\"></a>【译】我知道如何编程，但是我不知道拿来干什么</h2><p><a href=\"http://www.devdungeon.com/content/i-know-how-program-i-dont-know-what-program?utm_source=wanqu.co&amp;utm_campaign=Wanqu+Daily&amp;utm_medium=ios\" target=\"_blank\" rel=\"noopener\">原文链接</a></p>\n<p>当我面对刚入门的开发者时总有一个重复的主题。他们已经把他们的时间投入到学习一门或者两门编程语言的基础上，并且他们轻松地完成一些编程练习，但是他们不知道怎么接受他们已经学习的东西。通常来说，就像“我知道如何编程，但是我不知道编写什么程序”。标志性的回答是“完成一些编程挑战”，“给开源项目贡献代码”或者是“做一款游戏”。</p>\n<p>完成编程挑战有益于脑力练习，但是它们却在人们学习如何创建一个新程序上的帮助很少。给开源项目贡献代码是一个提高的方式。你可能会学习到一个真实项目是如何架构的，并且在编程语言方面提升你的技巧，但是不会学习到很多的关于一个项目整个生命环的内容。某些项目非常复杂，这可能会对新手来说是非常恐怖的事。编写一款游戏是另一个提高的方式。游戏是有趣的！我以前曾开始用 QBASIC 编写游戏。然而发生了同样的困境。“我想要做一个游戏，但是我不知道做什么游戏”。</p>\n<p>教导音乐系学生跟编程一样，我已经意识到在音乐系学生中存在同样的模式。“我知道全部的和弦，并且我弹奏很熟练，但是我不知道怎么样写一首歌曲。”在音乐中，我们确实有一个很好的解答。在学习创作中有一个途径。音乐家通常不仅仅从一开始就写自己的音乐。有些音乐家永远不会向拼凑音乐和花掉一生时间演奏他人音乐的方向发展。在编程的世界，态度有一点不同。</p>\n<p>在软件社区有一个规则是“不要重复发明轮子”。当一个成熟稳定的选择存在时，如果你重写一个库通常是不被赞成的。虽然这对于一般人来说是一个好的规则，但新手不应该害怕重复发明轮子。当为了学习或者练习完成时，发明轮子是可以的！它是学习中一个重要的部分。比如，编写你自己版本的 ls，mv，wget 或者 cowsay 命令。如果你想要走游戏路线那可以克隆 Pong，Tetris 或者 Space Invaders 游戏。它们不需要全部相同的特点或者精确复制，但是你可以带着你的目标和空白的计划开始编程，你要把游戏实现出来。</p>\n<ul>\n<li><a href=\"https://github.com/greatcodeclub/pong\" target=\"_blank\" rel=\"noopener\">pong</a></li>\n<li><a href=\"https://github.com/Aerolab/blockrain.js\" target=\"_blank\" rel=\"noopener\">blockrain.js</a> &amp; <a href=\"https://github.com/Hextris/hextris\" target=\"_blank\" rel=\"noopener\">Hextris</a></li>\n<li><a href=\"https://github.com/dwmkerr/spaceinvaders\" target=\"_blank\" rel=\"noopener\">spaceinvaders</a> &amp; <a href=\"https://github.com/fat/space-tweet\" target=\"_blank\" rel=\"noopener\">space-tweet</a></li>\n</ul>\n<p><img src=\"http://78renz.com1.z0.glb.clouddn.com/blog-20160519.png?imageslim\" alt=\"games\"></p>\n<p>在你写程序之前不要有’必须有个最佳的 idea 才开始动手’这种念头。我见到过在音乐家中有相同的心态。在他们第一次尝试时就努力创造一个高水平，这花费他们全部的精力投入到一首乐曲中。长远的是你将会写出很多很多乐曲，不仅仅是这一首。你完成的第一支乐曲可能不好，你很可能抛弃它。这没什么。在你第一次尝试时，不要试着想要写出最好的章节。你需要学习谱曲的过程。在你写好程序之前你将会编写出糟糕的程序。迈过它，征服它，获取经验你就能开始在需求上自由创作发挥。</p>\n<p>我们告诉人们用“Hello , world”做开端。因为这是他们行程的一个点，完成这个以为这征服了一个基础原理。你就理解了如何编译，如何运行，如何调用一个函数并且给它传递参数。编写一份已经存在软件的克隆版本是另外一个大的进步，跟 hello world 同等重要。当你完成它时，你已经克服了很多挑战。你已经发现哪里开始，如何计划，怎么组织，如何处理 bug ，给它一个人为的处理，并且打包最后它就成为一个可用的版本。即使你编写一个简单程序的克隆版本，你也能学习到全部过程。</p>\n<p>你可能会好奇如何克隆已经存在的项目，它将帮助你产生一些新想法。比如像音乐，它需要创新。演奏他人的乐曲怎么做才能帮助你谱写自己的乐谱呢？你必须首先理解其他人。你必须去了解他们如何创作的，还有他们使用了什么模式。当你做完这些足够时间你就开始着眼以后，并且你已经有丰富的知识用来总结。你将从不同地方学习到的小部分音节组合在一起，并且重复一些你了解的模式。你可能改进，组合，或者完全打破你学习到的这些模式。就像他们所说的，你需要了解规则目的是用来突破他们。在编程过程中我们也有通用的模式比如 MVC 。这是一个稳定的被接受的编写软件的模式。在音乐中，我们也有通用的模式。比如 <a href=\"https://en.wikipedia.org/wiki/I%E2%80%93V%E2%80%93vi%E2%80%93IV_progression\" target=\"_blank\" rel=\"noopener\">I-V-vi-IV</a>。当然它不是唯一的一个，但它是已知很好的一个模式。</p>\n<p>总而言之，这是经验和创新的一个组合。创新是一部分人们经常在编程过程中被忽略的但他非常重要。你曾留意过有多少程序员也同样是作曲家吗？乐曲包含很多技术上分析，架构，模式尽管很多人认为他是一个纯粹的创作行为。编程是经常被看成技术性的动作尽管它多数是创作性的行为。你可以在复制其他项目过程中培养创新性。伴随着你逐渐完成他们，你将会发现你有了自己新的想法去改进程序，抑或是一个新的带有些许个性的特点被添加进去。它将会为新项目启发思路。创新随时会出现，但是你需要先学习如何把它首先谱写成歌曲。</p>\n<p>总有一天，你将会发现你将能够为所有事编程。你可以让任务自动化并且处理问题熟练。当你面对将会使你没有时间应对的诸多事情时，你处理起来也会没有问题的。你也将有能力随时解决问题。“哦，这有一个100个Sheet的表格需要被格式化，拆分成文件，转成一个 CSV 文件？马上就解决！”不要耽误时间去尝试做未来最好的事。编写一些你将会使用到的东西。其他项目的点子也会随之而来。</p>\n<p>你们中有多少人已经处于你想象的“我不知道写什么程序？”这种的状态？你是怎么解决它的？如果处于这种状态你有什么建议？</p>\n<p><a href=\"http://www.devdungeon.com/content/i-know-how-program-i-dont-know-what-program?utm_source=wanqu.co&amp;utm_campaign=Wanqu+Daily&amp;utm_medium=ios\" target=\"_blank\" rel=\"noopener\">原文链接</a></p>\n<p>湾区日报推荐</p>\n<blockquote>\n<p>豆子简评：对自己有一些启发，现在转职专门做前端相关的工作时间不长，从 J2EE SQL  … 到 HTML CSS Javascript NodeJS … 。虽然可以达到基本熟悉一门新的编程语言可以花费不长的时间这样一个状态，但是一直没有找到很好的办法在接触到一个新技术或框架时，短时间地拿着这些“新工具”去做事，其中原因很类似于“I Know how to program, but I don’t know what to program.”，先造一些自己能用得上的轮子吧，在自己的 Lab 页多更新。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>湾区简评：这是很多初学编程的人，尤其是通过大学里的编程课学习写程序的人面临的问题。除了刷编程竞赛题、做课后编程题外，写程序能做什么？文章给的建议我赞同：先尝试去写自己也会用到的自动化的小工具。如果顺序反过来，已经知道要做什么了（比如做网站、做某个具体功能的app、做某个有实际用途的工具），再去学编程，会不会效果更好？</p>\n</blockquote>","more":"<h2 id=\"【译】我知道如何编程，但是我不知道拿来干什么\"><a href=\"#【译】我知道如何编程，但是我不知道拿来干什么\" class=\"headerlink\" title=\"【译】我知道如何编程，但是我不知道拿来干什么\"></a>【译】我知道如何编程，但是我不知道拿来干什么</h2><p><a href=\"http://www.devdungeon.com/content/i-know-how-program-i-dont-know-what-program?utm_source=wanqu.co&amp;utm_campaign=Wanqu+Daily&amp;utm_medium=ios\" target=\"_blank\" rel=\"noopener\">原文链接</a></p>\n<p>当我面对刚入门的开发者时总有一个重复的主题。他们已经把他们的时间投入到学习一门或者两门编程语言的基础上，并且他们轻松地完成一些编程练习，但是他们不知道怎么接受他们已经学习的东西。通常来说，就像“我知道如何编程，但是我不知道编写什么程序”。标志性的回答是“完成一些编程挑战”，“给开源项目贡献代码”或者是“做一款游戏”。</p>\n<p>完成编程挑战有益于脑力练习，但是它们却在人们学习如何创建一个新程序上的帮助很少。给开源项目贡献代码是一个提高的方式。你可能会学习到一个真实项目是如何架构的，并且在编程语言方面提升你的技巧，但是不会学习到很多的关于一个项目整个生命环的内容。某些项目非常复杂，这可能会对新手来说是非常恐怖的事。编写一款游戏是另一个提高的方式。游戏是有趣的！我以前曾开始用 QBASIC 编写游戏。然而发生了同样的困境。“我想要做一个游戏，但是我不知道做什么游戏”。</p>\n<p>教导音乐系学生跟编程一样，我已经意识到在音乐系学生中存在同样的模式。“我知道全部的和弦，并且我弹奏很熟练，但是我不知道怎么样写一首歌曲。”在音乐中，我们确实有一个很好的解答。在学习创作中有一个途径。音乐家通常不仅仅从一开始就写自己的音乐。有些音乐家永远不会向拼凑音乐和花掉一生时间演奏他人音乐的方向发展。在编程的世界，态度有一点不同。</p>\n<p>在软件社区有一个规则是“不要重复发明轮子”。当一个成熟稳定的选择存在时，如果你重写一个库通常是不被赞成的。虽然这对于一般人来说是一个好的规则，但新手不应该害怕重复发明轮子。当为了学习或者练习完成时，发明轮子是可以的！它是学习中一个重要的部分。比如，编写你自己版本的 ls，mv，wget 或者 cowsay 命令。如果你想要走游戏路线那可以克隆 Pong，Tetris 或者 Space Invaders 游戏。它们不需要全部相同的特点或者精确复制，但是你可以带着你的目标和空白的计划开始编程，你要把游戏实现出来。</p>\n<ul>\n<li><a href=\"https://github.com/greatcodeclub/pong\" target=\"_blank\" rel=\"noopener\">pong</a></li>\n<li><a href=\"https://github.com/Aerolab/blockrain.js\" target=\"_blank\" rel=\"noopener\">blockrain.js</a> &amp; <a href=\"https://github.com/Hextris/hextris\" target=\"_blank\" rel=\"noopener\">Hextris</a></li>\n<li><a href=\"https://github.com/dwmkerr/spaceinvaders\" target=\"_blank\" rel=\"noopener\">spaceinvaders</a> &amp; <a href=\"https://github.com/fat/space-tweet\" target=\"_blank\" rel=\"noopener\">space-tweet</a></li>\n</ul>\n<p><img src=\"http://78renz.com1.z0.glb.clouddn.com/blog-20160519.png?imageslim\" alt=\"games\"></p>\n<p>在你写程序之前不要有’必须有个最佳的 idea 才开始动手’这种念头。我见到过在音乐家中有相同的心态。在他们第一次尝试时就努力创造一个高水平，这花费他们全部的精力投入到一首乐曲中。长远的是你将会写出很多很多乐曲，不仅仅是这一首。你完成的第一支乐曲可能不好，你很可能抛弃它。这没什么。在你第一次尝试时，不要试着想要写出最好的章节。你需要学习谱曲的过程。在你写好程序之前你将会编写出糟糕的程序。迈过它，征服它，获取经验你就能开始在需求上自由创作发挥。</p>\n<p>我们告诉人们用“Hello , world”做开端。因为这是他们行程的一个点，完成这个以为这征服了一个基础原理。你就理解了如何编译，如何运行，如何调用一个函数并且给它传递参数。编写一份已经存在软件的克隆版本是另外一个大的进步，跟 hello world 同等重要。当你完成它时，你已经克服了很多挑战。你已经发现哪里开始，如何计划，怎么组织，如何处理 bug ，给它一个人为的处理，并且打包最后它就成为一个可用的版本。即使你编写一个简单程序的克隆版本，你也能学习到全部过程。</p>\n<p>你可能会好奇如何克隆已经存在的项目，它将帮助你产生一些新想法。比如像音乐，它需要创新。演奏他人的乐曲怎么做才能帮助你谱写自己的乐谱呢？你必须首先理解其他人。你必须去了解他们如何创作的，还有他们使用了什么模式。当你做完这些足够时间你就开始着眼以后，并且你已经有丰富的知识用来总结。你将从不同地方学习到的小部分音节组合在一起，并且重复一些你了解的模式。你可能改进，组合，或者完全打破你学习到的这些模式。就像他们所说的，你需要了解规则目的是用来突破他们。在编程过程中我们也有通用的模式比如 MVC 。这是一个稳定的被接受的编写软件的模式。在音乐中，我们也有通用的模式。比如 <a href=\"https://en.wikipedia.org/wiki/I%E2%80%93V%E2%80%93vi%E2%80%93IV_progression\" target=\"_blank\" rel=\"noopener\">I-V-vi-IV</a>。当然它不是唯一的一个，但它是已知很好的一个模式。</p>\n<p>总而言之，这是经验和创新的一个组合。创新是一部分人们经常在编程过程中被忽略的但他非常重要。你曾留意过有多少程序员也同样是作曲家吗？乐曲包含很多技术上分析，架构，模式尽管很多人认为他是一个纯粹的创作行为。编程是经常被看成技术性的动作尽管它多数是创作性的行为。你可以在复制其他项目过程中培养创新性。伴随着你逐渐完成他们，你将会发现你有了自己新的想法去改进程序，抑或是一个新的带有些许个性的特点被添加进去。它将会为新项目启发思路。创新随时会出现，但是你需要先学习如何把它首先谱写成歌曲。</p>\n<p>总有一天，你将会发现你将能够为所有事编程。你可以让任务自动化并且处理问题熟练。当你面对将会使你没有时间应对的诸多事情时，你处理起来也会没有问题的。你也将有能力随时解决问题。“哦，这有一个100个Sheet的表格需要被格式化，拆分成文件，转成一个 CSV 文件？马上就解决！”不要耽误时间去尝试做未来最好的事。编写一些你将会使用到的东西。其他项目的点子也会随之而来。</p>\n<p>你们中有多少人已经处于你想象的“我不知道写什么程序？”这种的状态？你是怎么解决它的？如果处于这种状态你有什么建议？</p>\n<p><a href=\"http://www.devdungeon.com/content/i-know-how-program-i-dont-know-what-program?utm_source=wanqu.co&amp;utm_campaign=Wanqu+Daily&amp;utm_medium=ios\" target=\"_blank\" rel=\"noopener\">原文链接</a></p>\n<p>湾区日报推荐</p>\n<blockquote>\n<p>豆子简评：对自己有一些启发，现在转职专门做前端相关的工作时间不长，从 J2EE SQL  … 到 HTML CSS Javascript NodeJS … 。虽然可以达到基本熟悉一门新的编程语言可以花费不长的时间这样一个状态，但是一直没有找到很好的办法在接触到一个新技术或框架时，短时间地拿着这些“新工具”去做事，其中原因很类似于“I Know how to program, but I don’t know what to program.”，先造一些自己能用得上的轮子吧，在自己的 Lab 页多更新。</p>\n</blockquote>"},{"title":"Simple HTTP Server on OSX","date":"2016-05-31T06:18:32.000Z","_content":"\n很多项目在开发前期或者仅有 HTML/CSS/JS 文件，本地想要预览效果而不希望本地启动 Apache 或者 Nginx 难免有些麻烦，Mac OSX 其实内置Python，通过下面两条命令就可以快速启动一个简单 HTTP 服务。\n\n```shell\n$cd path/project/folder\n$python -m SimpleHTTPServer 8080\n```\n\nTada, thus you have got a HTTP server which port is 8080.\n\n```\ncontrol + c // stop it\n```\n","source":"_posts/2016-05-31-Simple-HTTP-Server-on-OSX.md","raw":"---\ntitle: Simple HTTP Server on OSX\ndate: 2016-05-31 14:18:32\ntags: [Mac]\n---\n\n很多项目在开发前期或者仅有 HTML/CSS/JS 文件，本地想要预览效果而不希望本地启动 Apache 或者 Nginx 难免有些麻烦，Mac OSX 其实内置Python，通过下面两条命令就可以快速启动一个简单 HTTP 服务。\n\n```shell\n$cd path/project/folder\n$python -m SimpleHTTPServer 8080\n```\n\nTada, thus you have got a HTTP server which port is 8080.\n\n```\ncontrol + c // stop it\n```\n","slug":"Simple-HTTP-Server-on-OSX","published":1,"updated":"2017-11-04T11:09:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc31n1g40027gey5uuj4w00t","content":"<p>很多项目在开发前期或者仅有 HTML/CSS/JS 文件，本地想要预览效果而不希望本地启动 Apache 或者 Nginx 难免有些麻烦，Mac OSX 其实内置Python，通过下面两条命令就可以快速启动一个简单 HTTP 服务。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span>cd path/project/folder</span><br><span class=\"line\"><span class=\"meta\">$</span>python -m SimpleHTTPServer 8080</span><br></pre></td></tr></table></figure>\n<p>Tada, thus you have got a HTTP server which port is 8080.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">control + c // stop it</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>很多项目在开发前期或者仅有 HTML/CSS/JS 文件，本地想要预览效果而不希望本地启动 Apache 或者 Nginx 难免有些麻烦，Mac OSX 其实内置Python，通过下面两条命令就可以快速启动一个简单 HTTP 服务。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span>cd path/project/folder</span><br><span class=\"line\"><span class=\"meta\">$</span>python -m SimpleHTTPServer 8080</span><br></pre></td></tr></table></figure>\n<p>Tada, thus you have got a HTTP server which port is 8080.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">control + c // stop it</span><br></pre></td></tr></table></figure>\n"},{"layout":"post","title":"【译】NPM vs Bower vs Browserify vs Gulp vs Grunt vs Webpack","date":"2016-06-17T06:35:33.000Z","_content":"\n这是一篇在 Stack overflow 看到的一篇问题和回答，对于自己有一些解惑\n\n<!-- more -->\n\n[Source Link](http://stackoverflow.com/questions/35062852/npm-vs-bower-vs-browserify-vs-gulp-vs-grunt-vs-webpack)\n\n## 作者问题\n\n> 描述：我正在试着总结关于最流行的 Javascript 包管理器，打包器和任务执行器的知识。如果有错误请纠正我。\n\n- `npm` & `bower` 是包管理工具。他们只是将依赖文件下载，并不知道在下载这些文件的基础上如何编译项目。他们知道的是在获取所有依赖之后去调用 `webpack`/`gulp`/`grunt` 。\n- `bower` 很像 `npm` ，但是编译依赖树不在行（不像 `npm` 那样递归着进行）。意味着 `npm` 获取每一依赖（可能获取几次相同的文件），然而 `bower` 期望你手动去包含子依赖。有时候 `bower` 和 `npm` 可以一起被使用，分别作用前端和后端（在前端每一mb都很重要）。\n- `glup` 和 `gulp` 是任务运行器，目的是将能够被自动化的所有事任务自动化执行。（比如编译css/sass，处理图片，打包还有最小化混淆代码）。\n- `grunt` vs `gulp` （就像`maven` vs `gradle` 或是 配置 vs 编码）。Grunt 是基于分离独立的任务配置的，每一个任务开始／处理／关闭文件。Gulp 需要少量代码，并且基于 node streams，那允许它编译链（w/o重复打开相同文件）而且执行很快。\n- `webpack` (`webpack-dev-server`) 对于我来说，它是任务执行器随着变化热加载，那些允许你忘记关于所有js/css的监视器。\n- `npm`/`bower`+plugin 可以替代任务运行器。他们的能力经常交叉因此如果你需要使用 `gulp`/`grunt` 在 npm+plugin 之上时存在着不同的潜在影响。但是任务运行器处理复杂任务定义的更好（比如 “在每一个编译打包，从ES6转义成ES5，在所有浏览器仿真器上运行，制作镜像还有通过ftp部署到dropbox”）。\n- `browserify` 允许为浏览器打包node模块。`browserify` vs `node's require` 就像 [AMD vs CommonJS](https://addyosmani.com/writing-modular-js/)\n\n### Questions\n\n+ 什么是 webpack 和 webpack-dev-server ？官方文档说它是模块打包器，但对于我而言，它知识任务运行工具。有什么不同？\n+ 你在哪里用到 browserify ？我们能不能和 node／ES6 一样做？\n+ 你什么时候在 npm + plugins 基础上使用 `gulp`/`grunt` ？\n\n## Beat Answer\n\n`Webpack` 和 `Browerify` 做了很多相同的工作，比如用于在一个浏览器环境钟打包你的模块。这个模块就是一个 Node 特征，它不在浏览器中存在，并且 ES6 中的 `import` 还没有在任何浏览器中实现，这就是为什么需要被打包。但是，他们在很多方式上是有区别的，`Webpack` 默认提供很多工具（比如代码拆分），`Browerify` 只能在下载插件之后才能做这些，但是使用这两种都能实现相似的效果。它取决于个人习惯（我常使用 `Webpack` ）。`Webpack` 不是一个任务运行器，它只是你通过CLI或任务运行器直接运行文件的一个中间过程器。\n\n`Webpack-dev-server` 提供类似于 `Browser-sync` - 它是一个你可以将你的 app 部署的服务，并且验证你的前端开发进程直接通过 dev-server 自动刷新浏览器或者在没有热部署的情况下传播变化（比如 React components）。\n\n我为了项目的完整和简单的任务编写已经使用`Gulp`，但是我后来发现我既不需要`Gulp`也不需要`Grunt`。所有我需要的都可以使用`npm`组合脚本去运行第三方工具利用它们的 API 完成。在`Gulp`，`Grunt`和`npm script`之间选择取决于你的需要、JS 经验和你工作时的开发经验。\n\n当然`Gulp`中的任务是易读的，甚至与JS不是很相似，它还是引用和学习另一个工具，并且我个人倾向于缩小我的依赖并且保持简单。另外一面，使用npm组合脚本和运行文件（配置和执行`Webpack`文件中函数）替代这些任务是更具有挑战性的。但是重要的是他们三个的结果是相同的。\n\n举例说我建议你看一看 [react starter project](https://github.com/kriasoft/react-starter-kit) ，它可以向你很好的展示`npm`组合脚本，`Webpack`和`browser-sync`。即使你可以处理你的源文件，如果你愿意，你可以使用`Gulp`或者`Grunt`运行你的开发服务，我更喜欢第一个选项。","source":"_posts/2016-06-17-NPM-vs-Bower-vs-Browserify-vs-Gulp-vs-Grunt-vs-Webpack.md","raw":"---\nlayout: post\ntitle: 【译】NPM vs Bower vs Browserify vs Gulp vs Grunt vs Webpack\ndate: 2016-06-17 14:35:33\ncategory : 译文计划\ntags: [翻译, Javascript, Front-End]\n---\n\n这是一篇在 Stack overflow 看到的一篇问题和回答，对于自己有一些解惑\n\n<!-- more -->\n\n[Source Link](http://stackoverflow.com/questions/35062852/npm-vs-bower-vs-browserify-vs-gulp-vs-grunt-vs-webpack)\n\n## 作者问题\n\n> 描述：我正在试着总结关于最流行的 Javascript 包管理器，打包器和任务执行器的知识。如果有错误请纠正我。\n\n- `npm` & `bower` 是包管理工具。他们只是将依赖文件下载，并不知道在下载这些文件的基础上如何编译项目。他们知道的是在获取所有依赖之后去调用 `webpack`/`gulp`/`grunt` 。\n- `bower` 很像 `npm` ，但是编译依赖树不在行（不像 `npm` 那样递归着进行）。意味着 `npm` 获取每一依赖（可能获取几次相同的文件），然而 `bower` 期望你手动去包含子依赖。有时候 `bower` 和 `npm` 可以一起被使用，分别作用前端和后端（在前端每一mb都很重要）。\n- `glup` 和 `gulp` 是任务运行器，目的是将能够被自动化的所有事任务自动化执行。（比如编译css/sass，处理图片，打包还有最小化混淆代码）。\n- `grunt` vs `gulp` （就像`maven` vs `gradle` 或是 配置 vs 编码）。Grunt 是基于分离独立的任务配置的，每一个任务开始／处理／关闭文件。Gulp 需要少量代码，并且基于 node streams，那允许它编译链（w/o重复打开相同文件）而且执行很快。\n- `webpack` (`webpack-dev-server`) 对于我来说，它是任务执行器随着变化热加载，那些允许你忘记关于所有js/css的监视器。\n- `npm`/`bower`+plugin 可以替代任务运行器。他们的能力经常交叉因此如果你需要使用 `gulp`/`grunt` 在 npm+plugin 之上时存在着不同的潜在影响。但是任务运行器处理复杂任务定义的更好（比如 “在每一个编译打包，从ES6转义成ES5，在所有浏览器仿真器上运行，制作镜像还有通过ftp部署到dropbox”）。\n- `browserify` 允许为浏览器打包node模块。`browserify` vs `node's require` 就像 [AMD vs CommonJS](https://addyosmani.com/writing-modular-js/)\n\n### Questions\n\n+ 什么是 webpack 和 webpack-dev-server ？官方文档说它是模块打包器，但对于我而言，它知识任务运行工具。有什么不同？\n+ 你在哪里用到 browserify ？我们能不能和 node／ES6 一样做？\n+ 你什么时候在 npm + plugins 基础上使用 `gulp`/`grunt` ？\n\n## Beat Answer\n\n`Webpack` 和 `Browerify` 做了很多相同的工作，比如用于在一个浏览器环境钟打包你的模块。这个模块就是一个 Node 特征，它不在浏览器中存在，并且 ES6 中的 `import` 还没有在任何浏览器中实现，这就是为什么需要被打包。但是，他们在很多方式上是有区别的，`Webpack` 默认提供很多工具（比如代码拆分），`Browerify` 只能在下载插件之后才能做这些，但是使用这两种都能实现相似的效果。它取决于个人习惯（我常使用 `Webpack` ）。`Webpack` 不是一个任务运行器，它只是你通过CLI或任务运行器直接运行文件的一个中间过程器。\n\n`Webpack-dev-server` 提供类似于 `Browser-sync` - 它是一个你可以将你的 app 部署的服务，并且验证你的前端开发进程直接通过 dev-server 自动刷新浏览器或者在没有热部署的情况下传播变化（比如 React components）。\n\n我为了项目的完整和简单的任务编写已经使用`Gulp`，但是我后来发现我既不需要`Gulp`也不需要`Grunt`。所有我需要的都可以使用`npm`组合脚本去运行第三方工具利用它们的 API 完成。在`Gulp`，`Grunt`和`npm script`之间选择取决于你的需要、JS 经验和你工作时的开发经验。\n\n当然`Gulp`中的任务是易读的，甚至与JS不是很相似，它还是引用和学习另一个工具，并且我个人倾向于缩小我的依赖并且保持简单。另外一面，使用npm组合脚本和运行文件（配置和执行`Webpack`文件中函数）替代这些任务是更具有挑战性的。但是重要的是他们三个的结果是相同的。\n\n举例说我建议你看一看 [react starter project](https://github.com/kriasoft/react-starter-kit) ，它可以向你很好的展示`npm`组合脚本，`Webpack`和`browser-sync`。即使你可以处理你的源文件，如果你愿意，你可以使用`Gulp`或者`Grunt`运行你的开发服务，我更喜欢第一个选项。","slug":"NPM-vs-Bower-vs-Browserify-vs-Gulp-vs-Grunt-vs-Webpack","published":1,"updated":"2017-11-04T11:09:17.000Z","comments":1,"photos":[],"link":"","_id":"cjc31n1g5002bgey526y0oofd","content":"<p>这是一篇在 Stack overflow 看到的一篇问题和回答，对于自己有一些解惑</p>\n<a id=\"more\"></a>\n<p><a href=\"http://stackoverflow.com/questions/35062852/npm-vs-bower-vs-browserify-vs-gulp-vs-grunt-vs-webpack\" target=\"_blank\" rel=\"noopener\">Source Link</a></p>\n<h2 id=\"作者问题\"><a href=\"#作者问题\" class=\"headerlink\" title=\"作者问题\"></a>作者问题</h2><blockquote>\n<p>描述：我正在试着总结关于最流行的 Javascript 包管理器，打包器和任务执行器的知识。如果有错误请纠正我。</p>\n</blockquote>\n<ul>\n<li><code>npm</code> &amp; <code>bower</code> 是包管理工具。他们只是将依赖文件下载，并不知道在下载这些文件的基础上如何编译项目。他们知道的是在获取所有依赖之后去调用 <code>webpack</code>/<code>gulp</code>/<code>grunt</code> 。</li>\n<li><code>bower</code> 很像 <code>npm</code> ，但是编译依赖树不在行（不像 <code>npm</code> 那样递归着进行）。意味着 <code>npm</code> 获取每一依赖（可能获取几次相同的文件），然而 <code>bower</code> 期望你手动去包含子依赖。有时候 <code>bower</code> 和 <code>npm</code> 可以一起被使用，分别作用前端和后端（在前端每一mb都很重要）。</li>\n<li><code>glup</code> 和 <code>gulp</code> 是任务运行器，目的是将能够被自动化的所有事任务自动化执行。（比如编译css/sass，处理图片，打包还有最小化混淆代码）。</li>\n<li><code>grunt</code> vs <code>gulp</code> （就像<code>maven</code> vs <code>gradle</code> 或是 配置 vs 编码）。Grunt 是基于分离独立的任务配置的，每一个任务开始／处理／关闭文件。Gulp 需要少量代码，并且基于 node streams，那允许它编译链（w/o重复打开相同文件）而且执行很快。</li>\n<li><code>webpack</code> (<code>webpack-dev-server</code>) 对于我来说，它是任务执行器随着变化热加载，那些允许你忘记关于所有js/css的监视器。</li>\n<li><code>npm</code>/<code>bower</code>+plugin 可以替代任务运行器。他们的能力经常交叉因此如果你需要使用 <code>gulp</code>/<code>grunt</code> 在 npm+plugin 之上时存在着不同的潜在影响。但是任务运行器处理复杂任务定义的更好（比如 “在每一个编译打包，从ES6转义成ES5，在所有浏览器仿真器上运行，制作镜像还有通过ftp部署到dropbox”）。</li>\n<li><code>browserify</code> 允许为浏览器打包node模块。<code>browserify</code> vs <code>node&#39;s require</code> 就像 <a href=\"https://addyosmani.com/writing-modular-js/\" target=\"_blank\" rel=\"noopener\">AMD vs CommonJS</a></li>\n</ul>\n<h3 id=\"Questions\"><a href=\"#Questions\" class=\"headerlink\" title=\"Questions\"></a>Questions</h3><ul>\n<li>什么是 webpack 和 webpack-dev-server ？官方文档说它是模块打包器，但对于我而言，它知识任务运行工具。有什么不同？</li>\n<li>你在哪里用到 browserify ？我们能不能和 node／ES6 一样做？</li>\n<li>你什么时候在 npm + plugins 基础上使用 <code>gulp</code>/<code>grunt</code> ？</li>\n</ul>\n<h2 id=\"Beat-Answer\"><a href=\"#Beat-Answer\" class=\"headerlink\" title=\"Beat Answer\"></a>Beat Answer</h2><p><code>Webpack</code> 和 <code>Browerify</code> 做了很多相同的工作，比如用于在一个浏览器环境钟打包你的模块。这个模块就是一个 Node 特征，它不在浏览器中存在，并且 ES6 中的 <code>import</code> 还没有在任何浏览器中实现，这就是为什么需要被打包。但是，他们在很多方式上是有区别的，<code>Webpack</code> 默认提供很多工具（比如代码拆分），<code>Browerify</code> 只能在下载插件之后才能做这些，但是使用这两种都能实现相似的效果。它取决于个人习惯（我常使用 <code>Webpack</code> ）。<code>Webpack</code> 不是一个任务运行器，它只是你通过CLI或任务运行器直接运行文件的一个中间过程器。</p>\n<p><code>Webpack-dev-server</code> 提供类似于 <code>Browser-sync</code> - 它是一个你可以将你的 app 部署的服务，并且验证你的前端开发进程直接通过 dev-server 自动刷新浏览器或者在没有热部署的情况下传播变化（比如 React components）。</p>\n<p>我为了项目的完整和简单的任务编写已经使用<code>Gulp</code>，但是我后来发现我既不需要<code>Gulp</code>也不需要<code>Grunt</code>。所有我需要的都可以使用<code>npm</code>组合脚本去运行第三方工具利用它们的 API 完成。在<code>Gulp</code>，<code>Grunt</code>和<code>npm script</code>之间选择取决于你的需要、JS 经验和你工作时的开发经验。</p>\n<p>当然<code>Gulp</code>中的任务是易读的，甚至与JS不是很相似，它还是引用和学习另一个工具，并且我个人倾向于缩小我的依赖并且保持简单。另外一面，使用npm组合脚本和运行文件（配置和执行<code>Webpack</code>文件中函数）替代这些任务是更具有挑战性的。但是重要的是他们三个的结果是相同的。</p>\n<p>举例说我建议你看一看 <a href=\"https://github.com/kriasoft/react-starter-kit\" target=\"_blank\" rel=\"noopener\">react starter project</a> ，它可以向你很好的展示<code>npm</code>组合脚本，<code>Webpack</code>和<code>browser-sync</code>。即使你可以处理你的源文件，如果你愿意，你可以使用<code>Gulp</code>或者<code>Grunt</code>运行你的开发服务，我更喜欢第一个选项。</p>\n","site":{"data":{}},"excerpt":"<p>这是一篇在 Stack overflow 看到的一篇问题和回答，对于自己有一些解惑</p>","more":"<p><a href=\"http://stackoverflow.com/questions/35062852/npm-vs-bower-vs-browserify-vs-gulp-vs-grunt-vs-webpack\" target=\"_blank\" rel=\"noopener\">Source Link</a></p>\n<h2 id=\"作者问题\"><a href=\"#作者问题\" class=\"headerlink\" title=\"作者问题\"></a>作者问题</h2><blockquote>\n<p>描述：我正在试着总结关于最流行的 Javascript 包管理器，打包器和任务执行器的知识。如果有错误请纠正我。</p>\n</blockquote>\n<ul>\n<li><code>npm</code> &amp; <code>bower</code> 是包管理工具。他们只是将依赖文件下载，并不知道在下载这些文件的基础上如何编译项目。他们知道的是在获取所有依赖之后去调用 <code>webpack</code>/<code>gulp</code>/<code>grunt</code> 。</li>\n<li><code>bower</code> 很像 <code>npm</code> ，但是编译依赖树不在行（不像 <code>npm</code> 那样递归着进行）。意味着 <code>npm</code> 获取每一依赖（可能获取几次相同的文件），然而 <code>bower</code> 期望你手动去包含子依赖。有时候 <code>bower</code> 和 <code>npm</code> 可以一起被使用，分别作用前端和后端（在前端每一mb都很重要）。</li>\n<li><code>glup</code> 和 <code>gulp</code> 是任务运行器，目的是将能够被自动化的所有事任务自动化执行。（比如编译css/sass，处理图片，打包还有最小化混淆代码）。</li>\n<li><code>grunt</code> vs <code>gulp</code> （就像<code>maven</code> vs <code>gradle</code> 或是 配置 vs 编码）。Grunt 是基于分离独立的任务配置的，每一个任务开始／处理／关闭文件。Gulp 需要少量代码，并且基于 node streams，那允许它编译链（w/o重复打开相同文件）而且执行很快。</li>\n<li><code>webpack</code> (<code>webpack-dev-server</code>) 对于我来说，它是任务执行器随着变化热加载，那些允许你忘记关于所有js/css的监视器。</li>\n<li><code>npm</code>/<code>bower</code>+plugin 可以替代任务运行器。他们的能力经常交叉因此如果你需要使用 <code>gulp</code>/<code>grunt</code> 在 npm+plugin 之上时存在着不同的潜在影响。但是任务运行器处理复杂任务定义的更好（比如 “在每一个编译打包，从ES6转义成ES5，在所有浏览器仿真器上运行，制作镜像还有通过ftp部署到dropbox”）。</li>\n<li><code>browserify</code> 允许为浏览器打包node模块。<code>browserify</code> vs <code>node&#39;s require</code> 就像 <a href=\"https://addyosmani.com/writing-modular-js/\" target=\"_blank\" rel=\"noopener\">AMD vs CommonJS</a></li>\n</ul>\n<h3 id=\"Questions\"><a href=\"#Questions\" class=\"headerlink\" title=\"Questions\"></a>Questions</h3><ul>\n<li>什么是 webpack 和 webpack-dev-server ？官方文档说它是模块打包器，但对于我而言，它知识任务运行工具。有什么不同？</li>\n<li>你在哪里用到 browserify ？我们能不能和 node／ES6 一样做？</li>\n<li>你什么时候在 npm + plugins 基础上使用 <code>gulp</code>/<code>grunt</code> ？</li>\n</ul>\n<h2 id=\"Beat-Answer\"><a href=\"#Beat-Answer\" class=\"headerlink\" title=\"Beat Answer\"></a>Beat Answer</h2><p><code>Webpack</code> 和 <code>Browerify</code> 做了很多相同的工作，比如用于在一个浏览器环境钟打包你的模块。这个模块就是一个 Node 特征，它不在浏览器中存在，并且 ES6 中的 <code>import</code> 还没有在任何浏览器中实现，这就是为什么需要被打包。但是，他们在很多方式上是有区别的，<code>Webpack</code> 默认提供很多工具（比如代码拆分），<code>Browerify</code> 只能在下载插件之后才能做这些，但是使用这两种都能实现相似的效果。它取决于个人习惯（我常使用 <code>Webpack</code> ）。<code>Webpack</code> 不是一个任务运行器，它只是你通过CLI或任务运行器直接运行文件的一个中间过程器。</p>\n<p><code>Webpack-dev-server</code> 提供类似于 <code>Browser-sync</code> - 它是一个你可以将你的 app 部署的服务，并且验证你的前端开发进程直接通过 dev-server 自动刷新浏览器或者在没有热部署的情况下传播变化（比如 React components）。</p>\n<p>我为了项目的完整和简单的任务编写已经使用<code>Gulp</code>，但是我后来发现我既不需要<code>Gulp</code>也不需要<code>Grunt</code>。所有我需要的都可以使用<code>npm</code>组合脚本去运行第三方工具利用它们的 API 完成。在<code>Gulp</code>，<code>Grunt</code>和<code>npm script</code>之间选择取决于你的需要、JS 经验和你工作时的开发经验。</p>\n<p>当然<code>Gulp</code>中的任务是易读的，甚至与JS不是很相似，它还是引用和学习另一个工具，并且我个人倾向于缩小我的依赖并且保持简单。另外一面，使用npm组合脚本和运行文件（配置和执行<code>Webpack</code>文件中函数）替代这些任务是更具有挑战性的。但是重要的是他们三个的结果是相同的。</p>\n<p>举例说我建议你看一看 <a href=\"https://github.com/kriasoft/react-starter-kit\" target=\"_blank\" rel=\"noopener\">react starter project</a> ，它可以向你很好的展示<code>npm</code>组合脚本，<code>Webpack</code>和<code>browser-sync</code>。即使你可以处理你的源文件，如果你愿意，你可以使用<code>Gulp</code>或者<code>Grunt</code>运行你的开发服务，我更喜欢第一个选项。</p>"},{"_content":"【译】Google出品 - 利用 webpack 做 web 性能优化\n\n===\n\n2018-02-11 Beanlee\n\n原文 https://developers.google.com/web/fundamentals/performance/webpack/\n\n作者 Addy Osmani\n\n## Instroduction 介绍\n\n现代 Web 应用经常用到`bunding tool`用于创建一个生产环境的打包文件（例如脚本、样式等），这个打包文件是已经优化完，并且最小化完成的，并且能够被用户用更少的时间下载到。在这篇文章中，我们将会利用`webpack`来贯穿如何优化网站资源。这样可以帮助用户对于你的网站得到更快地加载和体验。\n\n![webpack-logo](https://img20.360buyimg.com/uba/jfs/t15217/149/2229580840/12989/54324b99/5a815957N5bb3e0c6.png)\n\nwebpack 目前是最流行的打包工具之一，深入地利用他的特点去优化代码，拆分脚本成重要和非重要部分还有剔除无用的代码能够保证你的引用有最小的带宽和进程消耗。\n\n![code-splitting](https://img14.360buyimg.com/uba/jfs/t17569/325/476871633/18187/a1e34f41/5a81597fNd77bb5b8.png)\n\n> Note: 我们创建了一个练习用的引用来演示优化的描述。尽力挤出最多的时间来练习这些 tips [`webpack-training-project`](https://github.com/GoogleChromeLabs/webpack-training-project)\n\n让我们从现代 web 应用中最耗费资源之一的 `Javascript`开始。\n\n- 减小前端体积\n- 利用长期缓存\n- 监控并分析应用\n- 结尾\n\n===\n\n## Decrease Front-end Size 减少前端体积\n\n作者 [Ivan Akulov](https://developers.google.com/web/resources/contributors/iamakulov)\n\n当你正在优化一个应用时最初第一件事就是尽可能地让它体积减小。下面就是利用 webpack 如何做。\n\n### Enable minification 启用最小化\n\n最小化是通过去除多余空格、缩短变量名等方式压缩代码。例如：\n\n```javascript\n// Original code\nfunction map(array, iteratee) {\n  let index = -1;\n  const length = array == null ? 0 : array.length;\n  const result = new Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n```\nto\n\n```javascript\n// Minified code\nfunction map(n,r){let t=-1;for(const a=null==n?0:n.length,l=Array(a);++t<a;)l[t]=r(n[t],t,n);return l}\n```\nWebpack 支持两种方式最小化代码：UglifyJS 插件和_loader-specific options_。他们可以同时使用。\n\n[The UglifyJS plugin](https://github.com/webpack-contrib/uglifyjs-webpack-plugin)在 bundle 层级中起作用，在编译之后压缩 bundle。下面来展示如何工作：\n\n\n1. 你的代码：\n\n```javascript\n// comments.js\nimport './comments.css';\nexport function render(data, target) {\n  console.log('Rendered!');\n}\n```\n2. Webpack 打包大致成如下：\n\n```javascript\n// bundle.js (part of)\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony export (immutable) */ __webpack_exports__[\"render\"] = render;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__comments_css__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__comments_css_js___default =\n__webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__comments_css__);\n\nfunction render(data, target) {\n  console.log('Rendered!');\n}\n```\n3. 使用 UglifyJS 插件大致编译成如下：\n\n```javascript\n// minified bundle.js (part of)\n\"use strict\";function t(e,n){console.log(\"Rendered!\")}\nObject.defineProperty(n,\"__esModule\",{value:!0}),n.render=t;var o=r(1);r.n(o)\n```\n插件集成在 webpack 中，把它的配置在`plugins`中就可以启用：\n\n```javascript\n// webpack.config.js\nconst webpack = require('webpack');\n\nmodule.exports = {\n  plugins: [\n    new webpack.optimize.UglifyJsPlugin(),\n  ],\n};\n```\n第二种方式_loader-specific options_ 利用 loader options，可以压缩 Uglify 插件无法最小化的部分。举例，当你利用`css-loader`引入一个 CSS 文件时，文件会编译成一个字符串：\n\n```css\n/* comments.css */\n.comment {\n  color: black;\n}\n```\nto\n\n```javascript\n// minified bundle.js (part of)\nexports=module.exports=__webpack_require__(1)(),\nexports.push([module.i,\".comment {\\r\\n  color: black;\\r\\n}\",\"\"]);\n```\nUglifyJS 由于这是一个字符串不能压缩这段代码。要最小化这个 css 文件内容，我们需要配置 _loader_\n\n```javascript\n// webpack.config.js\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\n          'style-loader',\n          { loader: 'css-loader', options: { minimize: true } },\n        ],\n      },\n    ],\n  },\n};\n```\n**{ minimize: true }**\n\n> Note: UglifyJS 插件不能编译 ES2015+(ES2016)，这意味着如果你的 diamante 中使用类、箭头函数和一些新特性语法，不能编译成 ES5，插件会抛异常。\n> 如果需要编译新语法，要使用 [uglifyjs-webpack-plugin](https://github.com/webpack-contrib/uglifyjs-webpack-plugin) 包。也是集成在 webpack 中相同的插件，但是更新一些，能够有能力编译 ES2015+。\n\n#### Further reading\n\n* [The UglifyJsPlugin docs](https://github.com/webpack-contrib/uglifyjs-webpack-plugin)\n* Other popular minifiers: [Babel Minify](https://github.com/webpack-contrib/babel-minify-webpack-plugin), [Google Closure Compiler](https://github.com/roman01la/webpack-closure-compiler)\n\n### Specify `NODE_ENV=production` 明确生产环境信息\n\n减小前端体积的另外一个方法就是在代码中将`NODE_ENV`[环境变量](https://superuser.com/questions/284342/what-are-path-and-other-environment-variables-and-how-can-i-set-or-use-them)设置成`production`。\n\nLibraries 会读取`NODE_ENV`变量判断他们应该在那种模式下工作 - 开发模式 or 生成模式。很多库会基于这个变量有不同的表现。举个例子，当`NODE_ENV`没有设置成`production`，Vue.js 会做额外的检查并且输出一些警告：\n\n\n```javascript\n// vue/dist/vue.runtime.esm.js\n// …\nif (process.env.NODE_ENV !== 'production') {\n  warn('props must be strings when using array syntax.');\n}\n// …\n```\nReact 也是类似 - 开发模式下 build 带有一些警告：\n\n```javascript\n// react/index.js\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react.production.min.js');\n} else {\n  module.exports = require('./cjs/react.development.js');\n}\n\n// react/cjs/react.development.js\n// …\nwarning$3(\n  componentClass.getDefaultProps.isReactClassApproved,\n  'getDefaultProps is only used on classic React.createClass ' +\n  'definitions. Use a static property named `defaultProps` instead.'\n);\n// …\n```\n这些检查和警告通常在生产环境下不必要的，但是他们仍然保留在代码中并且会增加库的体积。通过配置 webpack 的 [`DefinePlugin`](https://webpack.js.org/plugins/define-plugin/) 来删除他们：\n\n```javascript\n // webpack.config.js\nconst webpack = require('webpack');\n\nmodule.exports = {\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.env.NODE_ENV': '\"production\"',\n    }),\n    new webpack.optimize.UglifyJsPlugin(),\n  ],\n};\n```\n`DefinePlugin`用确定的变量替换所有存在的说明变量。利用下面配置：\n\n1. `DefinePlugin`将用`\"production\"`替换到`process.env.NODE_ENV`：\n\n```javascript\n// vue/dist/vue.runtime.esm.js\nif (typeof val === 'string') {\n  name = camelize(val);\n  res[name] = { type: null };\n} else if (process.env.NODE_ENV !== 'production') {\n  warn('props must be strings when using array syntax.');\n}\n```\nto\n\n```javascript\n// vue/dist/vue.runtime.esm.js\nif (typeof val === 'string') {\n  name = camelize(val);\n  res[name] = { type: null };\n} else if (\"production\" !== 'production') {\n  warn('props must be strings when using array syntax.');\n}\n```\n> Note: 如果你偏向有通过 CLI 配置变量，可以查看一下 [EnvironmentPlugin](https://webpack.js.org/plugins/environment-plugin/)。它和`DefinePlugin`类似，但读环境并且自动替换`process.env`表达式。\n\n2.`UglifyJS`会移除掉所有`if`分支 - 因为`\"production\" !== 'production'`永远返回 false ，插件理解代码内的判断分支将永远不会执行：\n\n```javascript\n// vue/dist/vue.runtime.esm.js\nif (typeof val === 'string') {\n  name = camelize(val);\n  res[name] = { type: null };\n} else if (\"production\" !== 'production') {\n  warn('props must be strings when using array syntax.');\n}\n```\nto\n\n```javascript\n// vue/dist/vue.runtime.esm.js (without minification)\nif (typeof val === 'string') {\n  name = camelize(val);\n  res[name] = { type: null };\n}\n```\n> Note: 不一定强制要求使用 `UglifyJSPlugin`。你可以使用其他不同的最小化工具，这些页支持移除无用代码（例如，the [Babel Minify plugin](https://github.com/webpack-contrib/babel-minify-webpack-plugin) or the [Google Closure Compiler plugin](https://github.com/roman01la/webpack-closure-compiler)）\n\n#### Further Reading\n\n*   [What “environment variables” are](https://superuser.com/questions/284342/what-are-path-and-other-environment-variables-and-how-can-i-set-or-use-them)\n*   Webpack docs about: [`DefinePlugin`](https://webpack.js.org/plugins/define-plugin/), [`EnvironmentPlugin`](https://webpack.js.org/plugins/environment-plugin/)\n\n### Use ES Modules 使用 ES 模块\n\n下面这个方式利用 [ES modules](https://ponyfoo.com/articles/es6-modules-in-depth) 减小前端体积。\n\n当你使用 ES module，webpack 有能力去做 tree-shaking。Tree-shaking 贯穿整个依赖树，检查那些依赖被使用，移除无用依赖。因此，如果你使用 ES module 语法，webpack 可以排除掉无用代码：\n1. 一个有多个 export 的文件，但是 app 只需要其中一个：\n\n```javascript\n// comments.js\nexport const render = () => { return 'Rendered!'; };\nexport const commentRestEndpoint = '/rest/comments';\n\n// index.js\nimport { render } from './comments.js';\nrender();\n```\n2. webpack 理解 `commentRestEndPoint`没有使用，同时不能在一个 bundle 中生成单独的 export：\n\n```javascript\n// bundle.js (part that corresponds to comments.js)\n(function(module, __webpack_exports__, __webpack_require__) {\n  \"use strict\";\n  const render = () => { return 'Rendered!'; };\n  /* harmony export (immutable) */ __webpack_exports__[\"a\"] = render;\n\n  const commentRestEndpoint = '/rest/comments';\n  /* unused harmony export commentRestEndpoint */\n})\n```\n3. `UglifyJSPlugin`移除无用变量：\n\n```javascript\n// bundle.js (part that corresponds to comments.js)\n(function(n,e){\"use strict\";var r=function(){return\"Rendered!\"};e.b=r})\n```\n如果他们都是有 ES module 编写，就是与一些库并存时也是生效的。\n\n> Note: 在 webpack 中，tree-shaking 没有 minifier 是无法生效的。 webpack 仅仅移除了没有被用到的 export 变量；`UglifyJSPlugin`才会移除无用代码。所以如果你编译打包时没有使用 minifier，打包后体积并不会更小。你也可以不一定使用这个插件。其他最小化的插件也支持移除 dead code（例如：[Babel Minify plugin](https://github.com/webpack-contrib/babel-minify-webpack-plugin) or [Google Closure Compiler plugin](https://github.com/roman01la/webpack-closure-compiler)）\n\n> Warning: 不要将 ES module 编译到 CommonJS 中。 如果你使用 Babel `babel-preset-env` or `babel-preset-es2015`，检查一下当前的配置。默认情况下， ES `import` and `export` to CommonJS `require` and `module.exports`。通过设置 option 来禁止掉[Pass the `{ modules: false }` option](https://github.com/babel/babel/tree/master/experimental/babel-preset-env)。\n\n\n#### Futher reading\n\n*   [“ES6 Modules in depth”](https://ponyfoo.com/articles/es6-modules-in-depth)\n*   Webpack docs [about tree shaking](https://webpack.js.org/guides/tree-shaking/)\n\n### Optimize images 优化图片\n\n图片基本会占局页面一半以上体积。虽然它们不像 JavaScript 那么重要（比如它们不会阻止页面渲染），但图片仍然会占用掉一大部分带宽。利用`url-loader`，`svg-url-loader`和`image-webpack-loader`来在 webpack 中进行优化。\n\n`url-loader` 允许将小静态文件打包进 app。没有配置，他需要通过 file，将它放在编译后的打包 bundle 内并返回一个这个文件的 url。然而，如果我们注明`limit`选项，它将会 encode 成更小的文件 base64 文件 url。这是可以将图片放在Javascript 代码中，同时节省 HTTP 请求：\n\n```javascript\n// webpack.config.js\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.(jpe?g|png|gif)$/,\n        loader: 'url-loader',\n        options: {\n          // Inline files smaller than 10 kB (10240 bytes)\n          limit: 10 * 1024,\n        },\n      },\n    ],\n  }\n};\n```\n\n```javascript\n// index.js\nimport imageUrl from './image.png';\n// → If image.png is smaller than 10 kB, `imageUrl` will include\n// the encoded image: 'data:image/png;base64,iVBORw0KGg…'\n// → If image.png is larger than 10 kB, the loader will create a new file,\n// and `imageUrl` will include its url: `/2fcd56a1920be.png`\n```\n> Note: 内联图片减少了独立请求的数量，这是很好的方式（[even with HTTP/2](https://blog.octo.com/en/http2-arrives-but-sprite-sets-aint-no-dead/)），但是会增加 bundle下载和转换的时间和内存的消耗。一定要确保不要嵌入超大图片或者较多的图片 - 否则增加的 bundle 的时间将会掩盖做成内联图片的收益。\n\n`svg-url-loader`与`url-loader`类似 - 都是将使用 [URL encoding](https://developer.mozilla.org/en-US/docs/Glossary/percent-encoding)  encode 文件。这对对于 SVG 图片很奏效 - 因为 SVG 文件是文本，encoding 在体积上更有效率：\n\n```javascript\n// webpack.config.js\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.svg$/,\n        loader: 'svg-url-loader',\n        options: {\n          // Inline files smaller than 10 kB (10240 bytes)\n          limit: 10 * 1024,\n          // Remove the quotes from the url\n          // (they’re unnecessary in most cases)\n          noquotes: true,\n        },\n      },\n    ],\n  },\n};\n```\n> Note: svg-url-loader 拥有改善 IE 浏览器支持的 options，但是在其他浏览器中更糟糕。如果你需要兼容 IE 浏览器，[设置 iesafe: true 选项](https://github.com/bhovhannes/svg-url-loader#iesafe)\n\n`image-webpack-loader`压缩图片使之变小。它支持 JPG，PNG，GIF 和 SVG，因为我们将会使用它所有类型。\n\n这个 loader 不会将图片嵌入在应用内，因此它必须与`url-loader`和`svg-url-loader`配合使用。避免复制粘贴到相同的 rules 中（一个用于 JPG/PNG/GIF 图片，另一个用于 SVG 图片），我们来使用`enforce: pre`作为单独的一个 rule 涵盖这个 loader：\n\n```javascript\n// webpack.config.js\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.(jpe?g|png|gif|svg)$/,\n        loader: 'image-webpack-loader',\n        // This will apply the loader before the other ones\n        enforce: 'pre',\n      },\n    ],\n  },\n};\n```\n默认 loader 的设置就已经可以了 - 但是如果你想要更深入的配置，查看 [the plugin options](https://github.com/tcoopman/image-webpack-loader#options)。为了选择哪些 options 需要明确，可以查看 Addy Osmani 的 [guide on image optimization](https://images.guide/)\n\n#### Further reading\n\n*   [\"What is base64 encoding used for?\"](https://stackoverflow.com/questions/201479/what-is-base-64-encoding-used-for)\n*   Addy Osmani’s [guide on image optimization](https://images.guide/)\n\n### Optimize dependencies 优化依赖\n\n平均一半以上的 Javascript 体积大小来源于依赖包，并且这些可能都不是必要的。\n\n举一个例子来说，Lodash（v4.17.4）增加了最小化代码的 72KB 大小到 bundle 中。但是如果你仅仅用到它的20个方法，大于 65 KB 没有用处。\n\n另外一个例子就是 Moment.js。 V2.19.1版本最小化后有 223KB，体积巨大 - 截至2017年10月一个页面内的 Javascript 平均体积是 452KB。但是，本地文件的体积占 170KB。如果你没有用到 多语言版 Moment.js，这些文件都会没有目的地使 bundle 更臃肿。\n\n所有这些依赖都可以被轻易优化。我们在 Github repo 手机了优化的建议，[check it out](https://github.com/GoogleChromeLabs/webpack-libs-optimizations)！\n\n### Enable module concatenation for ES modules (aka scope hoisting)\n\n当你构建一个 bundle 时，webpack 将每一个 module 封装进 function 中：\n\n```javascript\n// index.js\nimport {render} from './comments.js';\nrender();\n\n// comments.js\nexport function render(data, target) {\n  console.log('Rendered!');\n}\n```\nto\n\n```javascript\n// bundle.js (part  of)\n/* 0 */\n(function(module, __webpack_exports__, __webpack_require__) {\n\n  \"use strict\";\n  Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n  var __WEBPACK_IMPORTED_MODULE_0__comments_js__ = __webpack_require__(1);\n  Object(__WEBPACK_IMPORTED_MODULE_0__comments_js__[\"a\" /* render */])();\n\n}),\n/* 1 */\n(function(module, __webpack_exports__, __webpack_require__) {\n\n  \"use strict\";\n  __webpack_exports__[\"a\"] = render;\n  function render(data, target) {\n    console.log('Rendered!');\n  }\n\n})\n```\n在以前，这是使 CommonJS/AMD modules 互相分离所必须的。但是，这回增加体积同时性能堪忧。\n\nWebpack 2 介绍了 ES modules 的支持，不像 CommonJS 和 AMD modules 一样，而是能够不用将每一个 module 用 function 封装起来。同时 Webpack 3 利用[`ModuleConcatenationPlugin`](https://webpack.js.org/plugins/module-concatenation-plugin/)完成这样一个 bundle，下面是例子：\n\n```javascript\n// index.js\nimport {render} from './comments.js';\nrender();\n\n// comments.js\nexport function render(data, target) {\n  console.log('Rendered!');\n}\n```\nto\n\n```javascript\n// Unlike the previous snippet, this bundle has only one module\n// which includes the code from both files\n// 与前面的代码不同，这个 bundle 只有一个 module，同时包含两个文件\n\n// bundle.js (part of; compiled with ModuleConcatenationPlugin)\n/* 0 */\n(function(module, __webpack_exports__, __webpack_require__) {\n\n  \"use strict\";\n  Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n\n  // CONCATENATED MODULE: ./comments.js\n  function render(data, target) {\n    console.log('Rendered!');\n  }\n\n  // CONCATENATED MODULE: ./index.js\n  render();\n\n})\n```\n看到区别了吗？在这个 bundle 中， module 0 需要 module 1 的 render 方法。使用 `ModuleConcatenationPlugin`，`require`被直接简单的替换成 require 函数，同时 module 1 被删除删除掉了。这个 bundle 拥有更少的 modules，就有更少的 modules 损耗！\n\n启用这个功能，可以在插件列表中增加`ModuleConcatenationPlugin`：\n```javascript\n// webpack.config.js\nconst webpack = require('webpack');\n\nmodule.exports = {\n  plugins: [\n    new webpack.optimize.ModuleConcatenationPlugin(),\n  ],\n};\n```\n> Note：想要知道为什么这个功能不是默认启用？Concatenating modules 很棒， [但是他会增加编译的时间同时破坏 module 的热更新](https://twitter.com/TheLarkInn/status/925800563144454144)。这就是为什么只在生产环境中启用的原因了。\n\n#### Further reading\n\n*   Webpack docs [for the ModuleConcatenationPlugin](https://webpack.js.org/plugins/module-concatenation-plugin/)\n*   [“Brief introduction to scope hoisting”](https://medium.com/webpack/brief-introduction-to-scope-hoisting-in-webpack-8435084c171f)\n*   Detailed description of [what this plugin does](https://medium.com/webpack/webpack-freelancing-log-book-week-5-7-4764be3266f5)\n\n### Use `externals` if you have both webpack and non-webpack code 如果代码中包含 webpack 和非 webpack 的代码要使用 externals\n\n你可能拥有一个体积庞大的工程，其中一部分代码可以使用 webpack 编译，而有一些代码又不能。比如一个视频网站，播放器的 widget 可能通过 webpack 编译，但是其周围页面区域可能不是：\n\n![video-hosting](https://img30.360buyimg.com/uba/jfs/t15334/148/2273118093/210074/8260a296/5a81599dN148751d5.png)\n\n如果两部分代码有相同的依赖，你可以共享这些依赖以便减少重复下载耗时。[the webpack’s `externals` option](https://webpack.js.org/configuration/externals/)就干了这件事 - 它用变量或者外部引用来替代 modules。\n\n#### 如果依赖是挂载到 window \n\n如果你的非 webpack 代码依靠这些依赖，这些依赖是挂载 window 上的变量，可以将依赖名称 alias 成变量名：\n\n```javascript\n// webpack.config.js\nmodule.exports = {\n  externals: {\n    'react': 'React',\n    'react-dom': 'ReactDOM',\n  },\n};\n```\n利用这个配置，webpack 将不会打包 `react` 和 `react-dom`包。取而代之，他们会被替换成下面这个样子：\n\n```javascript\n// bundle.js (part of)\n(function(module, exports) {\n  // A module that exports `window.React`. Without `externals`,\n  // this module would include the whole React bundle\n  module.exports = React;\n}),\n(function(module, exports) {\n  // A module that exports `window.ReactDOM`. Without `externals`,\n  // this module would include the whole ReactDOM bundle\n  module.exports = ReactDOM;\n})\n```\n#### 如果依赖是当做 AMD 包被加载\n\n如果你的非 webpack 代码没有将依赖暴露挂载到 window 上，这就更复杂了。但是如果非 webpack 代码使用 AMD 包的形式消费了这些依赖，你仍然可以避免重复的代码加载两次。\n\n具体如何做呢？将 webpack 代码编译成一个 AMD module 同时又名成一个库 URLs：\n\n```javascript\n// webpack.config.js\nmodule.exports = {\n  output: { libraryTarget: 'amd' },\n\n  externals: {\n    'react': { amd: '/libraries/react.min.js' },\n    'react-dom': { amd: '/libraries/react-dom.min.js' },\n  },\n};\n```\nWebpack 将会把 bundle 包装进 `define()`同时让它依赖于这些URLs：\n\n```javascript\n// bundle.js (beginning)\ndefine([\"/libraries/react.min.js\", \"/libraries/react-dom.min.js\"], function () { … });\n```\n如果非 webpack 代码使用相同的 URLs 加载依赖，这些文件将会加载一次 - 多余的请求会使用缓存。\n\n> Note：webpack 只是替换那些`externals`对象中的准确匹配的 keys 的引用。这意味着如果你的代码这样写`import React from 'react/umd/react.production.min.js'`，这个库是不会被 bundle 排除掉的。这是因为 - webpack 并不知道 `import 'react'` 和 `import 'react/umd/react.production.min.js'` 是同一个库，这样比较谨慎。\n\n#### Further reading\n\n*   Webpack docs [on `externals`](https://webpack.js.org/configuration/externals/)\n\n### Summing up 总结\n\n*   Minimize your code with the `UglifyJsPlugin` and loader options\n*   Remove the development-only code with the `DefinePlugin`\n*   Use ES modules to enable tree shaking\n*   Compress images\n*   Apply dependency-specific optimizations\n*   Enable module concatenation\n*   Use `externals` if this makes sense for you\n\n## Make use of long-term caching 利用好长时缓存\n\n作者 [Ivan Akulov](https://developers.google.com/web/resources/contributors/iamakulov)\n\n在做完优化应用体积之后的下一步提升应用加载时间的就是缓存。在客户端中使用缓存作为应用的一部分同时每一次减少重新下载。\n\n### Use bundle versioning and cache headers 使用 bundle 版本和缓存头信息\n\n做缓存通用的解决办法：\n1. 告诉浏览器缓存一个文件很长时间（比如一年）\n\n```\n# Server header\nCache-Control: max-age=31536000\n```\nNote：如果你不熟悉 `Cache-Control`做了什么，你可以看一下Jake Archibald 的精彩博文 [on caching best practices](https://jakearchibald.com/2016/caching-best-practices/)\n\n2.当文件改变需要强制重新下载时候去重命名这些文件\n\n```html\n<!-- Before the change -->\n<script src=\"./index-v15.js\"></script>\n\n<!-- After the change -->\n<script src=\"./index-v16.js\"></script>\n```\n这些方法告诉浏览器下载这些 JS 文件，缓存起来。浏览器将会只在文件名变化是才会请求网络（或者是缓存失效）。\n\n使用 webpack，你也可以做同样的事，但是是可以使用版本号来解决，你需要明确这个文件的 hash。使用 [`[chunkhash]`](https://webpack.js.org/configuration/output/#output-filename) 可以将 hash 值包含进文件名中：\n\n```javascript\n// webpack.config.js\nmodule.exports = {\n  entry: './index.js',\n  output: {\n    filename: 'bundle.[chunkhash].js',\n        // → bundle.8e0d62a03.js\n  },\n};\n```\n> Note: webpack 可能会生成不同的 hash 就是 bundle 相同 - 比如你重名了了一个文件或者重新在不同的操作系统下编译了一个 bundle。 [This is a bug.](https://github.com/webpack/webpack/issues/1479)\n> 如果你需要将文件名发送给客户端，也可以使用 `HtmlWebpackPlugin` 或者 `WebpackManifestPlugin`。\n\n`HtmlWebpackPlugin` 很简单，但是灵活性欠缺一些。编译时，插件会生成一个 HTML 文件，这其中包括所有的编译后的资源文件。如果你的业务逻辑不复杂，这就非常适合你：\n\n```html\n<!-- index.html -->\n<!doctype html>\n<!-- ... -->\n<script src=\"bundle.8e0d62a03.js\"></script>\n```\n`WebpackManifestPlugin`更灵活一些，它可以帮助你解决业务负责的部分。编译时它会生成一个 JSON 文件，这文件保存这没有 hash 值文件与有 hash 文件之间的映射。服务端利用这个 JSON 可以识别出那个文件有效：\n\n```json\n// manifest.json\n{\n  \"bundle.js\": \"bundle.8e0d62a03.js\"\n}\n```\n#### Further reading\n\n*   Jake Archibald [about caching best practices](https://jakearchibald.com/2016/caching-best-practices/)\n\n### Extract dependencies and runtime into a separate file 外部依赖和独立文件运行时\n\n#### Dependencies 依赖包\n\nApp 依赖通常情况下趋向于比实际 app 内代码中更少的变化。如果你将他们移到独立的文件中，浏览器将可以把他们独立缓存起来 - 同时不会每次 app 代码改变时重新下载。\n\n> Key Term: 在 webpack 的技术中，利用 app 代码拆分文件被称为 `chunks`。我们后面会用到这个名词。\n\n为了将依赖包提取到单独的 chunk 中，下面分为三步：\n\n1. 使用`[name].[chunkname].js`替换`output`的文件名：\n\n```javascript\n// webpack.config.js\nmodule.exports = {\n  output: {\n    // Before\n    filename: 'bundle.[chunkhash].js',\n    // After\n    filename: '[name].[chunkhash].js',\n  },\n};\n```\n当 webpack 构建应用时，它会用一个带有 chunk 的名称来替换`[name]`。如果没有添加`[name]`部分，我们不得不通过 chunks 之间的 hash 区别来比较他们的区别 - 那就太难了！\n\n2. 将`entry`转成一个对象：\n\n```javascript\n// webpack.config.js\nmodule.exports = {\n  // Before\n  entry: './index.js',\n  // After\n  entry: {\n    main: './index.js',\n  },\n};\n```\n在这段代码中，\"main\" 对象是一个 chunk 的名字。这个名字将会被步骤 1 里面的 `[name]`代替。目前为止，如果你构建一个 app，chunk 就会包括整个 app 的代码 - 就像我们没有做这些步骤一样。但是很快就会产生变化。\n\n3. 添加  [`CommonsChunkPlugin`](https://webpack.js.org/plugins/commons-chunk-plugin/)：\n\n\n```javascript\n// webpack.config.js\nmodule.exports = {\n  plugins: [\n    new webpack.optimize.CommonsChunkPlugin({\n      // A name of the chunk that will include the dependencies.\n      // This name is substituted in place of [name] from step 1\n      name: 'vendor',\n\n      // A function that determines which modules to include into this chunk\n      minChunks: module => module.context &&\n        module.context.includes('node_modules'),\n    }),\n  ],\n};\n```\n这个插件将包括全部`node_modules`路径下的 modules 同时将他们移到一个单独的文件中，这个文件被称为 `vendor.[chunkhash].js`。\n\n完成了上面的步骤，每一次 build 都将生成两个文件。浏览器会将他们单独缓存 - 以便代码该生改变时重新下载。\n\n\n```bash\n$ webpack\nHash: ac01483e8fec1fa70676\nVersion: webpack 3.8.1\nTime: 3816ms\n                           Asset   Size  Chunks             Chunk Names\n  ./main.00bab6fd3100008a42b0.js  82 kB       0  [emitted]  main\n./vendor.d9e134771799ecdf9483.js  47 kB       1  [emitted]  vendor\n```\n#### Webpack runtime code\n\n不幸的是，仅仅抽取`vendor`是不够的。如果你试图在应用代码中修改一些东西：\n\n```javascript\n// index.js\n…\n…\n\n// E.g. add this:\nconsole.log('Wat');\n```\n你会注意到`vendor`的 hash 值也会改变：\n\n```bash\n                           Asset   Size  Chunks             Chunk Names\n./vendor.d9e134771799ecdf9483.js  47 kB       1  [emitted]  vendor\n```\nto\n\n```bash\n                            Asset   Size  Chunks             Chunk Names\n./vendor.e6ea4504d61a1cc1c60b.js  47 kB       1  [emitted]  vendor\n```\n发生这样的事是因为 webpack 打包时，一部分 modules 的代码，拥有 [_a runtime_](https://webpack.js.org/concepts/manifest/) - 管理模块执行一部分代码。当你将代码拆分成多个文件时，这小部分代码在 chunk ids 和 匹配的文件之间开始了一个映射：\n\n```javascript\n// vendor.e6ea4504d61a1cc1c60b.js\nscript.src = __webpack_require__.p + chunkId + \".\" + {\n  \"0\": \"2f2269c7f0a55a5c1871\"\n}[chunkId] + \".js\";\n```\nWebpack 将最新生成的 chunk 包含了这个 runtime 内，这个 chunk 就是我们代码中的`vendor`。与此同时每一次任何 `chunk`的改变，这一小部分代码也改变，导致整个 `vendor` chunk 也改变、\n\n为了解决这个问题，我们将这个 runtime 转义到一个独立的文件中，通过`CommonsChunkPlugin`创建一个额外的空的 chunk：\n\n```javascript\n// webpack.config.js\nmodule.exports = {\n  plugins: [\n    new webpack.optimize.CommonsChunkPlugin({\n      name: 'vendor',\n\n      minChunks: module => module.context &&\n        module.context.includes('node_modules'),\n    }),\n\n    // This plugin must come after the vendor one (because webpack\n    // includes runtime into the last chunk)\n    new webpack.optimize.CommonsChunkPlugin({\n      name: 'runtime',\n\n      // minChunks: Infinity means that no app modules\n      // will be included into this chunk\n      minChunks: Infinity,\n    }),\n  ],\n};\n```\n完成这一部分改变，每一次 build 都将生成三个文件：\n\n```bash\n$ webpack\nHash: ac01483e8fec1fa70676\nVersion: webpack 3.8.1\nTime: 3816ms\n                            Asset     Size  Chunks             Chunk Names\n   ./main.00bab6fd3100008a42b0.js    82 kB       0  [emitted]  main\n ./vendor.26886caf15818fa82dfa.js    46 kB       1  [emitted]  vendor\n./runtime.79f17c27b335abc7aaf4.js  1.45 kB       3  [emitted]  runtime\n```\n将他们反过来顺序添加到 index.html 中，你就搞定了：\n\n```html\n<!-- index.html -->\n<script src=\"./runtime.79f17c27b335abc7aaf4.js\"></script>\n<script src=\"./vendor.26886caf15818fa82dfa.js\"></script>\n<script src=\"./main.00bab6fd3100008a42b0.js\"></script>\n```\n#### Further reading\n\n*   Webpack guide [on long term caching](https://webpack.js.org/guides/caching/)\n*   Webpack docs [about webpack runtime and manifest](https://webpack.js.org/concepts/manifest/)\n*   [“Getting the most out of the CommonsChunkPlugin”](https://medium.com/webpack/webpack-bits-getting-the-most-out-of-the-commonschunkplugin-ab389e5f318)\n\n### Inline webpack runtime to save an extra HTTP request 内联 webpack runtime 节省额外的 HTTP  请求\n\n为了做的更好，尽力把 webpack runtime 内联在 HTML 请求里。下面举例：\n\n```html\n<!-- index.html -->\n<script src=\"./runtime.79f17c27b335abc7aaf4.js\"></script>\n```\n这样做：\n\n```html\n<!-- index.html -->\n<script>\n!function(e){function n(r){if(t[r])return t[r].exports;…}} ([]);\n</script>\n```\n这个 runtime 很小，内联它可以帮助你节省 HTTP 请求（尤其对 HTTP/1 重要；但是在 HTTP/2 就没有那么重要了，但是仍能够提高效率）。\n\n下面就来看看如何做。\n\n#### 如果使用 HtmlWebpackPlugin 来生成 HTML\n\n如果使用 [`HtmlWebpackPlugin`](https://github.com/jantimon/html-webpack-plugin) 来生成 HTML 文件，[`InlineChunkWebpackPlugin`](https://github.com/rohitlodha/html-webpack-inline-chunk-plugin) 就足够了。\n\n#### 如果使用自己的定制服务逻辑来生成 HTML\n\n1. 将 runtime 名称成静态明确的文件名：\n\n```javascript\n// webpack.config.js\nmodule.exports = {\n  plugins: [\n    new webpack.optimize.CommonsChunkPlugin({\n      name: 'runtime',\n      minChunks: Infinity,\n      filename: 'runtime.js',\n        // → Now the runtime file will be called\n        // “runtime.js”, not “runtime.79f17c27b335abc7aaf4.js”\n    }),\n  ],\n};\n```\n2. 将方便的方式将 runtime.js 嵌入进去。比如：Node.js 和 Express\n\n```javascript\n// server.js\nconst fs = require('fs');\nconst runtimeContent = fs.readFileSync('./runtime.js', 'utf-8');\n\napp.get('/', (req, res) => {\n  res.send(`\n    …\n    <script>${runtimeContent}</script>\n    …\n  `);\n});\n```\n### 懒加载\n\n有时候，页面拥有或多或少的部分：\n\n* 如果你在 YouTube 上加载一个视频页面，相比评论区域你更在乎视频区域。这就是视频要比评论区域重要。\n* 如果你在一个新闻网站打开一个报道，相比广告区域你更关心文章的内容。这就是文字比广告更重要。\n\n在这些案例中，通过仅下载最重要的部分，懒加载剩余区域能够提升最初的加载性能。使用 [the `import()` function](https://webpack.js.org/api/module-methods/#import-) 和 [code-splitting](https://webpack.js.org/guides/code-splitting/) 解决这个问题：\n\n\n```javascript\n// videoPlayer.js\nexport function renderVideoPlayer() { … }\n\n// comments.js\nexport function renderComments() { … }\n\n// index.js\nimport {renderVideoPlayer} from './videoPlayer';\nrenderVideoPlayer();\n\n// …Custom event listener\nonShowCommentsClick(() => {\n  import('./comments').then((comments) => {\n    comments.renderComments();\n  });\n});\n```\n`import()`明确表示你期望动态地加载独立的 module。当 webpack 看到 `import('./module.js')`时，他就会将这个 module 移到独立的 chunk 中：\n\n```bash\n$ webpack\nHash: 39b2a53cb4e73f0dc5b2\nVersion: webpack 3.8.1\nTime: 4273ms\n                            Asset     Size  Chunks             Chunk Names\n      ./0.8ecaf182f5c85b7a8199.js  22.5 kB       0  [emitted]\n   ./main.f7e53d8e13e9a2745d6d.js    60 kB       1  [emitted]  main\n ./vendor.4f14b6326a80f4752a98.js    46 kB       2  [emitted]  vendor\n./runtime.79f17c27b335abc7aaf4.js  1.45 kB       3  [emitted]  runtime\n```\n并且只在代码执行到 `import()` 才会下载。\n\n这将会让 main bundle 更小，提升初始加载的时间。更重要的是改进缓存 - 如果你修改 main chunk 的代码，其他部分的 chunk 也不会受影响。\n\n> Note: 如果使用 Babel 编译代码，你会因为 Babel 还不认识 _import()_ 而遇到语法错误抛出来。可以使用 [`syntax-dynamic-import`](https://www.npmjs.com/package/babel-plugin-syntax-dynamic-import) 解决这个错误。\n\n#### Further reading\n\n*   Webpack docs [for the `import()` function](https://webpack.js.org/api/module-methods/#import-)\n*   The JavaScript proposal [for implementing the `import()` syntax](https://github.com/tc39/proposal-dynamic-import)\n\n### Split the code into routes and pages 拆分代码到路由和页面中\n\n如果你的应用拥有多个路由或者页面，但是代码中只有单独一个 JS 文件（一个单独的 main chunk），这看起来你正在每一个请求中节省额外的 bytes 带宽。举个例子，当用户正在访问你网站的首页：\n\n![site-home-page](https://img10.360buyimg.com/uba/jfs/t17272/291/466883786/44644/f5b82d7c/5a8159b0N4fe9f50d.png)\n\n他们并不需要加载另外不同的页面上渲染文章标题的的代码 - 但是他们还是会加载到这段代码。更严重的是如果用户经常只访问首页，同时你还经常改变渲染文章标题的代码，webpack 将会对整个 bundle 失效 - 用户每次都会重复下载全部 app 的代码。\n\n如果我们将代码拆分到页面里（或者单页面应用的路由里），用户就会下载对他有意义的代码。更好的是，浏览器也会更好地缓存代码：当你改变首页的代码时，webpack 只会让相匹配的 chunk 失效。\n\n#### For single-page apps 对于单页面应用\n\n\n通过路由拆分带页面引用，使用`import()`（看看 [“Lazy-load code that you don’t need right now”](https://developers.google.com/web/fundamentals/performance/webpack/use-long-term-caching#lazy-loading)这部分）。如果你在使用一个框架，现在已经有成熟的方案：\n\n*   [“Code Splitting”](https://reacttraining.com/react-router/web/guides/code-splitting) in `react-router`'s docs (for React)\n*   [“Lazy Loading Routes”](https://router.vuejs.org/en/advanced/lazy-loading.html) in `vue-router`'s docs (for Vue.js)\n\n#### For traditional multi-page apps 对于传统的多页面应用\n\n通过页面拆分传统多页面应用，可以使用 webpack 的 [_entry points_](https://webpack.js.org/concepts/entry-points/) 。如果你的应用有三种页面：主页、文章页、用户账户页，那就分厂三个 entries：\n\n\n```javascript\n// webpack.config.js\nmodule.exports = {\n  entry: {\n    home: './src/Home/index.js',\n    article: './src/Article/index.js',\n    profile: './src/Profile/index.js'\n  },\n};\n```\n对于每一个 entry 文件，webpack 将构建出独立的依赖树，并且声称一个 bundle，它将通过 entry 来只包括用到的 modules：\n\n```bash\n$ webpack\nHash: 318d7b8490a7382bf23b\nVersion: webpack 3.8.1\nTime: 4273ms\n                            Asset     Size  Chunks             Chunk Names\n      ./0.8ecaf182f5c85b7a8199.js  22.5 kB       0  [emitted]\n   ./home.91b9ed27366fe7e33d6a.js    18 kB       1  [emitted]  home\n./article.87a128755b16ac3294fd.js    32 kB       2  [emitted]  article\n./profile.de945dc02685f6166781.js    24 kB       3  [emitted]  profile\n ./vendor.4f14b6326a80f4752a98.js    46 kB       4  [emitted]  vendor\n./runtime.318d7b8490a7382bf23b.js  1.45 kB       5  [emitted]  runtime\n```\n 因此，如果仅仅是文章页使用_Lodash_，_home_ 和 _profile_ 的 bundle 将不会包含 lodash - 同时用户也不会在访问首页的时候下载到这个库。\n\n拆分依赖树也有缺点。如果两个 entry points 都用到了_loadash_，同时你没有在 _vendor_ 移除掉依赖，两个 entry points 将包括两个重复的_lodash_。我们使用[`CommonsChunkPlugin`](https://webpack.js.org/plugins/commons-chunk-plugin/)解决这个问题 - 它会将通用的依赖转移到一个独立的文件中：\n\n```javascript\n// webpack.config.js\nmodule.exports = {\n  plugins: [\n    new webpack.optimize.CommonsChunkPlugin({\n      // A name of the chunk that will include the common dependencies\n      name: 'common',\n\n      // The plugin will move a module into a common file\n      // only if it’s included into `minChunks` chunks\n      // (Note that the plugin analyzes all chunks, not only entries)\n      minChunks: 2,    // 2 is the default value\n    }),\n  ],\n};\n```\n随意使用`minChunks`的值来找到最优的选项。通常情况下，你想要它尽可能体积小，但它会增加 chunks 的数量。举个例子，3 个 chunk，`minChunks` 可能是 2 个，但是 30 个 chunk，它可能是 8 个 - 因为如果你把它设置成 2 ，过多的 modules 将会打包进一个通用文件中，文件更臃肿。\n\n#### Further reading\n\n*   Webpack docs [about the concept of entry points](https://webpack.js.org/concepts/entry-points/)\n*   Webpack docs [about the CommonsChunkPlugin](https://webpack.js.org/plugins/commons-chunk-plugin/)\n*   [“Getting the most out of the CommonsChunkPlugin”](https://medium.com/webpack/webpack-bits-getting-the-most-out-of-the-commonschunkplugin-ab389e5f318)\n\n### Make module ids more stable 让 module ide 更稳定\n\n当编译代码时，webpack 会分配给每一个 module 一个 ID。之后，这些 ID 就会被`require()`引用到 bundle 内部。你可以在编译输出的右侧在 moudle 路径之前看到这些 ID：\n\n\n```bash\n$ webpack\nHash: df3474e4f76528e3bbc9\nVersion: webpack 3.8.1\nTime: 2150ms\n                           Asset      Size  Chunks             Chunk Names\n      ./0.8ecaf182f5c85b7a8199.js  22.5 kB       0  [emitted]\n   ./main.4e50a16675574df6a9e9.js    60 kB       1  [emitted]  main\n ./vendor.26886caf15818fa82dfa.js    46 kB       2  [emitted]  vendor\n./runtime.79f17c27b335abc7aaf4.js  1.45 kB       3  [emitted]  runtime\n```\nhere\n\n```bash\n   [0] ./index.js 29 kB {1} [built]\n   [2] (webpack)/buildin/global.js 488 bytes {2} [built]\n   [3] (webpack)/buildin/module.js 495 bytes {2} [built]\n   [4] ./comments.js 58 kB {0} [built]\n   [5] ./ads.js 74 kB {1} [built]\n    + 1 hidden module\n```\n默认情况下，这些 ID 是使用计数器计算出来的（比如第一个 module 是 ID 0，第二个 moudle 就是 ID 1，以此类推）。这样的问题就在于当你新增一个 module 事，它会出现在原来 module 列表中的中间，改变后面所有 module 的 ID：\n\n\n```bash\n$ webpack\nHash: df3474e4f76528e3bbc9\nVersion: webpack 3.8.1\nTime: 2150ms\n                           Asset      Size  Chunks             Chunk Names\n      ./0.5c82c0f337fcb22672b5.js    22 kB       0  [emitted]\n   ./main.0c8b617dfc40c2827ae3.js    82 kB       1  [emitted]  main\n ./vendor.26886caf15818fa82dfa.js    46 kB       2  [emitted]  vendor\n./runtime.79f17c27b335abc7aaf4.js  1.45 kB       3  [emitted]  runtime\n   [0] ./index.js 29 kB {1} [built]\n   [2] (webpack)/buildin/global.js 488 bytes {2} [built]\n   [3] (webpack)/buildin/module.js 495 bytes {2} [built]\n```\n↓ 我们增加一个新 module\n\n```bash\n[4] ./webPlayer.js 24 kB {1} [built]\n```\n↓ 现在看这里做了什么！`comments.js`现在的 ID 由 4 变成了 5\n\n```bash\n[5] ./comments.js 58 kB {0} [built]\n```\n↓ `ads.js` 的 ID 由 5 变成 6\n\n```bash\n[6] ./ads.js 74 kB {1} [built]\n       + 1 hidden module\n```\n这将使包含或依赖于具有更改ID的模块的所有块无效 - 即使它们的实际代码没有更改。在我们的代码中，_0_这个 chunk 和 _main_ chunk 都会失效 - 只有_main_才应该失效。\n\n使用[`HashedModuleIdsPlugin`](https://webpack.js.org/plugins/hashed-module-ids-plugin/)插件改变module ID 如何计算来解决这个问题。它利用 module 路径的 hash 来替换掉计数器：\n\n```bash\n$ webpack\nHash: df3474e4f76528e3bbc9\nVersion: webpack 3.8.1\nTime: 2150ms\n                           Asset      Size  Chunks             Chunk Names\n      ./0.6168aaac8461862eab7a.js  22.5 kB       0  [emitted]\n   ./main.a2e49a279552980e3b91.js    60 kB       1  [emitted]  main\n ./vendor.ff9f7ea865884e6a84c8.js    46 kB       2  [emitted]  vendor\n./runtime.25f5d0204e4f77fa57a1.js  1.45 kB       3  [emitted]  runtime\n```\n↓ Here\n\n```bash\n[3IRH] ./index.js 29 kB {1} [built]\n[DuR2] (webpack)/buildin/global.js 488 bytes {2} [built]\n[JkW7] (webpack)/buildin/module.js 495 bytes {2} [built]\n[LbCc] ./webPlayer.js 24 kB {1} [built]\n[lebJ] ./comments.js 58 kB {0} [built]\n[02Tr] ./ads.js 74 kB {1} [built]\n    + 1 hidden module\n```\n有了这个方法，只有你重命名护着删除这个 moudle 它的 ID 才会变化。新的 modules 不会因为 module ID 互相影响。\n\n启用这个插件，在配置中增加 _plugins_：\n\n```javascript\n// webpack.config.js\nmodule.exports = {\n  plugins: [\n    new webpack.HashedModuleIdsPlugin(),\n  ],\n};\n```\n#### Further reading\n\n*   Webpack docs [about the HashedModuleIdsPlugin](https://webpack.js.org/plugins/hashed-module-ids-plugin/)\n\n### Summing up\n\n*   Cache the bundle and differentiate between them by changing their names\n*   Split the bundle into app code, vendor code and runtime\n*   Inline the runtime to save an HTTP request\n*   Lazy-load non-critical code with `import`\n*   Split code by routes/pages to avoid loading unnecessary stuff\n\n===\n\n## Monitor and analyze the app 监控并分析\n\n作者 [Ivan Akulov](https://developers.google.com/web/resources/contributors/iamakulov)\n\n即使当你配置好你的 webpack 让你的引用尽可能体积较小的时候，跟踪这个应用就非常重要，同时了解里面包含了什么。除此之外，你安装一个依赖，它将让你的 app 增加两倍大小 - 但并没有注意到这个问题！\n\n这一部分就来讲解一些能够帮助你理解你的 bundle 的工具。\n\n### Keep track of the bundle size 跟踪打包的体积\n\n在开发时可以使用[webpack-dashboard](https://github.com/FormidableLabs/webpack-dashboard/)和命令行[bundlesize](https://github.com/siddharthkp/bundlesize) 来监控 app 的体积。\n\n#### webpack-dashboard\n\n[webpack-dashboard](https://github.com/FormidableLabs/webpack-dashboard/)可以通过依赖体积大小、进程和其他细节来改进 webpack 的输出。\n\n![webpack-dashboard](http://img30.360buyimg.com/uba/jfs/t16294/169/2125639991/38263/ad862ba/5a8159c0N0da38a60.png)\n\n这个 dashborad 帮助我们跟踪大型依赖 - 如果你增加一个依赖，你就立刻能在 Modules section 始终看到它！\n\n启用这个功能，需要安装 _webpack-dashboard_ 包：\n\n```bash\nnpm install webpack-dashboard --save-dev\n```\n 同时在配置的 plugins 增加：\n\n```javascript\n// webpack.config.js\nconst DashboardPlugin = require('webpack-dashboard/plugin');\n\nmodule.exports = {\n  plugins: [\n    new DashboardPlugin(),\n  ],\n};\n```\n或者如果正在使用基于 Express dev server 可以使用 `compiler.apply()`：\n\n```bash\ncompiler.apply(new DashboardPlugin());\n```\n多尝试 dashboard 找出改进的地方！比如，在 modules section 滚动找到那个库体积过大，把它替换成小的可替代的库。\n\n#### bundlesize\n\n[bundlesize](https://github.com/siddharthkp/bundlesize) 可以验证 webpack assets 不超过指定的大小。通过自动化 CI 就可以知晓 app 是否变的过于臃肿：\n\n![bundlesize](https://img30.360buyimg.com/uba/jfs/t15808/165/2111159728/110001/633e93ab/5a8159cdN1c575a1f.jpg)\n\n配置如下：\n\n##### **Find out the maximum sizes** 找出最大体积\n\n1. 分析 app 尽可能减小体积，执行生产环境的 build。\n2. 在`package.json`中增加`bundlesize`部分：\n\n```json\n// package.json\n{\n  \"bundlesize\": [\n    {\n      \"path\": \"./dist/*\"\n    }\n  ]\n}\n```\n3. 使用`npx`执行`bundlesize`：\n\n```bash\nnpx bundlesize\n```\n它就会将每一个文件的 gzip 压缩后的体积打印出来：\n\n```bash\nPASS  ./dist/icon256.6168aaac8461862eab7a.png:  10.89KB PASS./dist/icon512.c3e073a4100bd0c28a86.png:  13.1KB PASS./dist/main.0c8b617dfc40c2827ae3.js:  16.28KB PASS./dist/vendor.ff9f7ea865884e6a84c8.js:  31.49KB\n```\n4. 每一个体积增加10-20%，你将得到最大体积。这个10-20％的幅度可以让你像往常一样开发应用程序，同时警告你，当它的大小增长太多。\n\n##### **Enable `bundlesize`** 启用 bundlesize\n\n5.安装_bundlesize_开发依赖\n\n```bash\nnpm install bundlesize --save-dev\n```\n6.在`package.json`中的`bundlesize`部分，声明具体的最大值。对于某一些文件（比如图片），你可以单独根据文件类型来设置最大体积大小，而不需要根据每一个文件：\n\n\n```json\n// package.json\n{\n  \"bundlesize\": [\n    {\n      \"path\": \"./dist/*.png\",\n      \"maxSize\": \"16 kB\",\n    },\n    {\n      \"path\": \"./dist/main.*.js\",\n      \"maxSize\": \"20 kB\",\n    },\n    {\n      \"path\": \"./dist/vendor.*.js\",\n      \"maxSize\": \"35 kB\",\n    }\n  ]\n}\n```\n7.增加一个 npm 脚本来执行检查：\n\n```json\n// package.json\n{\n  \"scripts\": {\n    \"check-size\": \"bundlesize\"\n  }\n}\n```\n8.配置自动化 CI 来在每一次 push 时执行`npm run check-size`做检查。（如果你在 Github 上开发项目，直接可以使用[integrate `bundlesize` with GitHub](https://github.com/siddharthkp/bundlesize#2-build-status)。）\n\n这就全部了！现在如果你运行`npm run check-size`或者 push 代码，你就会看到输出的文件是否足够小：\n\n![bundlesize-output-success](https://img14.360buyimg.com/uba/jfs/t14890/146/2205111432/17457/fa7f748a/5a8159dcN17378d16.png)\n\n或者下面失败的情况\n\n![bundlesize-output-failure](https://img11.360buyimg.com/uba/jfs/t16969/198/453213154/26368/834a1c7f/5a8159e8Nc1f5ffe8.png)\n\n#### Further reading\n\n*   Alex Russell [about the real-world loading time we should target](https://infrequently.org/2017/10/can-you-afford-it-real-world-web-performance-budgets/)\n\n### Analyze why the bundle is so large 分析 bundle 为什么这么大\n\n你想要深挖 bundle 内，看看里面具体哪些 module 占用多大空间。[webpack-bundle-analyzer](https://github.com/webpack-contrib/webpack-bundle-analyzer)\n\n(Screen recording from [github.com/webpack-contrib/webpack -bundle-analyzer](https://github.com/webpack-contrib/webpack-bundle-analyzer))\n\nwebpack-bundle-analyzer 可以扫描 bundle 同时构建一个查看内部的可视化窗口。使用这个可视化工具找到过大或者不必要的依赖。\n\n使用这个分析器，需要安装`webpack-bundle-analyzer`包：\n\n```bash\nnpm install webpack-bundle-analyzer --save-dev\n```\n在 config 中增加插件：\n\n```javascript\n// webpack.config.js\nconst BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;\n\nmodule.exports = {\n  plugins: [\n    new BundleAnalyzerPlugin(),\n  ],\n};\n```\n运行生产环境的 build。这个插件就会在浏览器中打开一个显示状态的页面。\n\n默认情况下，这个页面会显示语法分析后的文件体积（在 bundle 出现的文件）。您可能想比较 gzip 的大小，因为这更接近实际用户的体验；使用左边的边栏来切换尺寸。\n\n> Note: 如果你使用 [ModuleConcatenationPlugin](https://webpack.js.org/plugins/module-concatenation-plugin/)，它可能在webpack-bundle-analyzer输出时合并一部分 module，使得报告小一些细节。如果你使用这个插件，在执行分析的时候需要禁用掉。\n\n下面是报告中需要看什么：\n\n* **大型依赖** 为什么体积这么大？是否有更小的替代包（比如 Preact 替代 React）？用了全部代码（比如 Moment.js 包含大量的本地变量 [that are often not used and could be dropped](https://github.com/GoogleChromeLabs/webpack-libs-optimizations#moment)）？\n* **重复依赖** 是否在不同文件中看到相同的库？（使用_CommonsChunkPlugin_将他们移到一个通用文件内）亦或是在同一个库中 bundle 拥有多个版本？\n* **相似依赖** 是否存在有相似功能的相似库存在？（比如_moment_和_date-fns_ 或者 _lodash_ 和 _lodash-es_）尽力汇总成一个。\n\n同样的，也可以看看 Sean Larkin 的文章 [great analysis of webpack bundles](https://medium.com/webpack/webpack-bits-getting-the-most-out-of-the-commonschunkplugin-ab389e5f318)。\n\n### Summing up\n\n*   Use `webpack-dashboard` and `bundlesize` to stay tuned of how large your app is\n*   Dig into what builds up the size with `webpack-bundle-analyzer`\n\n===\n## Conclusion结尾\n\n总结一下：\n\n* **剔除不必要的体积** 把所有的都压缩，剔除无用代码，增加依赖是保持谨慎小心。\n* **通过路由拆分代码** 只在真正需要的时候才加载，其他的部分做来加载。\n* **缓存代码** 应用程序的某些部分更新频率低于其他部分，将这些部分拆分成文件，以便在必要时仅重新下载。\n* **跟踪体积大小** 使用  [webpack-dashboard](https://github.com/FormidableLabs/webpack-dashboard/) 和 [webpack-bundle-analyzer](https://github.com/webpack-contrib/webpack-bundle-analyzer) 监控你的 app。每隔几个月重新检查一下你的应用的性能。\n\nWebpack 不仅仅是一个帮助你创建 app 更快的工具。它还帮助是你的 app 成为 [a Progressive Web App](https://developers.google.com/web/progressive-web-apps/) ，你的引用拥有更好的体检自动化的填充工具就像[Lighthouse](https://developers.google.com/web/tools/lighthouse/)根据环境给出建议。\n\n不要忘记阅读 [webpack docs](https://webpack.js.org/guides/) - 里面提供了大量的优化的信息。\n\n记得练习一下 [with the training app](https://github.com/GoogleChromeLabs/webpack-training-project)！","source":"_drafts/2018-02-11-blog-translate-web-performance-optimization-with-webpack-from-google.md","raw":"【译】Google出品 - 利用 webpack 做 web 性能优化\n\n===\n\n2018-02-11 Beanlee\n\n原文 https://developers.google.com/web/fundamentals/performance/webpack/\n\n作者 Addy Osmani\n\n## Instroduction 介绍\n\n现代 Web 应用经常用到`bunding tool`用于创建一个生产环境的打包文件（例如脚本、样式等），这个打包文件是已经优化完，并且最小化完成的，并且能够被用户用更少的时间下载到。在这篇文章中，我们将会利用`webpack`来贯穿如何优化网站资源。这样可以帮助用户对于你的网站得到更快地加载和体验。\n\n![webpack-logo](https://img20.360buyimg.com/uba/jfs/t15217/149/2229580840/12989/54324b99/5a815957N5bb3e0c6.png)\n\nwebpack 目前是最流行的打包工具之一，深入地利用他的特点去优化代码，拆分脚本成重要和非重要部分还有剔除无用的代码能够保证你的引用有最小的带宽和进程消耗。\n\n![code-splitting](https://img14.360buyimg.com/uba/jfs/t17569/325/476871633/18187/a1e34f41/5a81597fNd77bb5b8.png)\n\n> Note: 我们创建了一个练习用的引用来演示优化的描述。尽力挤出最多的时间来练习这些 tips [`webpack-training-project`](https://github.com/GoogleChromeLabs/webpack-training-project)\n\n让我们从现代 web 应用中最耗费资源之一的 `Javascript`开始。\n\n- 减小前端体积\n- 利用长期缓存\n- 监控并分析应用\n- 结尾\n\n===\n\n## Decrease Front-end Size 减少前端体积\n\n作者 [Ivan Akulov](https://developers.google.com/web/resources/contributors/iamakulov)\n\n当你正在优化一个应用时最初第一件事就是尽可能地让它体积减小。下面就是利用 webpack 如何做。\n\n### Enable minification 启用最小化\n\n最小化是通过去除多余空格、缩短变量名等方式压缩代码。例如：\n\n```javascript\n// Original code\nfunction map(array, iteratee) {\n  let index = -1;\n  const length = array == null ? 0 : array.length;\n  const result = new Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n```\nto\n\n```javascript\n// Minified code\nfunction map(n,r){let t=-1;for(const a=null==n?0:n.length,l=Array(a);++t<a;)l[t]=r(n[t],t,n);return l}\n```\nWebpack 支持两种方式最小化代码：UglifyJS 插件和_loader-specific options_。他们可以同时使用。\n\n[The UglifyJS plugin](https://github.com/webpack-contrib/uglifyjs-webpack-plugin)在 bundle 层级中起作用，在编译之后压缩 bundle。下面来展示如何工作：\n\n\n1. 你的代码：\n\n```javascript\n// comments.js\nimport './comments.css';\nexport function render(data, target) {\n  console.log('Rendered!');\n}\n```\n2. Webpack 打包大致成如下：\n\n```javascript\n// bundle.js (part of)\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony export (immutable) */ __webpack_exports__[\"render\"] = render;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__comments_css__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__comments_css_js___default =\n__webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__comments_css__);\n\nfunction render(data, target) {\n  console.log('Rendered!');\n}\n```\n3. 使用 UglifyJS 插件大致编译成如下：\n\n```javascript\n// minified bundle.js (part of)\n\"use strict\";function t(e,n){console.log(\"Rendered!\")}\nObject.defineProperty(n,\"__esModule\",{value:!0}),n.render=t;var o=r(1);r.n(o)\n```\n插件集成在 webpack 中，把它的配置在`plugins`中就可以启用：\n\n```javascript\n// webpack.config.js\nconst webpack = require('webpack');\n\nmodule.exports = {\n  plugins: [\n    new webpack.optimize.UglifyJsPlugin(),\n  ],\n};\n```\n第二种方式_loader-specific options_ 利用 loader options，可以压缩 Uglify 插件无法最小化的部分。举例，当你利用`css-loader`引入一个 CSS 文件时，文件会编译成一个字符串：\n\n```css\n/* comments.css */\n.comment {\n  color: black;\n}\n```\nto\n\n```javascript\n// minified bundle.js (part of)\nexports=module.exports=__webpack_require__(1)(),\nexports.push([module.i,\".comment {\\r\\n  color: black;\\r\\n}\",\"\"]);\n```\nUglifyJS 由于这是一个字符串不能压缩这段代码。要最小化这个 css 文件内容，我们需要配置 _loader_\n\n```javascript\n// webpack.config.js\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\n          'style-loader',\n          { loader: 'css-loader', options: { minimize: true } },\n        ],\n      },\n    ],\n  },\n};\n```\n**{ minimize: true }**\n\n> Note: UglifyJS 插件不能编译 ES2015+(ES2016)，这意味着如果你的 diamante 中使用类、箭头函数和一些新特性语法，不能编译成 ES5，插件会抛异常。\n> 如果需要编译新语法，要使用 [uglifyjs-webpack-plugin](https://github.com/webpack-contrib/uglifyjs-webpack-plugin) 包。也是集成在 webpack 中相同的插件，但是更新一些，能够有能力编译 ES2015+。\n\n#### Further reading\n\n* [The UglifyJsPlugin docs](https://github.com/webpack-contrib/uglifyjs-webpack-plugin)\n* Other popular minifiers: [Babel Minify](https://github.com/webpack-contrib/babel-minify-webpack-plugin), [Google Closure Compiler](https://github.com/roman01la/webpack-closure-compiler)\n\n### Specify `NODE_ENV=production` 明确生产环境信息\n\n减小前端体积的另外一个方法就是在代码中将`NODE_ENV`[环境变量](https://superuser.com/questions/284342/what-are-path-and-other-environment-variables-and-how-can-i-set-or-use-them)设置成`production`。\n\nLibraries 会读取`NODE_ENV`变量判断他们应该在那种模式下工作 - 开发模式 or 生成模式。很多库会基于这个变量有不同的表现。举个例子，当`NODE_ENV`没有设置成`production`，Vue.js 会做额外的检查并且输出一些警告：\n\n\n```javascript\n// vue/dist/vue.runtime.esm.js\n// …\nif (process.env.NODE_ENV !== 'production') {\n  warn('props must be strings when using array syntax.');\n}\n// …\n```\nReact 也是类似 - 开发模式下 build 带有一些警告：\n\n```javascript\n// react/index.js\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react.production.min.js');\n} else {\n  module.exports = require('./cjs/react.development.js');\n}\n\n// react/cjs/react.development.js\n// …\nwarning$3(\n  componentClass.getDefaultProps.isReactClassApproved,\n  'getDefaultProps is only used on classic React.createClass ' +\n  'definitions. Use a static property named `defaultProps` instead.'\n);\n// …\n```\n这些检查和警告通常在生产环境下不必要的，但是他们仍然保留在代码中并且会增加库的体积。通过配置 webpack 的 [`DefinePlugin`](https://webpack.js.org/plugins/define-plugin/) 来删除他们：\n\n```javascript\n // webpack.config.js\nconst webpack = require('webpack');\n\nmodule.exports = {\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.env.NODE_ENV': '\"production\"',\n    }),\n    new webpack.optimize.UglifyJsPlugin(),\n  ],\n};\n```\n`DefinePlugin`用确定的变量替换所有存在的说明变量。利用下面配置：\n\n1. `DefinePlugin`将用`\"production\"`替换到`process.env.NODE_ENV`：\n\n```javascript\n// vue/dist/vue.runtime.esm.js\nif (typeof val === 'string') {\n  name = camelize(val);\n  res[name] = { type: null };\n} else if (process.env.NODE_ENV !== 'production') {\n  warn('props must be strings when using array syntax.');\n}\n```\nto\n\n```javascript\n// vue/dist/vue.runtime.esm.js\nif (typeof val === 'string') {\n  name = camelize(val);\n  res[name] = { type: null };\n} else if (\"production\" !== 'production') {\n  warn('props must be strings when using array syntax.');\n}\n```\n> Note: 如果你偏向有通过 CLI 配置变量，可以查看一下 [EnvironmentPlugin](https://webpack.js.org/plugins/environment-plugin/)。它和`DefinePlugin`类似，但读环境并且自动替换`process.env`表达式。\n\n2.`UglifyJS`会移除掉所有`if`分支 - 因为`\"production\" !== 'production'`永远返回 false ，插件理解代码内的判断分支将永远不会执行：\n\n```javascript\n// vue/dist/vue.runtime.esm.js\nif (typeof val === 'string') {\n  name = camelize(val);\n  res[name] = { type: null };\n} else if (\"production\" !== 'production') {\n  warn('props must be strings when using array syntax.');\n}\n```\nto\n\n```javascript\n// vue/dist/vue.runtime.esm.js (without minification)\nif (typeof val === 'string') {\n  name = camelize(val);\n  res[name] = { type: null };\n}\n```\n> Note: 不一定强制要求使用 `UglifyJSPlugin`。你可以使用其他不同的最小化工具，这些页支持移除无用代码（例如，the [Babel Minify plugin](https://github.com/webpack-contrib/babel-minify-webpack-plugin) or the [Google Closure Compiler plugin](https://github.com/roman01la/webpack-closure-compiler)）\n\n#### Further Reading\n\n*   [What “environment variables” are](https://superuser.com/questions/284342/what-are-path-and-other-environment-variables-and-how-can-i-set-or-use-them)\n*   Webpack docs about: [`DefinePlugin`](https://webpack.js.org/plugins/define-plugin/), [`EnvironmentPlugin`](https://webpack.js.org/plugins/environment-plugin/)\n\n### Use ES Modules 使用 ES 模块\n\n下面这个方式利用 [ES modules](https://ponyfoo.com/articles/es6-modules-in-depth) 减小前端体积。\n\n当你使用 ES module，webpack 有能力去做 tree-shaking。Tree-shaking 贯穿整个依赖树，检查那些依赖被使用，移除无用依赖。因此，如果你使用 ES module 语法，webpack 可以排除掉无用代码：\n1. 一个有多个 export 的文件，但是 app 只需要其中一个：\n\n```javascript\n// comments.js\nexport const render = () => { return 'Rendered!'; };\nexport const commentRestEndpoint = '/rest/comments';\n\n// index.js\nimport { render } from './comments.js';\nrender();\n```\n2. webpack 理解 `commentRestEndPoint`没有使用，同时不能在一个 bundle 中生成单独的 export：\n\n```javascript\n// bundle.js (part that corresponds to comments.js)\n(function(module, __webpack_exports__, __webpack_require__) {\n  \"use strict\";\n  const render = () => { return 'Rendered!'; };\n  /* harmony export (immutable) */ __webpack_exports__[\"a\"] = render;\n\n  const commentRestEndpoint = '/rest/comments';\n  /* unused harmony export commentRestEndpoint */\n})\n```\n3. `UglifyJSPlugin`移除无用变量：\n\n```javascript\n// bundle.js (part that corresponds to comments.js)\n(function(n,e){\"use strict\";var r=function(){return\"Rendered!\"};e.b=r})\n```\n如果他们都是有 ES module 编写，就是与一些库并存时也是生效的。\n\n> Note: 在 webpack 中，tree-shaking 没有 minifier 是无法生效的。 webpack 仅仅移除了没有被用到的 export 变量；`UglifyJSPlugin`才会移除无用代码。所以如果你编译打包时没有使用 minifier，打包后体积并不会更小。你也可以不一定使用这个插件。其他最小化的插件也支持移除 dead code（例如：[Babel Minify plugin](https://github.com/webpack-contrib/babel-minify-webpack-plugin) or [Google Closure Compiler plugin](https://github.com/roman01la/webpack-closure-compiler)）\n\n> Warning: 不要将 ES module 编译到 CommonJS 中。 如果你使用 Babel `babel-preset-env` or `babel-preset-es2015`，检查一下当前的配置。默认情况下， ES `import` and `export` to CommonJS `require` and `module.exports`。通过设置 option 来禁止掉[Pass the `{ modules: false }` option](https://github.com/babel/babel/tree/master/experimental/babel-preset-env)。\n\n\n#### Futher reading\n\n*   [“ES6 Modules in depth”](https://ponyfoo.com/articles/es6-modules-in-depth)\n*   Webpack docs [about tree shaking](https://webpack.js.org/guides/tree-shaking/)\n\n### Optimize images 优化图片\n\n图片基本会占局页面一半以上体积。虽然它们不像 JavaScript 那么重要（比如它们不会阻止页面渲染），但图片仍然会占用掉一大部分带宽。利用`url-loader`，`svg-url-loader`和`image-webpack-loader`来在 webpack 中进行优化。\n\n`url-loader` 允许将小静态文件打包进 app。没有配置，他需要通过 file，将它放在编译后的打包 bundle 内并返回一个这个文件的 url。然而，如果我们注明`limit`选项，它将会 encode 成更小的文件 base64 文件 url。这是可以将图片放在Javascript 代码中，同时节省 HTTP 请求：\n\n```javascript\n// webpack.config.js\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.(jpe?g|png|gif)$/,\n        loader: 'url-loader',\n        options: {\n          // Inline files smaller than 10 kB (10240 bytes)\n          limit: 10 * 1024,\n        },\n      },\n    ],\n  }\n};\n```\n\n```javascript\n// index.js\nimport imageUrl from './image.png';\n// → If image.png is smaller than 10 kB, `imageUrl` will include\n// the encoded image: 'data:image/png;base64,iVBORw0KGg…'\n// → If image.png is larger than 10 kB, the loader will create a new file,\n// and `imageUrl` will include its url: `/2fcd56a1920be.png`\n```\n> Note: 内联图片减少了独立请求的数量，这是很好的方式（[even with HTTP/2](https://blog.octo.com/en/http2-arrives-but-sprite-sets-aint-no-dead/)），但是会增加 bundle下载和转换的时间和内存的消耗。一定要确保不要嵌入超大图片或者较多的图片 - 否则增加的 bundle 的时间将会掩盖做成内联图片的收益。\n\n`svg-url-loader`与`url-loader`类似 - 都是将使用 [URL encoding](https://developer.mozilla.org/en-US/docs/Glossary/percent-encoding)  encode 文件。这对对于 SVG 图片很奏效 - 因为 SVG 文件是文本，encoding 在体积上更有效率：\n\n```javascript\n// webpack.config.js\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.svg$/,\n        loader: 'svg-url-loader',\n        options: {\n          // Inline files smaller than 10 kB (10240 bytes)\n          limit: 10 * 1024,\n          // Remove the quotes from the url\n          // (they’re unnecessary in most cases)\n          noquotes: true,\n        },\n      },\n    ],\n  },\n};\n```\n> Note: svg-url-loader 拥有改善 IE 浏览器支持的 options，但是在其他浏览器中更糟糕。如果你需要兼容 IE 浏览器，[设置 iesafe: true 选项](https://github.com/bhovhannes/svg-url-loader#iesafe)\n\n`image-webpack-loader`压缩图片使之变小。它支持 JPG，PNG，GIF 和 SVG，因为我们将会使用它所有类型。\n\n这个 loader 不会将图片嵌入在应用内，因此它必须与`url-loader`和`svg-url-loader`配合使用。避免复制粘贴到相同的 rules 中（一个用于 JPG/PNG/GIF 图片，另一个用于 SVG 图片），我们来使用`enforce: pre`作为单独的一个 rule 涵盖这个 loader：\n\n```javascript\n// webpack.config.js\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.(jpe?g|png|gif|svg)$/,\n        loader: 'image-webpack-loader',\n        // This will apply the loader before the other ones\n        enforce: 'pre',\n      },\n    ],\n  },\n};\n```\n默认 loader 的设置就已经可以了 - 但是如果你想要更深入的配置，查看 [the plugin options](https://github.com/tcoopman/image-webpack-loader#options)。为了选择哪些 options 需要明确，可以查看 Addy Osmani 的 [guide on image optimization](https://images.guide/)\n\n#### Further reading\n\n*   [\"What is base64 encoding used for?\"](https://stackoverflow.com/questions/201479/what-is-base-64-encoding-used-for)\n*   Addy Osmani’s [guide on image optimization](https://images.guide/)\n\n### Optimize dependencies 优化依赖\n\n平均一半以上的 Javascript 体积大小来源于依赖包，并且这些可能都不是必要的。\n\n举一个例子来说，Lodash（v4.17.4）增加了最小化代码的 72KB 大小到 bundle 中。但是如果你仅仅用到它的20个方法，大于 65 KB 没有用处。\n\n另外一个例子就是 Moment.js。 V2.19.1版本最小化后有 223KB，体积巨大 - 截至2017年10月一个页面内的 Javascript 平均体积是 452KB。但是，本地文件的体积占 170KB。如果你没有用到 多语言版 Moment.js，这些文件都会没有目的地使 bundle 更臃肿。\n\n所有这些依赖都可以被轻易优化。我们在 Github repo 手机了优化的建议，[check it out](https://github.com/GoogleChromeLabs/webpack-libs-optimizations)！\n\n### Enable module concatenation for ES modules (aka scope hoisting)\n\n当你构建一个 bundle 时，webpack 将每一个 module 封装进 function 中：\n\n```javascript\n// index.js\nimport {render} from './comments.js';\nrender();\n\n// comments.js\nexport function render(data, target) {\n  console.log('Rendered!');\n}\n```\nto\n\n```javascript\n// bundle.js (part  of)\n/* 0 */\n(function(module, __webpack_exports__, __webpack_require__) {\n\n  \"use strict\";\n  Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n  var __WEBPACK_IMPORTED_MODULE_0__comments_js__ = __webpack_require__(1);\n  Object(__WEBPACK_IMPORTED_MODULE_0__comments_js__[\"a\" /* render */])();\n\n}),\n/* 1 */\n(function(module, __webpack_exports__, __webpack_require__) {\n\n  \"use strict\";\n  __webpack_exports__[\"a\"] = render;\n  function render(data, target) {\n    console.log('Rendered!');\n  }\n\n})\n```\n在以前，这是使 CommonJS/AMD modules 互相分离所必须的。但是，这回增加体积同时性能堪忧。\n\nWebpack 2 介绍了 ES modules 的支持，不像 CommonJS 和 AMD modules 一样，而是能够不用将每一个 module 用 function 封装起来。同时 Webpack 3 利用[`ModuleConcatenationPlugin`](https://webpack.js.org/plugins/module-concatenation-plugin/)完成这样一个 bundle，下面是例子：\n\n```javascript\n// index.js\nimport {render} from './comments.js';\nrender();\n\n// comments.js\nexport function render(data, target) {\n  console.log('Rendered!');\n}\n```\nto\n\n```javascript\n// Unlike the previous snippet, this bundle has only one module\n// which includes the code from both files\n// 与前面的代码不同，这个 bundle 只有一个 module，同时包含两个文件\n\n// bundle.js (part of; compiled with ModuleConcatenationPlugin)\n/* 0 */\n(function(module, __webpack_exports__, __webpack_require__) {\n\n  \"use strict\";\n  Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n\n  // CONCATENATED MODULE: ./comments.js\n  function render(data, target) {\n    console.log('Rendered!');\n  }\n\n  // CONCATENATED MODULE: ./index.js\n  render();\n\n})\n```\n看到区别了吗？在这个 bundle 中， module 0 需要 module 1 的 render 方法。使用 `ModuleConcatenationPlugin`，`require`被直接简单的替换成 require 函数，同时 module 1 被删除删除掉了。这个 bundle 拥有更少的 modules，就有更少的 modules 损耗！\n\n启用这个功能，可以在插件列表中增加`ModuleConcatenationPlugin`：\n```javascript\n// webpack.config.js\nconst webpack = require('webpack');\n\nmodule.exports = {\n  plugins: [\n    new webpack.optimize.ModuleConcatenationPlugin(),\n  ],\n};\n```\n> Note：想要知道为什么这个功能不是默认启用？Concatenating modules 很棒， [但是他会增加编译的时间同时破坏 module 的热更新](https://twitter.com/TheLarkInn/status/925800563144454144)。这就是为什么只在生产环境中启用的原因了。\n\n#### Further reading\n\n*   Webpack docs [for the ModuleConcatenationPlugin](https://webpack.js.org/plugins/module-concatenation-plugin/)\n*   [“Brief introduction to scope hoisting”](https://medium.com/webpack/brief-introduction-to-scope-hoisting-in-webpack-8435084c171f)\n*   Detailed description of [what this plugin does](https://medium.com/webpack/webpack-freelancing-log-book-week-5-7-4764be3266f5)\n\n### Use `externals` if you have both webpack and non-webpack code 如果代码中包含 webpack 和非 webpack 的代码要使用 externals\n\n你可能拥有一个体积庞大的工程，其中一部分代码可以使用 webpack 编译，而有一些代码又不能。比如一个视频网站，播放器的 widget 可能通过 webpack 编译，但是其周围页面区域可能不是：\n\n![video-hosting](https://img30.360buyimg.com/uba/jfs/t15334/148/2273118093/210074/8260a296/5a81599dN148751d5.png)\n\n如果两部分代码有相同的依赖，你可以共享这些依赖以便减少重复下载耗时。[the webpack’s `externals` option](https://webpack.js.org/configuration/externals/)就干了这件事 - 它用变量或者外部引用来替代 modules。\n\n#### 如果依赖是挂载到 window \n\n如果你的非 webpack 代码依靠这些依赖，这些依赖是挂载 window 上的变量，可以将依赖名称 alias 成变量名：\n\n```javascript\n// webpack.config.js\nmodule.exports = {\n  externals: {\n    'react': 'React',\n    'react-dom': 'ReactDOM',\n  },\n};\n```\n利用这个配置，webpack 将不会打包 `react` 和 `react-dom`包。取而代之，他们会被替换成下面这个样子：\n\n```javascript\n// bundle.js (part of)\n(function(module, exports) {\n  // A module that exports `window.React`. Without `externals`,\n  // this module would include the whole React bundle\n  module.exports = React;\n}),\n(function(module, exports) {\n  // A module that exports `window.ReactDOM`. Without `externals`,\n  // this module would include the whole ReactDOM bundle\n  module.exports = ReactDOM;\n})\n```\n#### 如果依赖是当做 AMD 包被加载\n\n如果你的非 webpack 代码没有将依赖暴露挂载到 window 上，这就更复杂了。但是如果非 webpack 代码使用 AMD 包的形式消费了这些依赖，你仍然可以避免重复的代码加载两次。\n\n具体如何做呢？将 webpack 代码编译成一个 AMD module 同时又名成一个库 URLs：\n\n```javascript\n// webpack.config.js\nmodule.exports = {\n  output: { libraryTarget: 'amd' },\n\n  externals: {\n    'react': { amd: '/libraries/react.min.js' },\n    'react-dom': { amd: '/libraries/react-dom.min.js' },\n  },\n};\n```\nWebpack 将会把 bundle 包装进 `define()`同时让它依赖于这些URLs：\n\n```javascript\n// bundle.js (beginning)\ndefine([\"/libraries/react.min.js\", \"/libraries/react-dom.min.js\"], function () { … });\n```\n如果非 webpack 代码使用相同的 URLs 加载依赖，这些文件将会加载一次 - 多余的请求会使用缓存。\n\n> Note：webpack 只是替换那些`externals`对象中的准确匹配的 keys 的引用。这意味着如果你的代码这样写`import React from 'react/umd/react.production.min.js'`，这个库是不会被 bundle 排除掉的。这是因为 - webpack 并不知道 `import 'react'` 和 `import 'react/umd/react.production.min.js'` 是同一个库，这样比较谨慎。\n\n#### Further reading\n\n*   Webpack docs [on `externals`](https://webpack.js.org/configuration/externals/)\n\n### Summing up 总结\n\n*   Minimize your code with the `UglifyJsPlugin` and loader options\n*   Remove the development-only code with the `DefinePlugin`\n*   Use ES modules to enable tree shaking\n*   Compress images\n*   Apply dependency-specific optimizations\n*   Enable module concatenation\n*   Use `externals` if this makes sense for you\n\n## Make use of long-term caching 利用好长时缓存\n\n作者 [Ivan Akulov](https://developers.google.com/web/resources/contributors/iamakulov)\n\n在做完优化应用体积之后的下一步提升应用加载时间的就是缓存。在客户端中使用缓存作为应用的一部分同时每一次减少重新下载。\n\n### Use bundle versioning and cache headers 使用 bundle 版本和缓存头信息\n\n做缓存通用的解决办法：\n1. 告诉浏览器缓存一个文件很长时间（比如一年）\n\n```\n# Server header\nCache-Control: max-age=31536000\n```\nNote：如果你不熟悉 `Cache-Control`做了什么，你可以看一下Jake Archibald 的精彩博文 [on caching best practices](https://jakearchibald.com/2016/caching-best-practices/)\n\n2.当文件改变需要强制重新下载时候去重命名这些文件\n\n```html\n<!-- Before the change -->\n<script src=\"./index-v15.js\"></script>\n\n<!-- After the change -->\n<script src=\"./index-v16.js\"></script>\n```\n这些方法告诉浏览器下载这些 JS 文件，缓存起来。浏览器将会只在文件名变化是才会请求网络（或者是缓存失效）。\n\n使用 webpack，你也可以做同样的事，但是是可以使用版本号来解决，你需要明确这个文件的 hash。使用 [`[chunkhash]`](https://webpack.js.org/configuration/output/#output-filename) 可以将 hash 值包含进文件名中：\n\n```javascript\n// webpack.config.js\nmodule.exports = {\n  entry: './index.js',\n  output: {\n    filename: 'bundle.[chunkhash].js',\n        // → bundle.8e0d62a03.js\n  },\n};\n```\n> Note: webpack 可能会生成不同的 hash 就是 bundle 相同 - 比如你重名了了一个文件或者重新在不同的操作系统下编译了一个 bundle。 [This is a bug.](https://github.com/webpack/webpack/issues/1479)\n> 如果你需要将文件名发送给客户端，也可以使用 `HtmlWebpackPlugin` 或者 `WebpackManifestPlugin`。\n\n`HtmlWebpackPlugin` 很简单，但是灵活性欠缺一些。编译时，插件会生成一个 HTML 文件，这其中包括所有的编译后的资源文件。如果你的业务逻辑不复杂，这就非常适合你：\n\n```html\n<!-- index.html -->\n<!doctype html>\n<!-- ... -->\n<script src=\"bundle.8e0d62a03.js\"></script>\n```\n`WebpackManifestPlugin`更灵活一些，它可以帮助你解决业务负责的部分。编译时它会生成一个 JSON 文件，这文件保存这没有 hash 值文件与有 hash 文件之间的映射。服务端利用这个 JSON 可以识别出那个文件有效：\n\n```json\n// manifest.json\n{\n  \"bundle.js\": \"bundle.8e0d62a03.js\"\n}\n```\n#### Further reading\n\n*   Jake Archibald [about caching best practices](https://jakearchibald.com/2016/caching-best-practices/)\n\n### Extract dependencies and runtime into a separate file 外部依赖和独立文件运行时\n\n#### Dependencies 依赖包\n\nApp 依赖通常情况下趋向于比实际 app 内代码中更少的变化。如果你将他们移到独立的文件中，浏览器将可以把他们独立缓存起来 - 同时不会每次 app 代码改变时重新下载。\n\n> Key Term: 在 webpack 的技术中，利用 app 代码拆分文件被称为 `chunks`。我们后面会用到这个名词。\n\n为了将依赖包提取到单独的 chunk 中，下面分为三步：\n\n1. 使用`[name].[chunkname].js`替换`output`的文件名：\n\n```javascript\n// webpack.config.js\nmodule.exports = {\n  output: {\n    // Before\n    filename: 'bundle.[chunkhash].js',\n    // After\n    filename: '[name].[chunkhash].js',\n  },\n};\n```\n当 webpack 构建应用时，它会用一个带有 chunk 的名称来替换`[name]`。如果没有添加`[name]`部分，我们不得不通过 chunks 之间的 hash 区别来比较他们的区别 - 那就太难了！\n\n2. 将`entry`转成一个对象：\n\n```javascript\n// webpack.config.js\nmodule.exports = {\n  // Before\n  entry: './index.js',\n  // After\n  entry: {\n    main: './index.js',\n  },\n};\n```\n在这段代码中，\"main\" 对象是一个 chunk 的名字。这个名字将会被步骤 1 里面的 `[name]`代替。目前为止，如果你构建一个 app，chunk 就会包括整个 app 的代码 - 就像我们没有做这些步骤一样。但是很快就会产生变化。\n\n3. 添加  [`CommonsChunkPlugin`](https://webpack.js.org/plugins/commons-chunk-plugin/)：\n\n\n```javascript\n// webpack.config.js\nmodule.exports = {\n  plugins: [\n    new webpack.optimize.CommonsChunkPlugin({\n      // A name of the chunk that will include the dependencies.\n      // This name is substituted in place of [name] from step 1\n      name: 'vendor',\n\n      // A function that determines which modules to include into this chunk\n      minChunks: module => module.context &&\n        module.context.includes('node_modules'),\n    }),\n  ],\n};\n```\n这个插件将包括全部`node_modules`路径下的 modules 同时将他们移到一个单独的文件中，这个文件被称为 `vendor.[chunkhash].js`。\n\n完成了上面的步骤，每一次 build 都将生成两个文件。浏览器会将他们单独缓存 - 以便代码该生改变时重新下载。\n\n\n```bash\n$ webpack\nHash: ac01483e8fec1fa70676\nVersion: webpack 3.8.1\nTime: 3816ms\n                           Asset   Size  Chunks             Chunk Names\n  ./main.00bab6fd3100008a42b0.js  82 kB       0  [emitted]  main\n./vendor.d9e134771799ecdf9483.js  47 kB       1  [emitted]  vendor\n```\n#### Webpack runtime code\n\n不幸的是，仅仅抽取`vendor`是不够的。如果你试图在应用代码中修改一些东西：\n\n```javascript\n// index.js\n…\n…\n\n// E.g. add this:\nconsole.log('Wat');\n```\n你会注意到`vendor`的 hash 值也会改变：\n\n```bash\n                           Asset   Size  Chunks             Chunk Names\n./vendor.d9e134771799ecdf9483.js  47 kB       1  [emitted]  vendor\n```\nto\n\n```bash\n                            Asset   Size  Chunks             Chunk Names\n./vendor.e6ea4504d61a1cc1c60b.js  47 kB       1  [emitted]  vendor\n```\n发生这样的事是因为 webpack 打包时，一部分 modules 的代码，拥有 [_a runtime_](https://webpack.js.org/concepts/manifest/) - 管理模块执行一部分代码。当你将代码拆分成多个文件时，这小部分代码在 chunk ids 和 匹配的文件之间开始了一个映射：\n\n```javascript\n// vendor.e6ea4504d61a1cc1c60b.js\nscript.src = __webpack_require__.p + chunkId + \".\" + {\n  \"0\": \"2f2269c7f0a55a5c1871\"\n}[chunkId] + \".js\";\n```\nWebpack 将最新生成的 chunk 包含了这个 runtime 内，这个 chunk 就是我们代码中的`vendor`。与此同时每一次任何 `chunk`的改变，这一小部分代码也改变，导致整个 `vendor` chunk 也改变、\n\n为了解决这个问题，我们将这个 runtime 转义到一个独立的文件中，通过`CommonsChunkPlugin`创建一个额外的空的 chunk：\n\n```javascript\n// webpack.config.js\nmodule.exports = {\n  plugins: [\n    new webpack.optimize.CommonsChunkPlugin({\n      name: 'vendor',\n\n      minChunks: module => module.context &&\n        module.context.includes('node_modules'),\n    }),\n\n    // This plugin must come after the vendor one (because webpack\n    // includes runtime into the last chunk)\n    new webpack.optimize.CommonsChunkPlugin({\n      name: 'runtime',\n\n      // minChunks: Infinity means that no app modules\n      // will be included into this chunk\n      minChunks: Infinity,\n    }),\n  ],\n};\n```\n完成这一部分改变，每一次 build 都将生成三个文件：\n\n```bash\n$ webpack\nHash: ac01483e8fec1fa70676\nVersion: webpack 3.8.1\nTime: 3816ms\n                            Asset     Size  Chunks             Chunk Names\n   ./main.00bab6fd3100008a42b0.js    82 kB       0  [emitted]  main\n ./vendor.26886caf15818fa82dfa.js    46 kB       1  [emitted]  vendor\n./runtime.79f17c27b335abc7aaf4.js  1.45 kB       3  [emitted]  runtime\n```\n将他们反过来顺序添加到 index.html 中，你就搞定了：\n\n```html\n<!-- index.html -->\n<script src=\"./runtime.79f17c27b335abc7aaf4.js\"></script>\n<script src=\"./vendor.26886caf15818fa82dfa.js\"></script>\n<script src=\"./main.00bab6fd3100008a42b0.js\"></script>\n```\n#### Further reading\n\n*   Webpack guide [on long term caching](https://webpack.js.org/guides/caching/)\n*   Webpack docs [about webpack runtime and manifest](https://webpack.js.org/concepts/manifest/)\n*   [“Getting the most out of the CommonsChunkPlugin”](https://medium.com/webpack/webpack-bits-getting-the-most-out-of-the-commonschunkplugin-ab389e5f318)\n\n### Inline webpack runtime to save an extra HTTP request 内联 webpack runtime 节省额外的 HTTP  请求\n\n为了做的更好，尽力把 webpack runtime 内联在 HTML 请求里。下面举例：\n\n```html\n<!-- index.html -->\n<script src=\"./runtime.79f17c27b335abc7aaf4.js\"></script>\n```\n这样做：\n\n```html\n<!-- index.html -->\n<script>\n!function(e){function n(r){if(t[r])return t[r].exports;…}} ([]);\n</script>\n```\n这个 runtime 很小，内联它可以帮助你节省 HTTP 请求（尤其对 HTTP/1 重要；但是在 HTTP/2 就没有那么重要了，但是仍能够提高效率）。\n\n下面就来看看如何做。\n\n#### 如果使用 HtmlWebpackPlugin 来生成 HTML\n\n如果使用 [`HtmlWebpackPlugin`](https://github.com/jantimon/html-webpack-plugin) 来生成 HTML 文件，[`InlineChunkWebpackPlugin`](https://github.com/rohitlodha/html-webpack-inline-chunk-plugin) 就足够了。\n\n#### 如果使用自己的定制服务逻辑来生成 HTML\n\n1. 将 runtime 名称成静态明确的文件名：\n\n```javascript\n// webpack.config.js\nmodule.exports = {\n  plugins: [\n    new webpack.optimize.CommonsChunkPlugin({\n      name: 'runtime',\n      minChunks: Infinity,\n      filename: 'runtime.js',\n        // → Now the runtime file will be called\n        // “runtime.js”, not “runtime.79f17c27b335abc7aaf4.js”\n    }),\n  ],\n};\n```\n2. 将方便的方式将 runtime.js 嵌入进去。比如：Node.js 和 Express\n\n```javascript\n// server.js\nconst fs = require('fs');\nconst runtimeContent = fs.readFileSync('./runtime.js', 'utf-8');\n\napp.get('/', (req, res) => {\n  res.send(`\n    …\n    <script>${runtimeContent}</script>\n    …\n  `);\n});\n```\n### 懒加载\n\n有时候，页面拥有或多或少的部分：\n\n* 如果你在 YouTube 上加载一个视频页面，相比评论区域你更在乎视频区域。这就是视频要比评论区域重要。\n* 如果你在一个新闻网站打开一个报道，相比广告区域你更关心文章的内容。这就是文字比广告更重要。\n\n在这些案例中，通过仅下载最重要的部分，懒加载剩余区域能够提升最初的加载性能。使用 [the `import()` function](https://webpack.js.org/api/module-methods/#import-) 和 [code-splitting](https://webpack.js.org/guides/code-splitting/) 解决这个问题：\n\n\n```javascript\n// videoPlayer.js\nexport function renderVideoPlayer() { … }\n\n// comments.js\nexport function renderComments() { … }\n\n// index.js\nimport {renderVideoPlayer} from './videoPlayer';\nrenderVideoPlayer();\n\n// …Custom event listener\nonShowCommentsClick(() => {\n  import('./comments').then((comments) => {\n    comments.renderComments();\n  });\n});\n```\n`import()`明确表示你期望动态地加载独立的 module。当 webpack 看到 `import('./module.js')`时，他就会将这个 module 移到独立的 chunk 中：\n\n```bash\n$ webpack\nHash: 39b2a53cb4e73f0dc5b2\nVersion: webpack 3.8.1\nTime: 4273ms\n                            Asset     Size  Chunks             Chunk Names\n      ./0.8ecaf182f5c85b7a8199.js  22.5 kB       0  [emitted]\n   ./main.f7e53d8e13e9a2745d6d.js    60 kB       1  [emitted]  main\n ./vendor.4f14b6326a80f4752a98.js    46 kB       2  [emitted]  vendor\n./runtime.79f17c27b335abc7aaf4.js  1.45 kB       3  [emitted]  runtime\n```\n并且只在代码执行到 `import()` 才会下载。\n\n这将会让 main bundle 更小，提升初始加载的时间。更重要的是改进缓存 - 如果你修改 main chunk 的代码，其他部分的 chunk 也不会受影响。\n\n> Note: 如果使用 Babel 编译代码，你会因为 Babel 还不认识 _import()_ 而遇到语法错误抛出来。可以使用 [`syntax-dynamic-import`](https://www.npmjs.com/package/babel-plugin-syntax-dynamic-import) 解决这个错误。\n\n#### Further reading\n\n*   Webpack docs [for the `import()` function](https://webpack.js.org/api/module-methods/#import-)\n*   The JavaScript proposal [for implementing the `import()` syntax](https://github.com/tc39/proposal-dynamic-import)\n\n### Split the code into routes and pages 拆分代码到路由和页面中\n\n如果你的应用拥有多个路由或者页面，但是代码中只有单独一个 JS 文件（一个单独的 main chunk），这看起来你正在每一个请求中节省额外的 bytes 带宽。举个例子，当用户正在访问你网站的首页：\n\n![site-home-page](https://img10.360buyimg.com/uba/jfs/t17272/291/466883786/44644/f5b82d7c/5a8159b0N4fe9f50d.png)\n\n他们并不需要加载另外不同的页面上渲染文章标题的的代码 - 但是他们还是会加载到这段代码。更严重的是如果用户经常只访问首页，同时你还经常改变渲染文章标题的代码，webpack 将会对整个 bundle 失效 - 用户每次都会重复下载全部 app 的代码。\n\n如果我们将代码拆分到页面里（或者单页面应用的路由里），用户就会下载对他有意义的代码。更好的是，浏览器也会更好地缓存代码：当你改变首页的代码时，webpack 只会让相匹配的 chunk 失效。\n\n#### For single-page apps 对于单页面应用\n\n\n通过路由拆分带页面引用，使用`import()`（看看 [“Lazy-load code that you don’t need right now”](https://developers.google.com/web/fundamentals/performance/webpack/use-long-term-caching#lazy-loading)这部分）。如果你在使用一个框架，现在已经有成熟的方案：\n\n*   [“Code Splitting”](https://reacttraining.com/react-router/web/guides/code-splitting) in `react-router`'s docs (for React)\n*   [“Lazy Loading Routes”](https://router.vuejs.org/en/advanced/lazy-loading.html) in `vue-router`'s docs (for Vue.js)\n\n#### For traditional multi-page apps 对于传统的多页面应用\n\n通过页面拆分传统多页面应用，可以使用 webpack 的 [_entry points_](https://webpack.js.org/concepts/entry-points/) 。如果你的应用有三种页面：主页、文章页、用户账户页，那就分厂三个 entries：\n\n\n```javascript\n// webpack.config.js\nmodule.exports = {\n  entry: {\n    home: './src/Home/index.js',\n    article: './src/Article/index.js',\n    profile: './src/Profile/index.js'\n  },\n};\n```\n对于每一个 entry 文件，webpack 将构建出独立的依赖树，并且声称一个 bundle，它将通过 entry 来只包括用到的 modules：\n\n```bash\n$ webpack\nHash: 318d7b8490a7382bf23b\nVersion: webpack 3.8.1\nTime: 4273ms\n                            Asset     Size  Chunks             Chunk Names\n      ./0.8ecaf182f5c85b7a8199.js  22.5 kB       0  [emitted]\n   ./home.91b9ed27366fe7e33d6a.js    18 kB       1  [emitted]  home\n./article.87a128755b16ac3294fd.js    32 kB       2  [emitted]  article\n./profile.de945dc02685f6166781.js    24 kB       3  [emitted]  profile\n ./vendor.4f14b6326a80f4752a98.js    46 kB       4  [emitted]  vendor\n./runtime.318d7b8490a7382bf23b.js  1.45 kB       5  [emitted]  runtime\n```\n 因此，如果仅仅是文章页使用_Lodash_，_home_ 和 _profile_ 的 bundle 将不会包含 lodash - 同时用户也不会在访问首页的时候下载到这个库。\n\n拆分依赖树也有缺点。如果两个 entry points 都用到了_loadash_，同时你没有在 _vendor_ 移除掉依赖，两个 entry points 将包括两个重复的_lodash_。我们使用[`CommonsChunkPlugin`](https://webpack.js.org/plugins/commons-chunk-plugin/)解决这个问题 - 它会将通用的依赖转移到一个独立的文件中：\n\n```javascript\n// webpack.config.js\nmodule.exports = {\n  plugins: [\n    new webpack.optimize.CommonsChunkPlugin({\n      // A name of the chunk that will include the common dependencies\n      name: 'common',\n\n      // The plugin will move a module into a common file\n      // only if it’s included into `minChunks` chunks\n      // (Note that the plugin analyzes all chunks, not only entries)\n      minChunks: 2,    // 2 is the default value\n    }),\n  ],\n};\n```\n随意使用`minChunks`的值来找到最优的选项。通常情况下，你想要它尽可能体积小，但它会增加 chunks 的数量。举个例子，3 个 chunk，`minChunks` 可能是 2 个，但是 30 个 chunk，它可能是 8 个 - 因为如果你把它设置成 2 ，过多的 modules 将会打包进一个通用文件中，文件更臃肿。\n\n#### Further reading\n\n*   Webpack docs [about the concept of entry points](https://webpack.js.org/concepts/entry-points/)\n*   Webpack docs [about the CommonsChunkPlugin](https://webpack.js.org/plugins/commons-chunk-plugin/)\n*   [“Getting the most out of the CommonsChunkPlugin”](https://medium.com/webpack/webpack-bits-getting-the-most-out-of-the-commonschunkplugin-ab389e5f318)\n\n### Make module ids more stable 让 module ide 更稳定\n\n当编译代码时，webpack 会分配给每一个 module 一个 ID。之后，这些 ID 就会被`require()`引用到 bundle 内部。你可以在编译输出的右侧在 moudle 路径之前看到这些 ID：\n\n\n```bash\n$ webpack\nHash: df3474e4f76528e3bbc9\nVersion: webpack 3.8.1\nTime: 2150ms\n                           Asset      Size  Chunks             Chunk Names\n      ./0.8ecaf182f5c85b7a8199.js  22.5 kB       0  [emitted]\n   ./main.4e50a16675574df6a9e9.js    60 kB       1  [emitted]  main\n ./vendor.26886caf15818fa82dfa.js    46 kB       2  [emitted]  vendor\n./runtime.79f17c27b335abc7aaf4.js  1.45 kB       3  [emitted]  runtime\n```\nhere\n\n```bash\n   [0] ./index.js 29 kB {1} [built]\n   [2] (webpack)/buildin/global.js 488 bytes {2} [built]\n   [3] (webpack)/buildin/module.js 495 bytes {2} [built]\n   [4] ./comments.js 58 kB {0} [built]\n   [5] ./ads.js 74 kB {1} [built]\n    + 1 hidden module\n```\n默认情况下，这些 ID 是使用计数器计算出来的（比如第一个 module 是 ID 0，第二个 moudle 就是 ID 1，以此类推）。这样的问题就在于当你新增一个 module 事，它会出现在原来 module 列表中的中间，改变后面所有 module 的 ID：\n\n\n```bash\n$ webpack\nHash: df3474e4f76528e3bbc9\nVersion: webpack 3.8.1\nTime: 2150ms\n                           Asset      Size  Chunks             Chunk Names\n      ./0.5c82c0f337fcb22672b5.js    22 kB       0  [emitted]\n   ./main.0c8b617dfc40c2827ae3.js    82 kB       1  [emitted]  main\n ./vendor.26886caf15818fa82dfa.js    46 kB       2  [emitted]  vendor\n./runtime.79f17c27b335abc7aaf4.js  1.45 kB       3  [emitted]  runtime\n   [0] ./index.js 29 kB {1} [built]\n   [2] (webpack)/buildin/global.js 488 bytes {2} [built]\n   [3] (webpack)/buildin/module.js 495 bytes {2} [built]\n```\n↓ 我们增加一个新 module\n\n```bash\n[4] ./webPlayer.js 24 kB {1} [built]\n```\n↓ 现在看这里做了什么！`comments.js`现在的 ID 由 4 变成了 5\n\n```bash\n[5] ./comments.js 58 kB {0} [built]\n```\n↓ `ads.js` 的 ID 由 5 变成 6\n\n```bash\n[6] ./ads.js 74 kB {1} [built]\n       + 1 hidden module\n```\n这将使包含或依赖于具有更改ID的模块的所有块无效 - 即使它们的实际代码没有更改。在我们的代码中，_0_这个 chunk 和 _main_ chunk 都会失效 - 只有_main_才应该失效。\n\n使用[`HashedModuleIdsPlugin`](https://webpack.js.org/plugins/hashed-module-ids-plugin/)插件改变module ID 如何计算来解决这个问题。它利用 module 路径的 hash 来替换掉计数器：\n\n```bash\n$ webpack\nHash: df3474e4f76528e3bbc9\nVersion: webpack 3.8.1\nTime: 2150ms\n                           Asset      Size  Chunks             Chunk Names\n      ./0.6168aaac8461862eab7a.js  22.5 kB       0  [emitted]\n   ./main.a2e49a279552980e3b91.js    60 kB       1  [emitted]  main\n ./vendor.ff9f7ea865884e6a84c8.js    46 kB       2  [emitted]  vendor\n./runtime.25f5d0204e4f77fa57a1.js  1.45 kB       3  [emitted]  runtime\n```\n↓ Here\n\n```bash\n[3IRH] ./index.js 29 kB {1} [built]\n[DuR2] (webpack)/buildin/global.js 488 bytes {2} [built]\n[JkW7] (webpack)/buildin/module.js 495 bytes {2} [built]\n[LbCc] ./webPlayer.js 24 kB {1} [built]\n[lebJ] ./comments.js 58 kB {0} [built]\n[02Tr] ./ads.js 74 kB {1} [built]\n    + 1 hidden module\n```\n有了这个方法，只有你重命名护着删除这个 moudle 它的 ID 才会变化。新的 modules 不会因为 module ID 互相影响。\n\n启用这个插件，在配置中增加 _plugins_：\n\n```javascript\n// webpack.config.js\nmodule.exports = {\n  plugins: [\n    new webpack.HashedModuleIdsPlugin(),\n  ],\n};\n```\n#### Further reading\n\n*   Webpack docs [about the HashedModuleIdsPlugin](https://webpack.js.org/plugins/hashed-module-ids-plugin/)\n\n### Summing up\n\n*   Cache the bundle and differentiate between them by changing their names\n*   Split the bundle into app code, vendor code and runtime\n*   Inline the runtime to save an HTTP request\n*   Lazy-load non-critical code with `import`\n*   Split code by routes/pages to avoid loading unnecessary stuff\n\n===\n\n## Monitor and analyze the app 监控并分析\n\n作者 [Ivan Akulov](https://developers.google.com/web/resources/contributors/iamakulov)\n\n即使当你配置好你的 webpack 让你的引用尽可能体积较小的时候，跟踪这个应用就非常重要，同时了解里面包含了什么。除此之外，你安装一个依赖，它将让你的 app 增加两倍大小 - 但并没有注意到这个问题！\n\n这一部分就来讲解一些能够帮助你理解你的 bundle 的工具。\n\n### Keep track of the bundle size 跟踪打包的体积\n\n在开发时可以使用[webpack-dashboard](https://github.com/FormidableLabs/webpack-dashboard/)和命令行[bundlesize](https://github.com/siddharthkp/bundlesize) 来监控 app 的体积。\n\n#### webpack-dashboard\n\n[webpack-dashboard](https://github.com/FormidableLabs/webpack-dashboard/)可以通过依赖体积大小、进程和其他细节来改进 webpack 的输出。\n\n![webpack-dashboard](http://img30.360buyimg.com/uba/jfs/t16294/169/2125639991/38263/ad862ba/5a8159c0N0da38a60.png)\n\n这个 dashborad 帮助我们跟踪大型依赖 - 如果你增加一个依赖，你就立刻能在 Modules section 始终看到它！\n\n启用这个功能，需要安装 _webpack-dashboard_ 包：\n\n```bash\nnpm install webpack-dashboard --save-dev\n```\n 同时在配置的 plugins 增加：\n\n```javascript\n// webpack.config.js\nconst DashboardPlugin = require('webpack-dashboard/plugin');\n\nmodule.exports = {\n  plugins: [\n    new DashboardPlugin(),\n  ],\n};\n```\n或者如果正在使用基于 Express dev server 可以使用 `compiler.apply()`：\n\n```bash\ncompiler.apply(new DashboardPlugin());\n```\n多尝试 dashboard 找出改进的地方！比如，在 modules section 滚动找到那个库体积过大，把它替换成小的可替代的库。\n\n#### bundlesize\n\n[bundlesize](https://github.com/siddharthkp/bundlesize) 可以验证 webpack assets 不超过指定的大小。通过自动化 CI 就可以知晓 app 是否变的过于臃肿：\n\n![bundlesize](https://img30.360buyimg.com/uba/jfs/t15808/165/2111159728/110001/633e93ab/5a8159cdN1c575a1f.jpg)\n\n配置如下：\n\n##### **Find out the maximum sizes** 找出最大体积\n\n1. 分析 app 尽可能减小体积，执行生产环境的 build。\n2. 在`package.json`中增加`bundlesize`部分：\n\n```json\n// package.json\n{\n  \"bundlesize\": [\n    {\n      \"path\": \"./dist/*\"\n    }\n  ]\n}\n```\n3. 使用`npx`执行`bundlesize`：\n\n```bash\nnpx bundlesize\n```\n它就会将每一个文件的 gzip 压缩后的体积打印出来：\n\n```bash\nPASS  ./dist/icon256.6168aaac8461862eab7a.png:  10.89KB PASS./dist/icon512.c3e073a4100bd0c28a86.png:  13.1KB PASS./dist/main.0c8b617dfc40c2827ae3.js:  16.28KB PASS./dist/vendor.ff9f7ea865884e6a84c8.js:  31.49KB\n```\n4. 每一个体积增加10-20%，你将得到最大体积。这个10-20％的幅度可以让你像往常一样开发应用程序，同时警告你，当它的大小增长太多。\n\n##### **Enable `bundlesize`** 启用 bundlesize\n\n5.安装_bundlesize_开发依赖\n\n```bash\nnpm install bundlesize --save-dev\n```\n6.在`package.json`中的`bundlesize`部分，声明具体的最大值。对于某一些文件（比如图片），你可以单独根据文件类型来设置最大体积大小，而不需要根据每一个文件：\n\n\n```json\n// package.json\n{\n  \"bundlesize\": [\n    {\n      \"path\": \"./dist/*.png\",\n      \"maxSize\": \"16 kB\",\n    },\n    {\n      \"path\": \"./dist/main.*.js\",\n      \"maxSize\": \"20 kB\",\n    },\n    {\n      \"path\": \"./dist/vendor.*.js\",\n      \"maxSize\": \"35 kB\",\n    }\n  ]\n}\n```\n7.增加一个 npm 脚本来执行检查：\n\n```json\n// package.json\n{\n  \"scripts\": {\n    \"check-size\": \"bundlesize\"\n  }\n}\n```\n8.配置自动化 CI 来在每一次 push 时执行`npm run check-size`做检查。（如果你在 Github 上开发项目，直接可以使用[integrate `bundlesize` with GitHub](https://github.com/siddharthkp/bundlesize#2-build-status)。）\n\n这就全部了！现在如果你运行`npm run check-size`或者 push 代码，你就会看到输出的文件是否足够小：\n\n![bundlesize-output-success](https://img14.360buyimg.com/uba/jfs/t14890/146/2205111432/17457/fa7f748a/5a8159dcN17378d16.png)\n\n或者下面失败的情况\n\n![bundlesize-output-failure](https://img11.360buyimg.com/uba/jfs/t16969/198/453213154/26368/834a1c7f/5a8159e8Nc1f5ffe8.png)\n\n#### Further reading\n\n*   Alex Russell [about the real-world loading time we should target](https://infrequently.org/2017/10/can-you-afford-it-real-world-web-performance-budgets/)\n\n### Analyze why the bundle is so large 分析 bundle 为什么这么大\n\n你想要深挖 bundle 内，看看里面具体哪些 module 占用多大空间。[webpack-bundle-analyzer](https://github.com/webpack-contrib/webpack-bundle-analyzer)\n\n(Screen recording from [github.com/webpack-contrib/webpack -bundle-analyzer](https://github.com/webpack-contrib/webpack-bundle-analyzer))\n\nwebpack-bundle-analyzer 可以扫描 bundle 同时构建一个查看内部的可视化窗口。使用这个可视化工具找到过大或者不必要的依赖。\n\n使用这个分析器，需要安装`webpack-bundle-analyzer`包：\n\n```bash\nnpm install webpack-bundle-analyzer --save-dev\n```\n在 config 中增加插件：\n\n```javascript\n// webpack.config.js\nconst BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;\n\nmodule.exports = {\n  plugins: [\n    new BundleAnalyzerPlugin(),\n  ],\n};\n```\n运行生产环境的 build。这个插件就会在浏览器中打开一个显示状态的页面。\n\n默认情况下，这个页面会显示语法分析后的文件体积（在 bundle 出现的文件）。您可能想比较 gzip 的大小，因为这更接近实际用户的体验；使用左边的边栏来切换尺寸。\n\n> Note: 如果你使用 [ModuleConcatenationPlugin](https://webpack.js.org/plugins/module-concatenation-plugin/)，它可能在webpack-bundle-analyzer输出时合并一部分 module，使得报告小一些细节。如果你使用这个插件，在执行分析的时候需要禁用掉。\n\n下面是报告中需要看什么：\n\n* **大型依赖** 为什么体积这么大？是否有更小的替代包（比如 Preact 替代 React）？用了全部代码（比如 Moment.js 包含大量的本地变量 [that are often not used and could be dropped](https://github.com/GoogleChromeLabs/webpack-libs-optimizations#moment)）？\n* **重复依赖** 是否在不同文件中看到相同的库？（使用_CommonsChunkPlugin_将他们移到一个通用文件内）亦或是在同一个库中 bundle 拥有多个版本？\n* **相似依赖** 是否存在有相似功能的相似库存在？（比如_moment_和_date-fns_ 或者 _lodash_ 和 _lodash-es_）尽力汇总成一个。\n\n同样的，也可以看看 Sean Larkin 的文章 [great analysis of webpack bundles](https://medium.com/webpack/webpack-bits-getting-the-most-out-of-the-commonschunkplugin-ab389e5f318)。\n\n### Summing up\n\n*   Use `webpack-dashboard` and `bundlesize` to stay tuned of how large your app is\n*   Dig into what builds up the size with `webpack-bundle-analyzer`\n\n===\n## Conclusion结尾\n\n总结一下：\n\n* **剔除不必要的体积** 把所有的都压缩，剔除无用代码，增加依赖是保持谨慎小心。\n* **通过路由拆分代码** 只在真正需要的时候才加载，其他的部分做来加载。\n* **缓存代码** 应用程序的某些部分更新频率低于其他部分，将这些部分拆分成文件，以便在必要时仅重新下载。\n* **跟踪体积大小** 使用  [webpack-dashboard](https://github.com/FormidableLabs/webpack-dashboard/) 和 [webpack-bundle-analyzer](https://github.com/webpack-contrib/webpack-bundle-analyzer) 监控你的 app。每隔几个月重新检查一下你的应用的性能。\n\nWebpack 不仅仅是一个帮助你创建 app 更快的工具。它还帮助是你的 app 成为 [a Progressive Web App](https://developers.google.com/web/progressive-web-apps/) ，你的引用拥有更好的体检自动化的填充工具就像[Lighthouse](https://developers.google.com/web/tools/lighthouse/)根据环境给出建议。\n\n不要忘记阅读 [webpack docs](https://webpack.js.org/guides/) - 里面提供了大量的优化的信息。\n\n记得练习一下 [with the training app](https://github.com/GoogleChromeLabs/webpack-training-project)！","slug":"blog-translate-web-performance-optimization-with-webpack-from-google","published":0,"date":"2018-02-10T16:00:00.000Z","updated":"2018-02-14T03:19:52.738Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdpx8l1l00000gy5l9xk2uu9","content":"<p>【译】Google出品 - 利用 webpack 做 web 性能优化</p>\n<p>===</p>\n<p>2018-02-11 Beanlee</p>\n<p>原文 <a href=\"https://developers.google.com/web/fundamentals/performance/webpack/\" target=\"_blank\" rel=\"noopener\">https://developers.google.com/web/fundamentals/performance/webpack/</a></p>\n<p>作者 Addy Osmani</p>\n<h2 id=\"Instroduction-介绍\"><a href=\"#Instroduction-介绍\" class=\"headerlink\" title=\"Instroduction 介绍\"></a>Instroduction 介绍</h2><p>现代 Web 应用经常用到<code>bunding tool</code>用于创建一个生产环境的打包文件（例如脚本、样式等），这个打包文件是已经优化完，并且最小化完成的，并且能够被用户用更少的时间下载到。在这篇文章中，我们将会利用<code>webpack</code>来贯穿如何优化网站资源。这样可以帮助用户对于你的网站得到更快地加载和体验。</p>\n<p><img src=\"https://img20.360buyimg.com/uba/jfs/t15217/149/2229580840/12989/54324b99/5a815957N5bb3e0c6.png\" alt=\"webpack-logo\"></p>\n<p>webpack 目前是最流行的打包工具之一，深入地利用他的特点去优化代码，拆分脚本成重要和非重要部分还有剔除无用的代码能够保证你的引用有最小的带宽和进程消耗。</p>\n<p><img src=\"https://img14.360buyimg.com/uba/jfs/t17569/325/476871633/18187/a1e34f41/5a81597fNd77bb5b8.png\" alt=\"code-splitting\"></p>\n<blockquote>\n<p>Note: 我们创建了一个练习用的引用来演示优化的描述。尽力挤出最多的时间来练习这些 tips <a href=\"https://github.com/GoogleChromeLabs/webpack-training-project\" target=\"_blank\" rel=\"noopener\"><code>webpack-training-project</code></a></p>\n</blockquote>\n<p>让我们从现代 web 应用中最耗费资源之一的 <code>Javascript</code>开始。</p>\n<ul>\n<li>减小前端体积</li>\n<li>利用长期缓存</li>\n<li>监控并分析应用</li>\n<li>结尾</li>\n</ul>\n<p>===</p>\n<h2 id=\"Decrease-Front-end-Size-减少前端体积\"><a href=\"#Decrease-Front-end-Size-减少前端体积\" class=\"headerlink\" title=\"Decrease Front-end Size 减少前端体积\"></a>Decrease Front-end Size 减少前端体积</h2><p>作者 <a href=\"https://developers.google.com/web/resources/contributors/iamakulov\" target=\"_blank\" rel=\"noopener\">Ivan Akulov</a></p>\n<p>当你正在优化一个应用时最初第一件事就是尽可能地让它体积减小。下面就是利用 webpack 如何做。</p>\n<h3 id=\"Enable-minification-启用最小化\"><a href=\"#Enable-minification-启用最小化\" class=\"headerlink\" title=\"Enable minification 启用最小化\"></a>Enable minification 启用最小化</h3><p>最小化是通过去除多余空格、缩短变量名等方式压缩代码。例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Original code</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">map</span>(<span class=\"params\">array, iteratee</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> index = <span class=\"number\">-1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> length = array == <span class=\"literal\">null</span> ? <span class=\"number\">0</span> : array.length;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(length);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (++index &lt; length) &#123;</span><br><span class=\"line\">    result[index] = iteratee(array[index], index, array);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>to</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Minified code</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">map</span>(<span class=\"params\">n,r</span>)</span>&#123;<span class=\"keyword\">let</span> t=<span class=\"number\">-1</span>;<span class=\"keyword\">for</span>(<span class=\"keyword\">const</span> a=<span class=\"literal\">null</span>==n?<span class=\"number\">0</span>:n.length,l=<span class=\"built_in\">Array</span>(a);++t&lt;a;)l[t]=r(n[t],t,n);<span class=\"keyword\">return</span> l&#125;</span><br></pre></td></tr></table></figure>\n<p>Webpack 支持两种方式最小化代码：UglifyJS 插件和<em>loader-specific options</em>。他们可以同时使用。</p>\n<p><a href=\"https://github.com/webpack-contrib/uglifyjs-webpack-plugin\" target=\"_blank\" rel=\"noopener\">The UglifyJS plugin</a>在 bundle 层级中起作用，在编译之后压缩 bundle。下面来展示如何工作：</p>\n<ol>\n<li>你的代码：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// comments.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./comments.css'</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span>(<span class=\"params\">data, target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Rendered!'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>Webpack 打包大致成如下：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// bundle.js (part of)</span></span><br><span class=\"line\"><span class=\"meta\">\"use strict\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(__webpack_exports__, <span class=\"string\">\"__esModule\"</span>, &#123; <span class=\"attr\">value</span>: <span class=\"literal\">true</span> &#125;);</span><br><span class=\"line\"><span class=\"comment\">/* harmony export (immutable) */</span> __webpack_exports__[<span class=\"string\">\"render\"</span>] = render;</span><br><span class=\"line\"><span class=\"comment\">/* harmony import */</span> <span class=\"keyword\">var</span> __WEBPACK_IMPORTED_MODULE_0__comments_css__ = __webpack_require__(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"comment\">/* harmony import */</span> <span class=\"keyword\">var</span> __WEBPACK_IMPORTED_MODULE_0__comments_css_js___default =</span><br><span class=\"line\">__webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__comments_css__);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span>(<span class=\"params\">data, target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Rendered!'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>使用 UglifyJS 插件大致编译成如下：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// minified bundle.js (part of)</span></span><br><span class=\"line\"><span class=\"meta\">\"use strict\"</span>;<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">t</span>(<span class=\"params\">e,n</span>)</span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">\"Rendered!\"</span>)&#125;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(n,<span class=\"string\">\"__esModule\"</span>,&#123;<span class=\"attr\">value</span>:!<span class=\"number\">0</span>&#125;),n.render=t;<span class=\"keyword\">var</span> o=r(<span class=\"number\">1</span>);r.n(o)</span><br></pre></td></tr></table></figure>\n<p>插件集成在 webpack 中，把它的配置在<code>plugins</code>中就可以启用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack.config.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.optimize.UglifyJsPlugin(),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>第二种方式<em>loader-specific options</em> 利用 loader options，可以压缩 Uglify 插件无法最小化的部分。举例，当你利用<code>css-loader</code>引入一个 CSS 文件时，文件会编译成一个字符串：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* comments.css */</span></span><br><span class=\"line\"><span class=\"selector-class\">.comment</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: black;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>to</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// minified bundle.js (part of)</span></span><br><span class=\"line\">exports=<span class=\"built_in\">module</span>.exports=__webpack_require__(<span class=\"number\">1</span>)(),</span><br><span class=\"line\">exports.push([<span class=\"built_in\">module</span>.i,<span class=\"string\">\".comment &#123;\\r\\n  color: black;\\r\\n&#125;\"</span>,<span class=\"string\">\"\"</span>]);</span><br></pre></td></tr></table></figure>\n<p>UglifyJS 由于这是一个字符串不能压缩这段代码。要最小化这个 css 文件内容，我们需要配置 <em>loader</em></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack.config.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.css$/</span>,</span><br><span class=\"line\">        use: [</span><br><span class=\"line\">          <span class=\"string\">'style-loader'</span>,</span><br><span class=\"line\">          &#123; <span class=\"attr\">loader</span>: <span class=\"string\">'css-loader'</span>, <span class=\"attr\">options</span>: &#123; <span class=\"attr\">minimize</span>: <span class=\"literal\">true</span> &#125; &#125;,</span><br><span class=\"line\">        ],</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    ],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>{ minimize: true }</strong></p>\n<blockquote>\n<p>Note: UglifyJS 插件不能编译 ES2015+(ES2016)，这意味着如果你的 diamante 中使用类、箭头函数和一些新特性语法，不能编译成 ES5，插件会抛异常。<br>如果需要编译新语法，要使用 <a href=\"https://github.com/webpack-contrib/uglifyjs-webpack-plugin\" target=\"_blank\" rel=\"noopener\">uglifyjs-webpack-plugin</a> 包。也是集成在 webpack 中相同的插件，但是更新一些，能够有能力编译 ES2015+。</p>\n</blockquote>\n<h4 id=\"Further-reading\"><a href=\"#Further-reading\" class=\"headerlink\" title=\"Further reading\"></a>Further reading</h4><ul>\n<li><a href=\"https://github.com/webpack-contrib/uglifyjs-webpack-plugin\" target=\"_blank\" rel=\"noopener\">The UglifyJsPlugin docs</a></li>\n<li>Other popular minifiers: <a href=\"https://github.com/webpack-contrib/babel-minify-webpack-plugin\" target=\"_blank\" rel=\"noopener\">Babel Minify</a>, <a href=\"https://github.com/roman01la/webpack-closure-compiler\" target=\"_blank\" rel=\"noopener\">Google Closure Compiler</a></li>\n</ul>\n<h3 id=\"Specify-NODE-ENV-production-明确生产环境信息\"><a href=\"#Specify-NODE-ENV-production-明确生产环境信息\" class=\"headerlink\" title=\"Specify NODE_ENV=production 明确生产环境信息\"></a>Specify <code>NODE_ENV=production</code> 明确生产环境信息</h3><p>减小前端体积的另外一个方法就是在代码中将<code>NODE_ENV</code><a href=\"https://superuser.com/questions/284342/what-are-path-and-other-environment-variables-and-how-can-i-set-or-use-them\" target=\"_blank\" rel=\"noopener\">环境变量</a>设置成<code>production</code>。</p>\n<p>Libraries 会读取<code>NODE_ENV</code>变量判断他们应该在那种模式下工作 - 开发模式 or 生成模式。很多库会基于这个变量有不同的表现。举个例子，当<code>NODE_ENV</code>没有设置成<code>production</code>，Vue.js 会做额外的检查并且输出一些警告：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// vue/dist/vue.runtime.esm.js</span></span><br><span class=\"line\"><span class=\"comment\">// …</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span>) &#123;</span><br><span class=\"line\">  warn(<span class=\"string\">'props must be strings when using array syntax.'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// …</span></span><br></pre></td></tr></table></figure>\n<p>React 也是类似 - 开发模式下 build 带有一些警告：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// react/index.js</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (process.env.NODE_ENV === <span class=\"string\">'production'</span>) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">module</span>.exports = <span class=\"built_in\">require</span>(<span class=\"string\">'./cjs/react.production.min.js'</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">module</span>.exports = <span class=\"built_in\">require</span>(<span class=\"string\">'./cjs/react.development.js'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// react/cjs/react.development.js</span></span><br><span class=\"line\"><span class=\"comment\">// …</span></span><br><span class=\"line\">warning$<span class=\"number\">3</span>(</span><br><span class=\"line\">  componentClass.getDefaultProps.isReactClassApproved,</span><br><span class=\"line\">  <span class=\"string\">'getDefaultProps is only used on classic React.createClass '</span> +</span><br><span class=\"line\">  <span class=\"string\">'definitions. Use a static property named `defaultProps` instead.'</span></span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"comment\">// …</span></span><br></pre></td></tr></table></figure>\n<p>这些检查和警告通常在生产环境下不必要的，但是他们仍然保留在代码中并且会增加库的体积。通过配置 webpack 的 <a href=\"https://webpack.js.org/plugins/define-plugin/\" target=\"_blank\" rel=\"noopener\"><code>DefinePlugin</code></a> 来删除他们：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// webpack.config.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.DefinePlugin(&#123;</span><br><span class=\"line\">      <span class=\"string\">'process.env.NODE_ENV'</span>: <span class=\"string\">'\"production\"'</span>,</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.optimize.UglifyJsPlugin(),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><code>DefinePlugin</code>用确定的变量替换所有存在的说明变量。利用下面配置：</p>\n<ol>\n<li><code>DefinePlugin</code>将用<code>&quot;production&quot;</code>替换到<code>process.env.NODE_ENV</code>：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// vue/dist/vue.runtime.esm.js</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> val === <span class=\"string\">'string'</span>) &#123;</span><br><span class=\"line\">  name = camelize(val);</span><br><span class=\"line\">  res[name] = &#123; <span class=\"attr\">type</span>: <span class=\"literal\">null</span> &#125;;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span>) &#123;</span><br><span class=\"line\">  warn(<span class=\"string\">'props must be strings when using array syntax.'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>to</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// vue/dist/vue.runtime.esm.js</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> val === <span class=\"string\">'string'</span>) &#123;</span><br><span class=\"line\">  name = camelize(val);</span><br><span class=\"line\">  res[name] = &#123; <span class=\"attr\">type</span>: <span class=\"literal\">null</span> &#125;;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">\"production\"</span> !== <span class=\"string\">'production'</span>) &#123;</span><br><span class=\"line\">  warn(<span class=\"string\">'props must be strings when using array syntax.'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Note: 如果你偏向有通过 CLI 配置变量，可以查看一下 <a href=\"https://webpack.js.org/plugins/environment-plugin/\" target=\"_blank\" rel=\"noopener\">EnvironmentPlugin</a>。它和<code>DefinePlugin</code>类似，但读环境并且自动替换<code>process.env</code>表达式。</p>\n</blockquote>\n<p>2.<code>UglifyJS</code>会移除掉所有<code>if</code>分支 - 因为<code>&quot;production&quot; !== &#39;production&#39;</code>永远返回 false ，插件理解代码内的判断分支将永远不会执行：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// vue/dist/vue.runtime.esm.js</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> val === <span class=\"string\">'string'</span>) &#123;</span><br><span class=\"line\">  name = camelize(val);</span><br><span class=\"line\">  res[name] = &#123; <span class=\"attr\">type</span>: <span class=\"literal\">null</span> &#125;;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">\"production\"</span> !== <span class=\"string\">'production'</span>) &#123;</span><br><span class=\"line\">  warn(<span class=\"string\">'props must be strings when using array syntax.'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>to</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// vue/dist/vue.runtime.esm.js (without minification)</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> val === <span class=\"string\">'string'</span>) &#123;</span><br><span class=\"line\">  name = camelize(val);</span><br><span class=\"line\">  res[name] = &#123; <span class=\"attr\">type</span>: <span class=\"literal\">null</span> &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Note: 不一定强制要求使用 <code>UglifyJSPlugin</code>。你可以使用其他不同的最小化工具，这些页支持移除无用代码（例如，the <a href=\"https://github.com/webpack-contrib/babel-minify-webpack-plugin\" target=\"_blank\" rel=\"noopener\">Babel Minify plugin</a> or the <a href=\"https://github.com/roman01la/webpack-closure-compiler\" target=\"_blank\" rel=\"noopener\">Google Closure Compiler plugin</a>）</p>\n</blockquote>\n<h4 id=\"Further-Reading\"><a href=\"#Further-Reading\" class=\"headerlink\" title=\"Further Reading\"></a>Further Reading</h4><ul>\n<li><a href=\"https://superuser.com/questions/284342/what-are-path-and-other-environment-variables-and-how-can-i-set-or-use-them\" target=\"_blank\" rel=\"noopener\">What “environment variables” are</a></li>\n<li>Webpack docs about: <a href=\"https://webpack.js.org/plugins/define-plugin/\" target=\"_blank\" rel=\"noopener\"><code>DefinePlugin</code></a>, <a href=\"https://webpack.js.org/plugins/environment-plugin/\" target=\"_blank\" rel=\"noopener\"><code>EnvironmentPlugin</code></a></li>\n</ul>\n<h3 id=\"Use-ES-Modules-使用-ES-模块\"><a href=\"#Use-ES-Modules-使用-ES-模块\" class=\"headerlink\" title=\"Use ES Modules 使用 ES 模块\"></a>Use ES Modules 使用 ES 模块</h3><p>下面这个方式利用 <a href=\"https://ponyfoo.com/articles/es6-modules-in-depth\" target=\"_blank\" rel=\"noopener\">ES modules</a> 减小前端体积。</p>\n<p>当你使用 ES module，webpack 有能力去做 tree-shaking。Tree-shaking 贯穿整个依赖树，检查那些依赖被使用，移除无用依赖。因此，如果你使用 ES module 语法，webpack 可以排除掉无用代码：</p>\n<ol>\n<li>一个有多个 export 的文件，但是 app 只需要其中一个：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// comments.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> render = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123; <span class=\"keyword\">return</span> <span class=\"string\">'Rendered!'</span>; &#125;;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> commentRestEndpoint = <span class=\"string\">'/rest/comments'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// index.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; render &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./comments.js'</span>;</span><br><span class=\"line\">render();</span><br></pre></td></tr></table></figure>\n<ol>\n<li>webpack 理解 <code>commentRestEndPoint</code>没有使用，同时不能在一个 bundle 中生成单独的 export：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// bundle.js (part that corresponds to comments.js)</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">module, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">  \"use strict\"</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> render = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123; <span class=\"keyword\">return</span> <span class=\"string\">'Rendered!'</span>; &#125;;</span><br><span class=\"line\">  <span class=\"comment\">/* harmony export (immutable) */</span> __webpack_exports__[<span class=\"string\">\"a\"</span>] = render;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> commentRestEndpoint = <span class=\"string\">'/rest/comments'</span>;</span><br><span class=\"line\">  <span class=\"comment\">/* unused harmony export commentRestEndpoint */</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<ol>\n<li><code>UglifyJSPlugin</code>移除无用变量：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// bundle.js (part that corresponds to comments.js)</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">n,e</span>)</span>&#123;<span class=\"string\">\"use strict\"</span>;<span class=\"keyword\">var</span> r=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"keyword\">return</span><span class=\"string\">\"Rendered!\"</span>&#125;;e.b=r&#125;)</span><br></pre></td></tr></table></figure>\n<p>如果他们都是有 ES module 编写，就是与一些库并存时也是生效的。</p>\n<blockquote>\n<p>Note: 在 webpack 中，tree-shaking 没有 minifier 是无法生效的。 webpack 仅仅移除了没有被用到的 export 变量；<code>UglifyJSPlugin</code>才会移除无用代码。所以如果你编译打包时没有使用 minifier，打包后体积并不会更小。你也可以不一定使用这个插件。其他最小化的插件也支持移除 dead code（例如：<a href=\"https://github.com/webpack-contrib/babel-minify-webpack-plugin\" target=\"_blank\" rel=\"noopener\">Babel Minify plugin</a> or <a href=\"https://github.com/roman01la/webpack-closure-compiler\" target=\"_blank\" rel=\"noopener\">Google Closure Compiler plugin</a>）</p>\n<p>Warning: 不要将 ES module 编译到 CommonJS 中。 如果你使用 Babel <code>babel-preset-env</code> or <code>babel-preset-es2015</code>，检查一下当前的配置。默认情况下， ES <code>import</code> and <code>export</code> to CommonJS <code>require</code> and <code>module.exports</code>。通过设置 option 来禁止掉<a href=\"https://github.com/babel/babel/tree/master/experimental/babel-preset-env\" target=\"_blank\" rel=\"noopener\">Pass the <code>{ modules: false }</code> option</a>。</p>\n</blockquote>\n<h4 id=\"Futher-reading\"><a href=\"#Futher-reading\" class=\"headerlink\" title=\"Futher reading\"></a>Futher reading</h4><ul>\n<li><a href=\"https://ponyfoo.com/articles/es6-modules-in-depth\" target=\"_blank\" rel=\"noopener\">“ES6 Modules in depth”</a></li>\n<li>Webpack docs <a href=\"https://webpack.js.org/guides/tree-shaking/\" target=\"_blank\" rel=\"noopener\">about tree shaking</a></li>\n</ul>\n<h3 id=\"Optimize-images-优化图片\"><a href=\"#Optimize-images-优化图片\" class=\"headerlink\" title=\"Optimize images 优化图片\"></a>Optimize images 优化图片</h3><p>图片基本会占局页面一半以上体积。虽然它们不像 JavaScript 那么重要（比如它们不会阻止页面渲染），但图片仍然会占用掉一大部分带宽。利用<code>url-loader</code>，<code>svg-url-loader</code>和<code>image-webpack-loader</code>来在 webpack 中进行优化。</p>\n<p><code>url-loader</code> 允许将小静态文件打包进 app。没有配置，他需要通过 file，将它放在编译后的打包 bundle 内并返回一个这个文件的 url。然而，如果我们注明<code>limit</code>选项，它将会 encode 成更小的文件 base64 文件 url。这是可以将图片放在Javascript 代码中，同时节省 HTTP 请求：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack.config.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.(jpe?g|png|gif)$/</span>,</span><br><span class=\"line\">        loader: <span class=\"string\">'url-loader'</span>,</span><br><span class=\"line\">        options: &#123;</span><br><span class=\"line\">          <span class=\"comment\">// Inline files smaller than 10 kB (10240 bytes)</span></span><br><span class=\"line\">          limit: <span class=\"number\">10</span> * <span class=\"number\">1024</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    ],</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// index.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> imageUrl <span class=\"keyword\">from</span> <span class=\"string\">'./image.png'</span>;</span><br><span class=\"line\"><span class=\"comment\">// → If image.png is smaller than 10 kB, `imageUrl` will include</span></span><br><span class=\"line\"><span class=\"comment\">// the encoded image: 'data:image/png;base64,iVBORw0KGg…'</span></span><br><span class=\"line\"><span class=\"comment\">// → If image.png is larger than 10 kB, the loader will create a new file,</span></span><br><span class=\"line\"><span class=\"comment\">// and `imageUrl` will include its url: `/2fcd56a1920be.png`</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Note: 内联图片减少了独立请求的数量，这是很好的方式（<a href=\"https://blog.octo.com/en/http2-arrives-but-sprite-sets-aint-no-dead/\" target=\"_blank\" rel=\"noopener\">even with HTTP/2</a>），但是会增加 bundle下载和转换的时间和内存的消耗。一定要确保不要嵌入超大图片或者较多的图片 - 否则增加的 bundle 的时间将会掩盖做成内联图片的收益。</p>\n</blockquote>\n<p><code>svg-url-loader</code>与<code>url-loader</code>类似 - 都是将使用 <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/percent-encoding\" target=\"_blank\" rel=\"noopener\">URL encoding</a>  encode 文件。这对对于 SVG 图片很奏效 - 因为 SVG 文件是文本，encoding 在体积上更有效率：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack.config.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.svg$/</span>,</span><br><span class=\"line\">        loader: <span class=\"string\">'svg-url-loader'</span>,</span><br><span class=\"line\">        options: &#123;</span><br><span class=\"line\">          <span class=\"comment\">// Inline files smaller than 10 kB (10240 bytes)</span></span><br><span class=\"line\">          limit: <span class=\"number\">10</span> * <span class=\"number\">1024</span>,</span><br><span class=\"line\">          <span class=\"comment\">// Remove the quotes from the url</span></span><br><span class=\"line\">          <span class=\"comment\">// (they’re unnecessary in most cases)</span></span><br><span class=\"line\">          noquotes: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    ],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Note: svg-url-loader 拥有改善 IE 浏览器支持的 options，但是在其他浏览器中更糟糕。如果你需要兼容 IE 浏览器，<a href=\"https://github.com/bhovhannes/svg-url-loader#iesafe\" target=\"_blank\" rel=\"noopener\">设置 iesafe: true 选项</a></p>\n</blockquote>\n<p><code>image-webpack-loader</code>压缩图片使之变小。它支持 JPG，PNG，GIF 和 SVG，因为我们将会使用它所有类型。</p>\n<p>这个 loader 不会将图片嵌入在应用内，因此它必须与<code>url-loader</code>和<code>svg-url-loader</code>配合使用。避免复制粘贴到相同的 rules 中（一个用于 JPG/PNG/GIF 图片，另一个用于 SVG 图片），我们来使用<code>enforce: pre</code>作为单独的一个 rule 涵盖这个 loader：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack.config.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.(jpe?g|png|gif|svg)$/</span>,</span><br><span class=\"line\">        loader: <span class=\"string\">'image-webpack-loader'</span>,</span><br><span class=\"line\">        <span class=\"comment\">// This will apply the loader before the other ones</span></span><br><span class=\"line\">        enforce: <span class=\"string\">'pre'</span>,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    ],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>默认 loader 的设置就已经可以了 - 但是如果你想要更深入的配置，查看 <a href=\"https://github.com/tcoopman/image-webpack-loader#options\" target=\"_blank\" rel=\"noopener\">the plugin options</a>。为了选择哪些 options 需要明确，可以查看 Addy Osmani 的 <a href=\"https://images.guide/\" target=\"_blank\" rel=\"noopener\">guide on image optimization</a></p>\n<h4 id=\"Further-reading-1\"><a href=\"#Further-reading-1\" class=\"headerlink\" title=\"Further reading\"></a>Further reading</h4><ul>\n<li><a href=\"https://stackoverflow.com/questions/201479/what-is-base-64-encoding-used-for\" target=\"_blank\" rel=\"noopener\">“What is base64 encoding used for?”</a></li>\n<li>Addy Osmani’s <a href=\"https://images.guide/\" target=\"_blank\" rel=\"noopener\">guide on image optimization</a></li>\n</ul>\n<h3 id=\"Optimize-dependencies-优化依赖\"><a href=\"#Optimize-dependencies-优化依赖\" class=\"headerlink\" title=\"Optimize dependencies 优化依赖\"></a>Optimize dependencies 优化依赖</h3><p>平均一半以上的 Javascript 体积大小来源于依赖包，并且这些可能都不是必要的。</p>\n<p>举一个例子来说，Lodash（v4.17.4）增加了最小化代码的 72KB 大小到 bundle 中。但是如果你仅仅用到它的20个方法，大于 65 KB 没有用处。</p>\n<p>另外一个例子就是 Moment.js。 V2.19.1版本最小化后有 223KB，体积巨大 - 截至2017年10月一个页面内的 Javascript 平均体积是 452KB。但是，本地文件的体积占 170KB。如果你没有用到 多语言版 Moment.js，这些文件都会没有目的地使 bundle 更臃肿。</p>\n<p>所有这些依赖都可以被轻易优化。我们在 Github repo 手机了优化的建议，<a href=\"https://github.com/GoogleChromeLabs/webpack-libs-optimizations\" target=\"_blank\" rel=\"noopener\">check it out</a>！</p>\n<h3 id=\"Enable-module-concatenation-for-ES-modules-aka-scope-hoisting\"><a href=\"#Enable-module-concatenation-for-ES-modules-aka-scope-hoisting\" class=\"headerlink\" title=\"Enable module concatenation for ES modules (aka scope hoisting)\"></a>Enable module concatenation for ES modules (aka scope hoisting)</h3><p>当你构建一个 bundle 时，webpack 将每一个 module 封装进 function 中：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// index.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;render&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./comments.js'</span>;</span><br><span class=\"line\">render();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// comments.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span>(<span class=\"params\">data, target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Rendered!'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>to</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// bundle.js (part  of)</span></span><br><span class=\"line\"><span class=\"comment\">/* 0 */</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">module, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">  \"use strict\"</span>;</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.defineProperty(__webpack_exports__, <span class=\"string\">\"__esModule\"</span>, &#123; <span class=\"attr\">value</span>: <span class=\"literal\">true</span> &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> __WEBPACK_IMPORTED_MODULE_0__comments_js__ = __webpack_require__(<span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>(__WEBPACK_IMPORTED_MODULE_0__comments_js__[<span class=\"string\">\"a\"</span> <span class=\"comment\">/* render */</span>])();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;),</span><br><span class=\"line\"><span class=\"comment\">/* 1 */</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">module, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">  \"use strict\"</span>;</span><br><span class=\"line\">  __webpack_exports__[<span class=\"string\">\"a\"</span>] = render;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span>(<span class=\"params\">data, target</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Rendered!'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>在以前，这是使 CommonJS/AMD modules 互相分离所必须的。但是，这回增加体积同时性能堪忧。</p>\n<p>Webpack 2 介绍了 ES modules 的支持，不像 CommonJS 和 AMD modules 一样，而是能够不用将每一个 module 用 function 封装起来。同时 Webpack 3 利用<a href=\"https://webpack.js.org/plugins/module-concatenation-plugin/\" target=\"_blank\" rel=\"noopener\"><code>ModuleConcatenationPlugin</code></a>完成这样一个 bundle，下面是例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// index.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;render&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./comments.js'</span>;</span><br><span class=\"line\">render();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// comments.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span>(<span class=\"params\">data, target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Rendered!'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>to</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Unlike the previous snippet, this bundle has only one module</span></span><br><span class=\"line\"><span class=\"comment\">// which includes the code from both files</span></span><br><span class=\"line\"><span class=\"comment\">// 与前面的代码不同，这个 bundle 只有一个 module，同时包含两个文件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// bundle.js (part of; compiled with ModuleConcatenationPlugin)</span></span><br><span class=\"line\"><span class=\"comment\">/* 0 */</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">module, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">  \"use strict\"</span>;</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.defineProperty(__webpack_exports__, <span class=\"string\">\"__esModule\"</span>, &#123; <span class=\"attr\">value</span>: <span class=\"literal\">true</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// CONCATENATED MODULE: ./comments.js</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span>(<span class=\"params\">data, target</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Rendered!'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// CONCATENATED MODULE: ./index.js</span></span><br><span class=\"line\">  render();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>看到区别了吗？在这个 bundle 中， module 0 需要 module 1 的 render 方法。使用 <code>ModuleConcatenationPlugin</code>，<code>require</code>被直接简单的替换成 require 函数，同时 module 1 被删除删除掉了。这个 bundle 拥有更少的 modules，就有更少的 modules 损耗！</p>\n<p>启用这个功能，可以在插件列表中增加<code>ModuleConcatenationPlugin</code>：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack.config.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.optimize.ModuleConcatenationPlugin(),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>Note：想要知道为什么这个功能不是默认启用？Concatenating modules 很棒， <a href=\"https://twitter.com/TheLarkInn/status/925800563144454144\" target=\"_blank\" rel=\"noopener\">但是他会增加编译的时间同时破坏 module 的热更新</a>。这就是为什么只在生产环境中启用的原因了。</p>\n</blockquote>\n<h4 id=\"Further-reading-2\"><a href=\"#Further-reading-2\" class=\"headerlink\" title=\"Further reading\"></a>Further reading</h4><ul>\n<li>Webpack docs <a href=\"https://webpack.js.org/plugins/module-concatenation-plugin/\" target=\"_blank\" rel=\"noopener\">for the ModuleConcatenationPlugin</a></li>\n<li><a href=\"https://medium.com/webpack/brief-introduction-to-scope-hoisting-in-webpack-8435084c171f\" target=\"_blank\" rel=\"noopener\">“Brief introduction to scope hoisting”</a></li>\n<li>Detailed description of <a href=\"https://medium.com/webpack/webpack-freelancing-log-book-week-5-7-4764be3266f5\" target=\"_blank\" rel=\"noopener\">what this plugin does</a></li>\n</ul>\n<h3 id=\"Use-externals-if-you-have-both-webpack-and-non-webpack-code-如果代码中包含-webpack-和非-webpack-的代码要使用-externals\"><a href=\"#Use-externals-if-you-have-both-webpack-and-non-webpack-code-如果代码中包含-webpack-和非-webpack-的代码要使用-externals\" class=\"headerlink\" title=\"Use externals if you have both webpack and non-webpack code 如果代码中包含 webpack 和非 webpack 的代码要使用 externals\"></a>Use <code>externals</code> if you have both webpack and non-webpack code 如果代码中包含 webpack 和非 webpack 的代码要使用 externals</h3><p>你可能拥有一个体积庞大的工程，其中一部分代码可以使用 webpack 编译，而有一些代码又不能。比如一个视频网站，播放器的 widget 可能通过 webpack 编译，但是其周围页面区域可能不是：</p>\n<p><img src=\"https://img30.360buyimg.com/uba/jfs/t15334/148/2273118093/210074/8260a296/5a81599dN148751d5.png\" alt=\"video-hosting\"></p>\n<p>如果两部分代码有相同的依赖，你可以共享这些依赖以便减少重复下载耗时。<a href=\"https://webpack.js.org/configuration/externals/\" target=\"_blank\" rel=\"noopener\">the webpack’s <code>externals</code> option</a>就干了这件事 - 它用变量或者外部引用来替代 modules。</p>\n<h4 id=\"如果依赖是挂载到-window\"><a href=\"#如果依赖是挂载到-window\" class=\"headerlink\" title=\"如果依赖是挂载到 window\"></a>如果依赖是挂载到 window</h4><p>如果你的非 webpack 代码依靠这些依赖，这些依赖是挂载 window 上的变量，可以将依赖名称 alias 成变量名：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack.config.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  externals: &#123;</span><br><span class=\"line\">    <span class=\"string\">'react'</span>: <span class=\"string\">'React'</span>,</span><br><span class=\"line\">    <span class=\"string\">'react-dom'</span>: <span class=\"string\">'ReactDOM'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>利用这个配置，webpack 将不会打包 <code>react</code> 和 <code>react-dom</code>包。取而代之，他们会被替换成下面这个样子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// bundle.js (part of)</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">module, exports</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// A module that exports `window.React`. Without `externals`,</span></span><br><span class=\"line\">  <span class=\"comment\">// this module would include the whole React bundle</span></span><br><span class=\"line\">  <span class=\"built_in\">module</span>.exports = React;</span><br><span class=\"line\">&#125;),</span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">module, exports</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// A module that exports `window.ReactDOM`. Without `externals`,</span></span><br><span class=\"line\">  <span class=\"comment\">// this module would include the whole ReactDOM bundle</span></span><br><span class=\"line\">  <span class=\"built_in\">module</span>.exports = ReactDOM;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h4 id=\"如果依赖是当做-AMD-包被加载\"><a href=\"#如果依赖是当做-AMD-包被加载\" class=\"headerlink\" title=\"如果依赖是当做 AMD 包被加载\"></a>如果依赖是当做 AMD 包被加载</h4><p>如果你的非 webpack 代码没有将依赖暴露挂载到 window 上，这就更复杂了。但是如果非 webpack 代码使用 AMD 包的形式消费了这些依赖，你仍然可以避免重复的代码加载两次。</p>\n<p>具体如何做呢？将 webpack 代码编译成一个 AMD module 同时又名成一个库 URLs：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack.config.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  output: &#123; <span class=\"attr\">libraryTarget</span>: <span class=\"string\">'amd'</span> &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  externals: &#123;</span><br><span class=\"line\">    <span class=\"string\">'react'</span>: &#123; <span class=\"attr\">amd</span>: <span class=\"string\">'/libraries/react.min.js'</span> &#125;,</span><br><span class=\"line\">    <span class=\"string\">'react-dom'</span>: &#123; <span class=\"attr\">amd</span>: <span class=\"string\">'/libraries/react-dom.min.js'</span> &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>Webpack 将会把 bundle 包装进 <code>define()</code>同时让它依赖于这些URLs：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// bundle.js (beginning)</span></span><br><span class=\"line\">define([<span class=\"string\">\"/libraries/react.min.js\"</span>, <span class=\"string\">\"/libraries/react-dom.min.js\"</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; … &#125;);</span><br></pre></td></tr></table></figure>\n<p>如果非 webpack 代码使用相同的 URLs 加载依赖，这些文件将会加载一次 - 多余的请求会使用缓存。</p>\n<blockquote>\n<p>Note：webpack 只是替换那些<code>externals</code>对象中的准确匹配的 keys 的引用。这意味着如果你的代码这样写<code>import React from &#39;react/umd/react.production.min.js&#39;</code>，这个库是不会被 bundle 排除掉的。这是因为 - webpack 并不知道 <code>import &#39;react&#39;</code> 和 <code>import &#39;react/umd/react.production.min.js&#39;</code> 是同一个库，这样比较谨慎。</p>\n</blockquote>\n<h4 id=\"Further-reading-3\"><a href=\"#Further-reading-3\" class=\"headerlink\" title=\"Further reading\"></a>Further reading</h4><ul>\n<li>Webpack docs <a href=\"https://webpack.js.org/configuration/externals/\" target=\"_blank\" rel=\"noopener\">on <code>externals</code></a></li>\n</ul>\n<h3 id=\"Summing-up-总结\"><a href=\"#Summing-up-总结\" class=\"headerlink\" title=\"Summing up 总结\"></a>Summing up 总结</h3><ul>\n<li>Minimize your code with the <code>UglifyJsPlugin</code> and loader options</li>\n<li>Remove the development-only code with the <code>DefinePlugin</code></li>\n<li>Use ES modules to enable tree shaking</li>\n<li>Compress images</li>\n<li>Apply dependency-specific optimizations</li>\n<li>Enable module concatenation</li>\n<li>Use <code>externals</code> if this makes sense for you</li>\n</ul>\n<h2 id=\"Make-use-of-long-term-caching-利用好长时缓存\"><a href=\"#Make-use-of-long-term-caching-利用好长时缓存\" class=\"headerlink\" title=\"Make use of long-term caching 利用好长时缓存\"></a>Make use of long-term caching 利用好长时缓存</h2><p>作者 <a href=\"https://developers.google.com/web/resources/contributors/iamakulov\" target=\"_blank\" rel=\"noopener\">Ivan Akulov</a></p>\n<p>在做完优化应用体积之后的下一步提升应用加载时间的就是缓存。在客户端中使用缓存作为应用的一部分同时每一次减少重新下载。</p>\n<h3 id=\"Use-bundle-versioning-and-cache-headers-使用-bundle-版本和缓存头信息\"><a href=\"#Use-bundle-versioning-and-cache-headers-使用-bundle-版本和缓存头信息\" class=\"headerlink\" title=\"Use bundle versioning and cache headers 使用 bundle 版本和缓存头信息\"></a>Use bundle versioning and cache headers 使用 bundle 版本和缓存头信息</h3><p>做缓存通用的解决办法：</p>\n<ol>\n<li>告诉浏览器缓存一个文件很长时间（比如一年）</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Server header</span><br><span class=\"line\">Cache-Control: max-age=31536000</span><br></pre></td></tr></table></figure>\n<p>Note：如果你不熟悉 <code>Cache-Control</code>做了什么，你可以看一下Jake Archibald 的精彩博文 <a href=\"https://jakearchibald.com/2016/caching-best-practices/\" target=\"_blank\" rel=\"noopener\">on caching best practices</a></p>\n<p>2.当文件改变需要强制重新下载时候去重命名这些文件</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- Before the change --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"./index-v15.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- After the change --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"./index-v16.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这些方法告诉浏览器下载这些 JS 文件，缓存起来。浏览器将会只在文件名变化是才会请求网络（或者是缓存失效）。</p>\n<p>使用 webpack，你也可以做同样的事，但是是可以使用版本号来解决，你需要明确这个文件的 hash。使用 <a href=\"https://webpack.js.org/configuration/output/#output-filename\" target=\"_blank\" rel=\"noopener\"><code>[chunkhash]</code></a> 可以将 hash 值包含进文件名中：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack.config.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: <span class=\"string\">'./index.js'</span>,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    filename: <span class=\"string\">'bundle.[chunkhash].js'</span>,</span><br><span class=\"line\">        <span class=\"comment\">// → bundle.8e0d62a03.js</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Note: webpack 可能会生成不同的 hash 就是 bundle 相同 - 比如你重名了了一个文件或者重新在不同的操作系统下编译了一个 bundle。 <a href=\"https://github.com/webpack/webpack/issues/1479\" target=\"_blank\" rel=\"noopener\">This is a bug.</a><br>如果你需要将文件名发送给客户端，也可以使用 <code>HtmlWebpackPlugin</code> 或者 <code>WebpackManifestPlugin</code>。</p>\n</blockquote>\n<p><code>HtmlWebpackPlugin</code> 很简单，但是灵活性欠缺一些。编译时，插件会生成一个 HTML 文件，这其中包括所有的编译后的资源文件。如果你的业务逻辑不复杂，这就非常适合你：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- index.html --&gt;</span></span><br><span class=\"line\"><span class=\"meta\">&lt;!doctype html&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- ... --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"bundle.8e0d62a03.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><code>WebpackManifestPlugin</code>更灵活一些，它可以帮助你解决业务负责的部分。编译时它会生成一个 JSON 文件，这文件保存这没有 hash 值文件与有 hash 文件之间的映射。服务端利用这个 JSON 可以识别出那个文件有效：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// manifest.json</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"bundle.js\"</span>: <span class=\"string\">\"bundle.8e0d62a03.js\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Further-reading-4\"><a href=\"#Further-reading-4\" class=\"headerlink\" title=\"Further reading\"></a>Further reading</h4><ul>\n<li>Jake Archibald <a href=\"https://jakearchibald.com/2016/caching-best-practices/\" target=\"_blank\" rel=\"noopener\">about caching best practices</a></li>\n</ul>\n<h3 id=\"Extract-dependencies-and-runtime-into-a-separate-file-外部依赖和独立文件运行时\"><a href=\"#Extract-dependencies-and-runtime-into-a-separate-file-外部依赖和独立文件运行时\" class=\"headerlink\" title=\"Extract dependencies and runtime into a separate file 外部依赖和独立文件运行时\"></a>Extract dependencies and runtime into a separate file 外部依赖和独立文件运行时</h3><h4 id=\"Dependencies-依赖包\"><a href=\"#Dependencies-依赖包\" class=\"headerlink\" title=\"Dependencies 依赖包\"></a>Dependencies 依赖包</h4><p>App 依赖通常情况下趋向于比实际 app 内代码中更少的变化。如果你将他们移到独立的文件中，浏览器将可以把他们独立缓存起来 - 同时不会每次 app 代码改变时重新下载。</p>\n<blockquote>\n<p>Key Term: 在 webpack 的技术中，利用 app 代码拆分文件被称为 <code>chunks</code>。我们后面会用到这个名词。</p>\n</blockquote>\n<p>为了将依赖包提取到单独的 chunk 中，下面分为三步：</p>\n<ol>\n<li>使用<code>[name].[chunkname].js</code>替换<code>output</code>的文件名：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack.config.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Before</span></span><br><span class=\"line\">    filename: <span class=\"string\">'bundle.[chunkhash].js'</span>,</span><br><span class=\"line\">    <span class=\"comment\">// After</span></span><br><span class=\"line\">    filename: <span class=\"string\">'[name].[chunkhash].js'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>当 webpack 构建应用时，它会用一个带有 chunk 的名称来替换<code>[name]</code>。如果没有添加<code>[name]</code>部分，我们不得不通过 chunks 之间的 hash 区别来比较他们的区别 - 那就太难了！</p>\n<ol>\n<li>将<code>entry</code>转成一个对象：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack.config.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Before</span></span><br><span class=\"line\">  entry: <span class=\"string\">'./index.js'</span>,</span><br><span class=\"line\">  <span class=\"comment\">// After</span></span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    main: <span class=\"string\">'./index.js'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>在这段代码中，”main” 对象是一个 chunk 的名字。这个名字将会被步骤 1 里面的 <code>[name]</code>代替。目前为止，如果你构建一个 app，chunk 就会包括整个 app 的代码 - 就像我们没有做这些步骤一样。但是很快就会产生变化。</p>\n<ol>\n<li>添加  <a href=\"https://webpack.js.org/plugins/commons-chunk-plugin/\" target=\"_blank\" rel=\"noopener\"><code>CommonsChunkPlugin</code></a>：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack.config.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class=\"line\">      <span class=\"comment\">// A name of the chunk that will include the dependencies.</span></span><br><span class=\"line\">      <span class=\"comment\">// This name is substituted in place of [name] from step 1</span></span><br><span class=\"line\">      name: <span class=\"string\">'vendor'</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// A function that determines which modules to include into this chunk</span></span><br><span class=\"line\">      minChunks: <span class=\"function\"><span class=\"params\">module</span> =&gt;</span> <span class=\"built_in\">module</span>.context &amp;&amp;</span><br><span class=\"line\">        <span class=\"built_in\">module</span>.context.includes(<span class=\"string\">'node_modules'</span>),</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这个插件将包括全部<code>node_modules</code>路径下的 modules 同时将他们移到一个单独的文件中，这个文件被称为 <code>vendor.[chunkhash].js</code>。</p>\n<p>完成了上面的步骤，每一次 build 都将生成两个文件。浏览器会将他们单独缓存 - 以便代码该生改变时重新下载。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ webpack</span><br><span class=\"line\">Hash: ac01483e8fec1fa70676</span><br><span class=\"line\">Version: webpack 3.8.1</span><br><span class=\"line\">Time: 3816ms</span><br><span class=\"line\">                           Asset   Size  Chunks             Chunk Names</span><br><span class=\"line\">  ./main.00bab6fd3100008a42b0.js  82 kB       0  [emitted]  main</span><br><span class=\"line\">./vendor.d9e134771799ecdf9483.js  47 kB       1  [emitted]  vendor</span><br></pre></td></tr></table></figure>\n<h4 id=\"Webpack-runtime-code\"><a href=\"#Webpack-runtime-code\" class=\"headerlink\" title=\"Webpack runtime code\"></a>Webpack runtime code</h4><p>不幸的是，仅仅抽取<code>vendor</code>是不够的。如果你试图在应用代码中修改一些东西：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// index.js</span></span><br><span class=\"line\">…</span><br><span class=\"line\">…</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// E.g. add this:</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Wat'</span>);</span><br></pre></td></tr></table></figure>\n<p>你会注意到<code>vendor</code>的 hash 值也会改变：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">                           Asset   Size  Chunks             Chunk Names</span><br><span class=\"line\">./vendor.d9e134771799ecdf9483.js  47 kB       1  [emitted]  vendor</span><br></pre></td></tr></table></figure>\n<p>to</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">                            Asset   Size  Chunks             Chunk Names</span><br><span class=\"line\">./vendor.e6ea4504d61a1cc1c60b.js  47 kB       1  [emitted]  vendor</span><br></pre></td></tr></table></figure>\n<p>发生这样的事是因为 webpack 打包时，一部分 modules 的代码，拥有 <a href=\"https://webpack.js.org/concepts/manifest/\" target=\"_blank\" rel=\"noopener\"><em>a runtime</em></a> - 管理模块执行一部分代码。当你将代码拆分成多个文件时，这小部分代码在 chunk ids 和 匹配的文件之间开始了一个映射：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// vendor.e6ea4504d61a1cc1c60b.js</span></span><br><span class=\"line\">script.src = __webpack_require__.p + chunkId + <span class=\"string\">\".\"</span> + &#123;</span><br><span class=\"line\">  <span class=\"string\">\"0\"</span>: <span class=\"string\">\"2f2269c7f0a55a5c1871\"</span></span><br><span class=\"line\">&#125;[chunkId] + <span class=\"string\">\".js\"</span>;</span><br></pre></td></tr></table></figure>\n<p>Webpack 将最新生成的 chunk 包含了这个 runtime 内，这个 chunk 就是我们代码中的<code>vendor</code>。与此同时每一次任何 <code>chunk</code>的改变，这一小部分代码也改变，导致整个 <code>vendor</code> chunk 也改变、</p>\n<p>为了解决这个问题，我们将这个 runtime 转义到一个独立的文件中，通过<code>CommonsChunkPlugin</code>创建一个额外的空的 chunk：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack.config.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class=\"line\">      name: <span class=\"string\">'vendor'</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">      minChunks: <span class=\"function\"><span class=\"params\">module</span> =&gt;</span> <span class=\"built_in\">module</span>.context &amp;&amp;</span><br><span class=\"line\">        <span class=\"built_in\">module</span>.context.includes(<span class=\"string\">'node_modules'</span>),</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// This plugin must come after the vendor one (because webpack</span></span><br><span class=\"line\">    <span class=\"comment\">// includes runtime into the last chunk)</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class=\"line\">      name: <span class=\"string\">'runtime'</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// minChunks: Infinity means that no app modules</span></span><br><span class=\"line\">      <span class=\"comment\">// will be included into this chunk</span></span><br><span class=\"line\">      minChunks: <span class=\"literal\">Infinity</span>,</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>完成这一部分改变，每一次 build 都将生成三个文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ webpack</span><br><span class=\"line\">Hash: ac01483e8fec1fa70676</span><br><span class=\"line\">Version: webpack 3.8.1</span><br><span class=\"line\">Time: 3816ms</span><br><span class=\"line\">                            Asset     Size  Chunks             Chunk Names</span><br><span class=\"line\">   ./main.00bab6fd3100008a42b0.js    82 kB       0  [emitted]  main</span><br><span class=\"line\"> ./vendor.26886caf15818fa82dfa.js    46 kB       1  [emitted]  vendor</span><br><span class=\"line\">./runtime.79f17c27b335abc7aaf4.js  1.45 kB       3  [emitted]  runtime</span><br></pre></td></tr></table></figure>\n<p>将他们反过来顺序添加到 index.html 中，你就搞定了：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- index.html --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"./runtime.79f17c27b335abc7aaf4.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"./vendor.26886caf15818fa82dfa.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"./main.00bab6fd3100008a42b0.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"Further-reading-5\"><a href=\"#Further-reading-5\" class=\"headerlink\" title=\"Further reading\"></a>Further reading</h4><ul>\n<li>Webpack guide <a href=\"https://webpack.js.org/guides/caching/\" target=\"_blank\" rel=\"noopener\">on long term caching</a></li>\n<li>Webpack docs <a href=\"https://webpack.js.org/concepts/manifest/\" target=\"_blank\" rel=\"noopener\">about webpack runtime and manifest</a></li>\n<li><a href=\"https://medium.com/webpack/webpack-bits-getting-the-most-out-of-the-commonschunkplugin-ab389e5f318\" target=\"_blank\" rel=\"noopener\">“Getting the most out of the CommonsChunkPlugin”</a></li>\n</ul>\n<h3 id=\"Inline-webpack-runtime-to-save-an-extra-HTTP-request-内联-webpack-runtime-节省额外的-HTTP-请求\"><a href=\"#Inline-webpack-runtime-to-save-an-extra-HTTP-request-内联-webpack-runtime-节省额外的-HTTP-请求\" class=\"headerlink\" title=\"Inline webpack runtime to save an extra HTTP request 内联 webpack runtime 节省额外的 HTTP  请求\"></a>Inline webpack runtime to save an extra HTTP request 内联 webpack runtime 节省额外的 HTTP  请求</h3><p>为了做的更好，尽力把 webpack runtime 内联在 HTML 请求里。下面举例：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- index.html --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"./runtime.79f17c27b335abc7aaf4.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这样做：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- index.html --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">!<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">n</span>(<span class=\"params\">r</span>)</span>&#123;<span class=\"keyword\">if</span>(t[r])<span class=\"keyword\">return</span> t[r].exports;…&#125;&#125; ([]);</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这个 runtime 很小，内联它可以帮助你节省 HTTP 请求（尤其对 HTTP/1 重要；但是在 HTTP/2 就没有那么重要了，但是仍能够提高效率）。</p>\n<p>下面就来看看如何做。</p>\n<h4 id=\"如果使用-HtmlWebpackPlugin-来生成-HTML\"><a href=\"#如果使用-HtmlWebpackPlugin-来生成-HTML\" class=\"headerlink\" title=\"如果使用 HtmlWebpackPlugin 来生成 HTML\"></a>如果使用 HtmlWebpackPlugin 来生成 HTML</h4><p>如果使用 <a href=\"https://github.com/jantimon/html-webpack-plugin\" target=\"_blank\" rel=\"noopener\"><code>HtmlWebpackPlugin</code></a> 来生成 HTML 文件，<a href=\"https://github.com/rohitlodha/html-webpack-inline-chunk-plugin\" target=\"_blank\" rel=\"noopener\"><code>InlineChunkWebpackPlugin</code></a> 就足够了。</p>\n<h4 id=\"如果使用自己的定制服务逻辑来生成-HTML\"><a href=\"#如果使用自己的定制服务逻辑来生成-HTML\" class=\"headerlink\" title=\"如果使用自己的定制服务逻辑来生成 HTML\"></a>如果使用自己的定制服务逻辑来生成 HTML</h4><ol>\n<li>将 runtime 名称成静态明确的文件名：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack.config.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class=\"line\">      name: <span class=\"string\">'runtime'</span>,</span><br><span class=\"line\">      minChunks: <span class=\"literal\">Infinity</span>,</span><br><span class=\"line\">      filename: <span class=\"string\">'runtime.js'</span>,</span><br><span class=\"line\">        <span class=\"comment\">// → Now the runtime file will be called</span></span><br><span class=\"line\">        <span class=\"comment\">// “runtime.js”, not “runtime.79f17c27b335abc7aaf4.js”</span></span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>将方便的方式将 runtime.js 嵌入进去。比如：Node.js 和 Express</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// server.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> runtimeContent = fs.readFileSync(<span class=\"string\">'./runtime.js'</span>, <span class=\"string\">'utf-8'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(<span class=\"string\">'/'</span>, (req, res) =&gt; &#123;</span><br><span class=\"line\">  res.send(<span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">    …</span></span><br><span class=\"line\"><span class=\"string\">    &lt;script&gt;<span class=\"subst\">$&#123;runtimeContent&#125;</span>&lt;/script&gt;</span></span><br><span class=\"line\"><span class=\"string\">    …</span></span><br><span class=\"line\"><span class=\"string\">  `</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"懒加载\"><a href=\"#懒加载\" class=\"headerlink\" title=\"懒加载\"></a>懒加载</h3><p>有时候，页面拥有或多或少的部分：</p>\n<ul>\n<li>如果你在 YouTube 上加载一个视频页面，相比评论区域你更在乎视频区域。这就是视频要比评论区域重要。</li>\n<li>如果你在一个新闻网站打开一个报道，相比广告区域你更关心文章的内容。这就是文字比广告更重要。</li>\n</ul>\n<p>在这些案例中，通过仅下载最重要的部分，懒加载剩余区域能够提升最初的加载性能。使用 <a href=\"https://webpack.js.org/api/module-methods/#import-\" target=\"_blank\" rel=\"noopener\">the <code>import()</code> function</a> 和 <a href=\"https://webpack.js.org/guides/code-splitting/\" target=\"_blank\" rel=\"noopener\">code-splitting</a> 解决这个问题：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// videoPlayer.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">renderVideoPlayer</span>(<span class=\"params\"></span>) </span>&#123; … &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// comments.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">renderComments</span>(<span class=\"params\"></span>) </span>&#123; … &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// index.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;renderVideoPlayer&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./videoPlayer'</span>;</span><br><span class=\"line\">renderVideoPlayer();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// …Custom event listener</span></span><br><span class=\"line\">onShowCommentsClick(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">import</span>(<span class=\"string\">'./comments'</span>).then(<span class=\"function\">(<span class=\"params\">comments</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    comments.renderComments();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><code>import()</code>明确表示你期望动态地加载独立的 module。当 webpack 看到 <code>import(&#39;./module.js&#39;)</code>时，他就会将这个 module 移到独立的 chunk 中：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ webpack</span><br><span class=\"line\">Hash: 39b2a53cb4e73f0dc5b2</span><br><span class=\"line\">Version: webpack 3.8.1</span><br><span class=\"line\">Time: 4273ms</span><br><span class=\"line\">                            Asset     Size  Chunks             Chunk Names</span><br><span class=\"line\">      ./0.8ecaf182f5c85b7a8199.js  22.5 kB       0  [emitted]</span><br><span class=\"line\">   ./main.f7e53d8e13e9a2745d6d.js    60 kB       1  [emitted]  main</span><br><span class=\"line\"> ./vendor.4f14b6326a80f4752a98.js    46 kB       2  [emitted]  vendor</span><br><span class=\"line\">./runtime.79f17c27b335abc7aaf4.js  1.45 kB       3  [emitted]  runtime</span><br></pre></td></tr></table></figure>\n<p>并且只在代码执行到 <code>import()</code> 才会下载。</p>\n<p>这将会让 main bundle 更小，提升初始加载的时间。更重要的是改进缓存 - 如果你修改 main chunk 的代码，其他部分的 chunk 也不会受影响。</p>\n<blockquote>\n<p>Note: 如果使用 Babel 编译代码，你会因为 Babel 还不认识 <em>import()</em> 而遇到语法错误抛出来。可以使用 <a href=\"https://www.npmjs.com/package/babel-plugin-syntax-dynamic-import\" target=\"_blank\" rel=\"noopener\"><code>syntax-dynamic-import</code></a> 解决这个错误。</p>\n</blockquote>\n<h4 id=\"Further-reading-6\"><a href=\"#Further-reading-6\" class=\"headerlink\" title=\"Further reading\"></a>Further reading</h4><ul>\n<li>Webpack docs <a href=\"https://webpack.js.org/api/module-methods/#import-\" target=\"_blank\" rel=\"noopener\">for the <code>import()</code> function</a></li>\n<li>The JavaScript proposal <a href=\"https://github.com/tc39/proposal-dynamic-import\" target=\"_blank\" rel=\"noopener\">for implementing the <code>import()</code> syntax</a></li>\n</ul>\n<h3 id=\"Split-the-code-into-routes-and-pages-拆分代码到路由和页面中\"><a href=\"#Split-the-code-into-routes-and-pages-拆分代码到路由和页面中\" class=\"headerlink\" title=\"Split the code into routes and pages 拆分代码到路由和页面中\"></a>Split the code into routes and pages 拆分代码到路由和页面中</h3><p>如果你的应用拥有多个路由或者页面，但是代码中只有单独一个 JS 文件（一个单独的 main chunk），这看起来你正在每一个请求中节省额外的 bytes 带宽。举个例子，当用户正在访问你网站的首页：</p>\n<p><img src=\"https://img10.360buyimg.com/uba/jfs/t17272/291/466883786/44644/f5b82d7c/5a8159b0N4fe9f50d.png\" alt=\"site-home-page\"></p>\n<p>他们并不需要加载另外不同的页面上渲染文章标题的的代码 - 但是他们还是会加载到这段代码。更严重的是如果用户经常只访问首页，同时你还经常改变渲染文章标题的代码，webpack 将会对整个 bundle 失效 - 用户每次都会重复下载全部 app 的代码。</p>\n<p>如果我们将代码拆分到页面里（或者单页面应用的路由里），用户就会下载对他有意义的代码。更好的是，浏览器也会更好地缓存代码：当你改变首页的代码时，webpack 只会让相匹配的 chunk 失效。</p>\n<h4 id=\"For-single-page-apps-对于单页面应用\"><a href=\"#For-single-page-apps-对于单页面应用\" class=\"headerlink\" title=\"For single-page apps 对于单页面应用\"></a>For single-page apps 对于单页面应用</h4><p>通过路由拆分带页面引用，使用<code>import()</code>（看看 <a href=\"https://developers.google.com/web/fundamentals/performance/webpack/use-long-term-caching#lazy-loading\" target=\"_blank\" rel=\"noopener\">“Lazy-load code that you don’t need right now”</a>这部分）。如果你在使用一个框架，现在已经有成熟的方案：</p>\n<ul>\n<li><a href=\"https://reacttraining.com/react-router/web/guides/code-splitting\" target=\"_blank\" rel=\"noopener\">“Code Splitting”</a> in <code>react-router</code>‘s docs (for React)</li>\n<li><a href=\"https://router.vuejs.org/en/advanced/lazy-loading.html\" target=\"_blank\" rel=\"noopener\">“Lazy Loading Routes”</a> in <code>vue-router</code>‘s docs (for Vue.js)</li>\n</ul>\n<h4 id=\"For-traditional-multi-page-apps-对于传统的多页面应用\"><a href=\"#For-traditional-multi-page-apps-对于传统的多页面应用\" class=\"headerlink\" title=\"For traditional multi-page apps 对于传统的多页面应用\"></a>For traditional multi-page apps 对于传统的多页面应用</h4><p>通过页面拆分传统多页面应用，可以使用 webpack 的 <a href=\"https://webpack.js.org/concepts/entry-points/\" target=\"_blank\" rel=\"noopener\"><em>entry points</em></a> 。如果你的应用有三种页面：主页、文章页、用户账户页，那就分厂三个 entries：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack.config.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    home: <span class=\"string\">'./src/Home/index.js'</span>,</span><br><span class=\"line\">    article: <span class=\"string\">'./src/Article/index.js'</span>,</span><br><span class=\"line\">    profile: <span class=\"string\">'./src/Profile/index.js'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>对于每一个 entry 文件，webpack 将构建出独立的依赖树，并且声称一个 bundle，它将通过 entry 来只包括用到的 modules：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ webpack</span><br><span class=\"line\">Hash: 318d7b8490a7382bf23b</span><br><span class=\"line\">Version: webpack 3.8.1</span><br><span class=\"line\">Time: 4273ms</span><br><span class=\"line\">                            Asset     Size  Chunks             Chunk Names</span><br><span class=\"line\">      ./0.8ecaf182f5c85b7a8199.js  22.5 kB       0  [emitted]</span><br><span class=\"line\">   ./home.91b9ed27366fe7e33d6a.js    18 kB       1  [emitted]  home</span><br><span class=\"line\">./article.87a128755b16ac3294fd.js    32 kB       2  [emitted]  article</span><br><span class=\"line\">./profile.de945dc02685f6166781.js    24 kB       3  [emitted]  profile</span><br><span class=\"line\"> ./vendor.4f14b6326a80f4752a98.js    46 kB       4  [emitted]  vendor</span><br><span class=\"line\">./runtime.318d7b8490a7382bf23b.js  1.45 kB       5  [emitted]  runtime</span><br></pre></td></tr></table></figure>\n<p> 因此，如果仅仅是文章页使用<em>Lodash</em>，<em>home</em> 和 <em>profile</em> 的 bundle 将不会包含 lodash - 同时用户也不会在访问首页的时候下载到这个库。</p>\n<p>拆分依赖树也有缺点。如果两个 entry points 都用到了<em>loadash</em>，同时你没有在 <em>vendor</em> 移除掉依赖，两个 entry points 将包括两个重复的<em>lodash</em>。我们使用<a href=\"https://webpack.js.org/plugins/commons-chunk-plugin/\" target=\"_blank\" rel=\"noopener\"><code>CommonsChunkPlugin</code></a>解决这个问题 - 它会将通用的依赖转移到一个独立的文件中：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack.config.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class=\"line\">      <span class=\"comment\">// A name of the chunk that will include the common dependencies</span></span><br><span class=\"line\">      name: <span class=\"string\">'common'</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// The plugin will move a module into a common file</span></span><br><span class=\"line\">      <span class=\"comment\">// only if it’s included into `minChunks` chunks</span></span><br><span class=\"line\">      <span class=\"comment\">// (Note that the plugin analyzes all chunks, not only entries)</span></span><br><span class=\"line\">      minChunks: <span class=\"number\">2</span>,    <span class=\"comment\">// 2 is the default value</span></span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>随意使用<code>minChunks</code>的值来找到最优的选项。通常情况下，你想要它尽可能体积小，但它会增加 chunks 的数量。举个例子，3 个 chunk，<code>minChunks</code> 可能是 2 个，但是 30 个 chunk，它可能是 8 个 - 因为如果你把它设置成 2 ，过多的 modules 将会打包进一个通用文件中，文件更臃肿。</p>\n<h4 id=\"Further-reading-7\"><a href=\"#Further-reading-7\" class=\"headerlink\" title=\"Further reading\"></a>Further reading</h4><ul>\n<li>Webpack docs <a href=\"https://webpack.js.org/concepts/entry-points/\" target=\"_blank\" rel=\"noopener\">about the concept of entry points</a></li>\n<li>Webpack docs <a href=\"https://webpack.js.org/plugins/commons-chunk-plugin/\" target=\"_blank\" rel=\"noopener\">about the CommonsChunkPlugin</a></li>\n<li><a href=\"https://medium.com/webpack/webpack-bits-getting-the-most-out-of-the-commonschunkplugin-ab389e5f318\" target=\"_blank\" rel=\"noopener\">“Getting the most out of the CommonsChunkPlugin”</a></li>\n</ul>\n<h3 id=\"Make-module-ids-more-stable-让-module-ide-更稳定\"><a href=\"#Make-module-ids-more-stable-让-module-ide-更稳定\" class=\"headerlink\" title=\"Make module ids more stable 让 module ide 更稳定\"></a>Make module ids more stable 让 module ide 更稳定</h3><p>当编译代码时，webpack 会分配给每一个 module 一个 ID。之后，这些 ID 就会被<code>require()</code>引用到 bundle 内部。你可以在编译输出的右侧在 moudle 路径之前看到这些 ID：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ webpack</span><br><span class=\"line\">Hash: df3474e4f76528e3bbc9</span><br><span class=\"line\">Version: webpack 3.8.1</span><br><span class=\"line\">Time: 2150ms</span><br><span class=\"line\">                           Asset      Size  Chunks             Chunk Names</span><br><span class=\"line\">      ./0.8ecaf182f5c85b7a8199.js  22.5 kB       0  [emitted]</span><br><span class=\"line\">   ./main.4e50a16675574df6a9e9.js    60 kB       1  [emitted]  main</span><br><span class=\"line\"> ./vendor.26886caf15818fa82dfa.js    46 kB       2  [emitted]  vendor</span><br><span class=\"line\">./runtime.79f17c27b335abc7aaf4.js  1.45 kB       3  [emitted]  runtime</span><br></pre></td></tr></table></figure>\n<p>here</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[0] ./index.js 29 kB &#123;1&#125; [built]</span><br><span class=\"line\">[2] (webpack)/buildin/global.js 488 bytes &#123;2&#125; [built]</span><br><span class=\"line\">[3] (webpack)/buildin/module.js 495 bytes &#123;2&#125; [built]</span><br><span class=\"line\">[4] ./comments.js 58 kB &#123;0&#125; [built]</span><br><span class=\"line\">[5] ./ads.js 74 kB &#123;1&#125; [built]</span><br><span class=\"line\"> + 1 hidden module</span><br></pre></td></tr></table></figure>\n<p>默认情况下，这些 ID 是使用计数器计算出来的（比如第一个 module 是 ID 0，第二个 moudle 就是 ID 1，以此类推）。这样的问题就在于当你新增一个 module 事，它会出现在原来 module 列表中的中间，改变后面所有 module 的 ID：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ webpack</span><br><span class=\"line\">Hash: df3474e4f76528e3bbc9</span><br><span class=\"line\">Version: webpack 3.8.1</span><br><span class=\"line\">Time: 2150ms</span><br><span class=\"line\">                           Asset      Size  Chunks             Chunk Names</span><br><span class=\"line\">      ./0.5c82c0f337fcb22672b5.js    22 kB       0  [emitted]</span><br><span class=\"line\">   ./main.0c8b617dfc40c2827ae3.js    82 kB       1  [emitted]  main</span><br><span class=\"line\"> ./vendor.26886caf15818fa82dfa.js    46 kB       2  [emitted]  vendor</span><br><span class=\"line\">./runtime.79f17c27b335abc7aaf4.js  1.45 kB       3  [emitted]  runtime</span><br><span class=\"line\">   [0] ./index.js 29 kB &#123;1&#125; [built]</span><br><span class=\"line\">   [2] (webpack)/buildin/global.js 488 bytes &#123;2&#125; [built]</span><br><span class=\"line\">   [3] (webpack)/buildin/module.js 495 bytes &#123;2&#125; [built]</span><br></pre></td></tr></table></figure>\n<p>↓ 我们增加一个新 module</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[4] ./webPlayer.js 24 kB &#123;1&#125; [built]</span><br></pre></td></tr></table></figure>\n<p>↓ 现在看这里做了什么！<code>comments.js</code>现在的 ID 由 4 变成了 5</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[5] ./comments.js 58 kB &#123;0&#125; [built]</span><br></pre></td></tr></table></figure>\n<p>↓ <code>ads.js</code> 的 ID 由 5 变成 6</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[6] ./ads.js 74 kB &#123;1&#125; [built]</span><br><span class=\"line\">       + 1 hidden module</span><br></pre></td></tr></table></figure>\n<p>这将使包含或依赖于具有更改ID的模块的所有块无效 - 即使它们的实际代码没有更改。在我们的代码中，<em>0</em>这个 chunk 和 <em>main</em> chunk 都会失效 - 只有<em>main</em>才应该失效。</p>\n<p>使用<a href=\"https://webpack.js.org/plugins/hashed-module-ids-plugin/\" target=\"_blank\" rel=\"noopener\"><code>HashedModuleIdsPlugin</code></a>插件改变module ID 如何计算来解决这个问题。它利用 module 路径的 hash 来替换掉计数器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ webpack</span><br><span class=\"line\">Hash: df3474e4f76528e3bbc9</span><br><span class=\"line\">Version: webpack 3.8.1</span><br><span class=\"line\">Time: 2150ms</span><br><span class=\"line\">                           Asset      Size  Chunks             Chunk Names</span><br><span class=\"line\">      ./0.6168aaac8461862eab7a.js  22.5 kB       0  [emitted]</span><br><span class=\"line\">   ./main.a2e49a279552980e3b91.js    60 kB       1  [emitted]  main</span><br><span class=\"line\"> ./vendor.ff9f7ea865884e6a84c8.js    46 kB       2  [emitted]  vendor</span><br><span class=\"line\">./runtime.25f5d0204e4f77fa57a1.js  1.45 kB       3  [emitted]  runtime</span><br></pre></td></tr></table></figure>\n<p>↓ Here</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[3IRH] ./index.js 29 kB &#123;1&#125; [built]</span><br><span class=\"line\">[DuR2] (webpack)/buildin/global.js 488 bytes &#123;2&#125; [built]</span><br><span class=\"line\">[JkW7] (webpack)/buildin/module.js 495 bytes &#123;2&#125; [built]</span><br><span class=\"line\">[LbCc] ./webPlayer.js 24 kB &#123;1&#125; [built]</span><br><span class=\"line\">[lebJ] ./comments.js 58 kB &#123;0&#125; [built]</span><br><span class=\"line\">[02Tr] ./ads.js 74 kB &#123;1&#125; [built]</span><br><span class=\"line\">    + 1 hidden module</span><br></pre></td></tr></table></figure>\n<p>有了这个方法，只有你重命名护着删除这个 moudle 它的 ID 才会变化。新的 modules 不会因为 module ID 互相影响。</p>\n<p>启用这个插件，在配置中增加 <em>plugins</em>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack.config.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.HashedModuleIdsPlugin(),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Further-reading-8\"><a href=\"#Further-reading-8\" class=\"headerlink\" title=\"Further reading\"></a>Further reading</h4><ul>\n<li>Webpack docs <a href=\"https://webpack.js.org/plugins/hashed-module-ids-plugin/\" target=\"_blank\" rel=\"noopener\">about the HashedModuleIdsPlugin</a></li>\n</ul>\n<h3 id=\"Summing-up\"><a href=\"#Summing-up\" class=\"headerlink\" title=\"Summing up\"></a>Summing up</h3><ul>\n<li>Cache the bundle and differentiate between them by changing their names</li>\n<li>Split the bundle into app code, vendor code and runtime</li>\n<li>Inline the runtime to save an HTTP request</li>\n<li>Lazy-load non-critical code with <code>import</code></li>\n<li>Split code by routes/pages to avoid loading unnecessary stuff</li>\n</ul>\n<p>===</p>\n<h2 id=\"Monitor-and-analyze-the-app-监控并分析\"><a href=\"#Monitor-and-analyze-the-app-监控并分析\" class=\"headerlink\" title=\"Monitor and analyze the app 监控并分析\"></a>Monitor and analyze the app 监控并分析</h2><p>作者 <a href=\"https://developers.google.com/web/resources/contributors/iamakulov\" target=\"_blank\" rel=\"noopener\">Ivan Akulov</a></p>\n<p>即使当你配置好你的 webpack 让你的引用尽可能体积较小的时候，跟踪这个应用就非常重要，同时了解里面包含了什么。除此之外，你安装一个依赖，它将让你的 app 增加两倍大小 - 但并没有注意到这个问题！</p>\n<p>这一部分就来讲解一些能够帮助你理解你的 bundle 的工具。</p>\n<h3 id=\"Keep-track-of-the-bundle-size-跟踪打包的体积\"><a href=\"#Keep-track-of-the-bundle-size-跟踪打包的体积\" class=\"headerlink\" title=\"Keep track of the bundle size 跟踪打包的体积\"></a>Keep track of the bundle size 跟踪打包的体积</h3><p>在开发时可以使用<a href=\"https://github.com/FormidableLabs/webpack-dashboard/\" target=\"_blank\" rel=\"noopener\">webpack-dashboard</a>和命令行<a href=\"https://github.com/siddharthkp/bundlesize\" target=\"_blank\" rel=\"noopener\">bundlesize</a> 来监控 app 的体积。</p>\n<h4 id=\"webpack-dashboard\"><a href=\"#webpack-dashboard\" class=\"headerlink\" title=\"webpack-dashboard\"></a>webpack-dashboard</h4><p><a href=\"https://github.com/FormidableLabs/webpack-dashboard/\" target=\"_blank\" rel=\"noopener\">webpack-dashboard</a>可以通过依赖体积大小、进程和其他细节来改进 webpack 的输出。</p>\n<p><img src=\"http://img30.360buyimg.com/uba/jfs/t16294/169/2125639991/38263/ad862ba/5a8159c0N0da38a60.png\" alt=\"webpack-dashboard\"></p>\n<p>这个 dashborad 帮助我们跟踪大型依赖 - 如果你增加一个依赖，你就立刻能在 Modules section 始终看到它！</p>\n<p>启用这个功能，需要安装 <em>webpack-dashboard</em> 包：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install webpack-dashboard --save-dev</span><br></pre></td></tr></table></figure>\n<p> 同时在配置的 plugins 增加：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack.config.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> DashboardPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack-dashboard/plugin'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> DashboardPlugin(),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>或者如果正在使用基于 Express dev server 可以使用 <code>compiler.apply()</code>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compiler.apply(new DashboardPlugin());</span><br></pre></td></tr></table></figure>\n<p>多尝试 dashboard 找出改进的地方！比如，在 modules section 滚动找到那个库体积过大，把它替换成小的可替代的库。</p>\n<h4 id=\"bundlesize\"><a href=\"#bundlesize\" class=\"headerlink\" title=\"bundlesize\"></a>bundlesize</h4><p><a href=\"https://github.com/siddharthkp/bundlesize\" target=\"_blank\" rel=\"noopener\">bundlesize</a> 可以验证 webpack assets 不超过指定的大小。通过自动化 CI 就可以知晓 app 是否变的过于臃肿：</p>\n<p><img src=\"https://img30.360buyimg.com/uba/jfs/t15808/165/2111159728/110001/633e93ab/5a8159cdN1c575a1f.jpg\" alt=\"bundlesize\"></p>\n<p>配置如下：</p>\n<h5 id=\"Find-out-the-maximum-sizes-找出最大体积\"><a href=\"#Find-out-the-maximum-sizes-找出最大体积\" class=\"headerlink\" title=\"Find out the maximum sizes 找出最大体积\"></a><strong>Find out the maximum sizes</strong> 找出最大体积</h5><ol>\n<li>分析 app 尽可能减小体积，执行生产环境的 build。</li>\n<li>在<code>package.json</code>中增加<code>bundlesize</code>部分：</li>\n</ol>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// package.json</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"bundlesize\"</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"path\"</span>: <span class=\"string\">\"./dist/*\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>使用<code>npx</code>执行<code>bundlesize</code>：</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx bundlesize</span><br></pre></td></tr></table></figure>\n<p>它就会将每一个文件的 gzip 压缩后的体积打印出来：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PASS  ./dist/icon256.6168aaac8461862eab7a.png:  10.89KB PASS./dist/icon512.c3e073a4100bd0c28a86.png:  13.1KB PASS./dist/main.0c8b617dfc40c2827ae3.js:  16.28KB PASS./dist/vendor.ff9f7ea865884e6a84c8.js:  31.49KB</span><br></pre></td></tr></table></figure>\n<ol>\n<li>每一个体积增加10-20%，你将得到最大体积。这个10-20％的幅度可以让你像往常一样开发应用程序，同时警告你，当它的大小增长太多。</li>\n</ol>\n<h5 id=\"Enable-bundlesize-启用-bundlesize\"><a href=\"#Enable-bundlesize-启用-bundlesize\" class=\"headerlink\" title=\"Enable bundlesize 启用 bundlesize\"></a><strong>Enable <code>bundlesize</code></strong> 启用 bundlesize</h5><p>5.安装<em>bundlesize</em>开发依赖</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install bundlesize --save-dev</span><br></pre></td></tr></table></figure>\n<p>6.在<code>package.json</code>中的<code>bundlesize</code>部分，声明具体的最大值。对于某一些文件（比如图片），你可以单独根据文件类型来设置最大体积大小，而不需要根据每一个文件：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// package.json</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"bundlesize\"</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"path\"</span>: <span class=\"string\">\"./dist/*.png\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"maxSize\"</span>: <span class=\"string\">\"16 kB\"</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"path\"</span>: <span class=\"string\">\"./dist/main.*.js\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"maxSize\"</span>: <span class=\"string\">\"20 kB\"</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"path\"</span>: <span class=\"string\">\"./dist/vendor.*.js\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"maxSize\"</span>: <span class=\"string\">\"35 kB\"</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>7.增加一个 npm 脚本来执行检查：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// package.json</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"check-size\"</span>: <span class=\"string\">\"bundlesize\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>8.配置自动化 CI 来在每一次 push 时执行<code>npm run check-size</code>做检查。（如果你在 Github 上开发项目，直接可以使用<a href=\"https://github.com/siddharthkp/bundlesize#2-build-status\" target=\"_blank\" rel=\"noopener\">integrate <code>bundlesize</code> with GitHub</a>。）</p>\n<p>这就全部了！现在如果你运行<code>npm run check-size</code>或者 push 代码，你就会看到输出的文件是否足够小：</p>\n<p><img src=\"https://img14.360buyimg.com/uba/jfs/t14890/146/2205111432/17457/fa7f748a/5a8159dcN17378d16.png\" alt=\"bundlesize-output-success\"></p>\n<p>或者下面失败的情况</p>\n<p><img src=\"https://img11.360buyimg.com/uba/jfs/t16969/198/453213154/26368/834a1c7f/5a8159e8Nc1f5ffe8.png\" alt=\"bundlesize-output-failure\"></p>\n<h4 id=\"Further-reading-9\"><a href=\"#Further-reading-9\" class=\"headerlink\" title=\"Further reading\"></a>Further reading</h4><ul>\n<li>Alex Russell <a href=\"https://infrequently.org/2017/10/can-you-afford-it-real-world-web-performance-budgets/\" target=\"_blank\" rel=\"noopener\">about the real-world loading time we should target</a></li>\n</ul>\n<h3 id=\"Analyze-why-the-bundle-is-so-large-分析-bundle-为什么这么大\"><a href=\"#Analyze-why-the-bundle-is-so-large-分析-bundle-为什么这么大\" class=\"headerlink\" title=\"Analyze why the bundle is so large 分析 bundle 为什么这么大\"></a>Analyze why the bundle is so large 分析 bundle 为什么这么大</h3><p>你想要深挖 bundle 内，看看里面具体哪些 module 占用多大空间。<a href=\"https://github.com/webpack-contrib/webpack-bundle-analyzer\" target=\"_blank\" rel=\"noopener\">webpack-bundle-analyzer</a></p>\n<p>(Screen recording from <a href=\"https://github.com/webpack-contrib/webpack-bundle-analyzer\" target=\"_blank\" rel=\"noopener\">github.com/webpack-contrib/webpack -bundle-analyzer</a>)</p>\n<p>webpack-bundle-analyzer 可以扫描 bundle 同时构建一个查看内部的可视化窗口。使用这个可视化工具找到过大或者不必要的依赖。</p>\n<p>使用这个分析器，需要安装<code>webpack-bundle-analyzer</code>包：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install webpack-bundle-analyzer --save-dev</span><br></pre></td></tr></table></figure>\n<p>在 config 中增加插件：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack.config.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> BundleAnalyzerPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack-bundle-analyzer'</span>).BundleAnalyzerPlugin;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> BundleAnalyzerPlugin(),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>运行生产环境的 build。这个插件就会在浏览器中打开一个显示状态的页面。</p>\n<p>默认情况下，这个页面会显示语法分析后的文件体积（在 bundle 出现的文件）。您可能想比较 gzip 的大小，因为这更接近实际用户的体验；使用左边的边栏来切换尺寸。</p>\n<blockquote>\n<p>Note: 如果你使用 <a href=\"https://webpack.js.org/plugins/module-concatenation-plugin/\" target=\"_blank\" rel=\"noopener\">ModuleConcatenationPlugin</a>，它可能在webpack-bundle-analyzer输出时合并一部分 module，使得报告小一些细节。如果你使用这个插件，在执行分析的时候需要禁用掉。</p>\n</blockquote>\n<p>下面是报告中需要看什么：</p>\n<ul>\n<li><strong>大型依赖</strong> 为什么体积这么大？是否有更小的替代包（比如 Preact 替代 React）？用了全部代码（比如 Moment.js 包含大量的本地变量 <a href=\"https://github.com/GoogleChromeLabs/webpack-libs-optimizations#moment\" target=\"_blank\" rel=\"noopener\">that are often not used and could be dropped</a>）？</li>\n<li><strong>重复依赖</strong> 是否在不同文件中看到相同的库？（使用<em>CommonsChunkPlugin</em>将他们移到一个通用文件内）亦或是在同一个库中 bundle 拥有多个版本？</li>\n<li><strong>相似依赖</strong> 是否存在有相似功能的相似库存在？（比如<em>moment</em>和<em>date-fns</em> 或者 <em>lodash</em> 和 <em>lodash-es</em>）尽力汇总成一个。</li>\n</ul>\n<p>同样的，也可以看看 Sean Larkin 的文章 <a href=\"https://medium.com/webpack/webpack-bits-getting-the-most-out-of-the-commonschunkplugin-ab389e5f318\" target=\"_blank\" rel=\"noopener\">great analysis of webpack bundles</a>。</p>\n<h3 id=\"Summing-up-1\"><a href=\"#Summing-up-1\" class=\"headerlink\" title=\"Summing up\"></a>Summing up</h3><ul>\n<li>Use <code>webpack-dashboard</code> and <code>bundlesize</code> to stay tuned of how large your app is</li>\n<li>Dig into what builds up the size with <code>webpack-bundle-analyzer</code></li>\n</ul>\n<p>===</p>\n<h2 id=\"Conclusion结尾\"><a href=\"#Conclusion结尾\" class=\"headerlink\" title=\"Conclusion结尾\"></a>Conclusion结尾</h2><p>总结一下：</p>\n<ul>\n<li><strong>剔除不必要的体积</strong> 把所有的都压缩，剔除无用代码，增加依赖是保持谨慎小心。</li>\n<li><strong>通过路由拆分代码</strong> 只在真正需要的时候才加载，其他的部分做来加载。</li>\n<li><strong>缓存代码</strong> 应用程序的某些部分更新频率低于其他部分，将这些部分拆分成文件，以便在必要时仅重新下载。</li>\n<li><strong>跟踪体积大小</strong> 使用  <a href=\"https://github.com/FormidableLabs/webpack-dashboard/\" target=\"_blank\" rel=\"noopener\">webpack-dashboard</a> 和 <a href=\"https://github.com/webpack-contrib/webpack-bundle-analyzer\" target=\"_blank\" rel=\"noopener\">webpack-bundle-analyzer</a> 监控你的 app。每隔几个月重新检查一下你的应用的性能。</li>\n</ul>\n<p>Webpack 不仅仅是一个帮助你创建 app 更快的工具。它还帮助是你的 app 成为 <a href=\"https://developers.google.com/web/progressive-web-apps/\" target=\"_blank\" rel=\"noopener\">a Progressive Web App</a> ，你的引用拥有更好的体检自动化的填充工具就像<a href=\"https://developers.google.com/web/tools/lighthouse/\" target=\"_blank\" rel=\"noopener\">Lighthouse</a>根据环境给出建议。</p>\n<p>不要忘记阅读 <a href=\"https://webpack.js.org/guides/\" target=\"_blank\" rel=\"noopener\">webpack docs</a> - 里面提供了大量的优化的信息。</p>\n<p>记得练习一下 <a href=\"https://github.com/GoogleChromeLabs/webpack-training-project\" target=\"_blank\" rel=\"noopener\">with the training app</a>！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>【译】Google出品 - 利用 webpack 做 web 性能优化</p>\n<p>===</p>\n<p>2018-02-11 Beanlee</p>\n<p>原文 <a href=\"https://developers.google.com/web/fundamentals/performance/webpack/\" target=\"_blank\" rel=\"noopener\">https://developers.google.com/web/fundamentals/performance/webpack/</a></p>\n<p>作者 Addy Osmani</p>\n<h2 id=\"Instroduction-介绍\"><a href=\"#Instroduction-介绍\" class=\"headerlink\" title=\"Instroduction 介绍\"></a>Instroduction 介绍</h2><p>现代 Web 应用经常用到<code>bunding tool</code>用于创建一个生产环境的打包文件（例如脚本、样式等），这个打包文件是已经优化完，并且最小化完成的，并且能够被用户用更少的时间下载到。在这篇文章中，我们将会利用<code>webpack</code>来贯穿如何优化网站资源。这样可以帮助用户对于你的网站得到更快地加载和体验。</p>\n<p><img src=\"https://img20.360buyimg.com/uba/jfs/t15217/149/2229580840/12989/54324b99/5a815957N5bb3e0c6.png\" alt=\"webpack-logo\"></p>\n<p>webpack 目前是最流行的打包工具之一，深入地利用他的特点去优化代码，拆分脚本成重要和非重要部分还有剔除无用的代码能够保证你的引用有最小的带宽和进程消耗。</p>\n<p><img src=\"https://img14.360buyimg.com/uba/jfs/t17569/325/476871633/18187/a1e34f41/5a81597fNd77bb5b8.png\" alt=\"code-splitting\"></p>\n<blockquote>\n<p>Note: 我们创建了一个练习用的引用来演示优化的描述。尽力挤出最多的时间来练习这些 tips <a href=\"https://github.com/GoogleChromeLabs/webpack-training-project\" target=\"_blank\" rel=\"noopener\"><code>webpack-training-project</code></a></p>\n</blockquote>\n<p>让我们从现代 web 应用中最耗费资源之一的 <code>Javascript</code>开始。</p>\n<ul>\n<li>减小前端体积</li>\n<li>利用长期缓存</li>\n<li>监控并分析应用</li>\n<li>结尾</li>\n</ul>\n<p>===</p>\n<h2 id=\"Decrease-Front-end-Size-减少前端体积\"><a href=\"#Decrease-Front-end-Size-减少前端体积\" class=\"headerlink\" title=\"Decrease Front-end Size 减少前端体积\"></a>Decrease Front-end Size 减少前端体积</h2><p>作者 <a href=\"https://developers.google.com/web/resources/contributors/iamakulov\" target=\"_blank\" rel=\"noopener\">Ivan Akulov</a></p>\n<p>当你正在优化一个应用时最初第一件事就是尽可能地让它体积减小。下面就是利用 webpack 如何做。</p>\n<h3 id=\"Enable-minification-启用最小化\"><a href=\"#Enable-minification-启用最小化\" class=\"headerlink\" title=\"Enable minification 启用最小化\"></a>Enable minification 启用最小化</h3><p>最小化是通过去除多余空格、缩短变量名等方式压缩代码。例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Original code</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">map</span>(<span class=\"params\">array, iteratee</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> index = <span class=\"number\">-1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> length = array == <span class=\"literal\">null</span> ? <span class=\"number\">0</span> : array.length;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(length);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (++index &lt; length) &#123;</span><br><span class=\"line\">    result[index] = iteratee(array[index], index, array);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>to</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Minified code</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">map</span>(<span class=\"params\">n,r</span>)</span>&#123;<span class=\"keyword\">let</span> t=<span class=\"number\">-1</span>;<span class=\"keyword\">for</span>(<span class=\"keyword\">const</span> a=<span class=\"literal\">null</span>==n?<span class=\"number\">0</span>:n.length,l=<span class=\"built_in\">Array</span>(a);++t&lt;a;)l[t]=r(n[t],t,n);<span class=\"keyword\">return</span> l&#125;</span><br></pre></td></tr></table></figure>\n<p>Webpack 支持两种方式最小化代码：UglifyJS 插件和<em>loader-specific options</em>。他们可以同时使用。</p>\n<p><a href=\"https://github.com/webpack-contrib/uglifyjs-webpack-plugin\" target=\"_blank\" rel=\"noopener\">The UglifyJS plugin</a>在 bundle 层级中起作用，在编译之后压缩 bundle。下面来展示如何工作：</p>\n<ol>\n<li>你的代码：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// comments.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./comments.css'</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span>(<span class=\"params\">data, target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Rendered!'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>Webpack 打包大致成如下：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// bundle.js (part of)</span></span><br><span class=\"line\"><span class=\"meta\">\"use strict\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(__webpack_exports__, <span class=\"string\">\"__esModule\"</span>, &#123; <span class=\"attr\">value</span>: <span class=\"literal\">true</span> &#125;);</span><br><span class=\"line\"><span class=\"comment\">/* harmony export (immutable) */</span> __webpack_exports__[<span class=\"string\">\"render\"</span>] = render;</span><br><span class=\"line\"><span class=\"comment\">/* harmony import */</span> <span class=\"keyword\">var</span> __WEBPACK_IMPORTED_MODULE_0__comments_css__ = __webpack_require__(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"comment\">/* harmony import */</span> <span class=\"keyword\">var</span> __WEBPACK_IMPORTED_MODULE_0__comments_css_js___default =</span><br><span class=\"line\">__webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__comments_css__);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span>(<span class=\"params\">data, target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Rendered!'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>使用 UglifyJS 插件大致编译成如下：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// minified bundle.js (part of)</span></span><br><span class=\"line\"><span class=\"meta\">\"use strict\"</span>;<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">t</span>(<span class=\"params\">e,n</span>)</span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">\"Rendered!\"</span>)&#125;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(n,<span class=\"string\">\"__esModule\"</span>,&#123;<span class=\"attr\">value</span>:!<span class=\"number\">0</span>&#125;),n.render=t;<span class=\"keyword\">var</span> o=r(<span class=\"number\">1</span>);r.n(o)</span><br></pre></td></tr></table></figure>\n<p>插件集成在 webpack 中，把它的配置在<code>plugins</code>中就可以启用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack.config.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.optimize.UglifyJsPlugin(),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>第二种方式<em>loader-specific options</em> 利用 loader options，可以压缩 Uglify 插件无法最小化的部分。举例，当你利用<code>css-loader</code>引入一个 CSS 文件时，文件会编译成一个字符串：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* comments.css */</span></span><br><span class=\"line\"><span class=\"selector-class\">.comment</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: black;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>to</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// minified bundle.js (part of)</span></span><br><span class=\"line\">exports=<span class=\"built_in\">module</span>.exports=__webpack_require__(<span class=\"number\">1</span>)(),</span><br><span class=\"line\">exports.push([<span class=\"built_in\">module</span>.i,<span class=\"string\">\".comment &#123;\\r\\n  color: black;\\r\\n&#125;\"</span>,<span class=\"string\">\"\"</span>]);</span><br></pre></td></tr></table></figure>\n<p>UglifyJS 由于这是一个字符串不能压缩这段代码。要最小化这个 css 文件内容，我们需要配置 <em>loader</em></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack.config.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.css$/</span>,</span><br><span class=\"line\">        use: [</span><br><span class=\"line\">          <span class=\"string\">'style-loader'</span>,</span><br><span class=\"line\">          &#123; <span class=\"attr\">loader</span>: <span class=\"string\">'css-loader'</span>, <span class=\"attr\">options</span>: &#123; <span class=\"attr\">minimize</span>: <span class=\"literal\">true</span> &#125; &#125;,</span><br><span class=\"line\">        ],</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    ],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>{ minimize: true }</strong></p>\n<blockquote>\n<p>Note: UglifyJS 插件不能编译 ES2015+(ES2016)，这意味着如果你的 diamante 中使用类、箭头函数和一些新特性语法，不能编译成 ES5，插件会抛异常。<br>如果需要编译新语法，要使用 <a href=\"https://github.com/webpack-contrib/uglifyjs-webpack-plugin\" target=\"_blank\" rel=\"noopener\">uglifyjs-webpack-plugin</a> 包。也是集成在 webpack 中相同的插件，但是更新一些，能够有能力编译 ES2015+。</p>\n</blockquote>\n<h4 id=\"Further-reading\"><a href=\"#Further-reading\" class=\"headerlink\" title=\"Further reading\"></a>Further reading</h4><ul>\n<li><a href=\"https://github.com/webpack-contrib/uglifyjs-webpack-plugin\" target=\"_blank\" rel=\"noopener\">The UglifyJsPlugin docs</a></li>\n<li>Other popular minifiers: <a href=\"https://github.com/webpack-contrib/babel-minify-webpack-plugin\" target=\"_blank\" rel=\"noopener\">Babel Minify</a>, <a href=\"https://github.com/roman01la/webpack-closure-compiler\" target=\"_blank\" rel=\"noopener\">Google Closure Compiler</a></li>\n</ul>\n<h3 id=\"Specify-NODE-ENV-production-明确生产环境信息\"><a href=\"#Specify-NODE-ENV-production-明确生产环境信息\" class=\"headerlink\" title=\"Specify NODE_ENV=production 明确生产环境信息\"></a>Specify <code>NODE_ENV=production</code> 明确生产环境信息</h3><p>减小前端体积的另外一个方法就是在代码中将<code>NODE_ENV</code><a href=\"https://superuser.com/questions/284342/what-are-path-and-other-environment-variables-and-how-can-i-set-or-use-them\" target=\"_blank\" rel=\"noopener\">环境变量</a>设置成<code>production</code>。</p>\n<p>Libraries 会读取<code>NODE_ENV</code>变量判断他们应该在那种模式下工作 - 开发模式 or 生成模式。很多库会基于这个变量有不同的表现。举个例子，当<code>NODE_ENV</code>没有设置成<code>production</code>，Vue.js 会做额外的检查并且输出一些警告：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// vue/dist/vue.runtime.esm.js</span></span><br><span class=\"line\"><span class=\"comment\">// …</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span>) &#123;</span><br><span class=\"line\">  warn(<span class=\"string\">'props must be strings when using array syntax.'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// …</span></span><br></pre></td></tr></table></figure>\n<p>React 也是类似 - 开发模式下 build 带有一些警告：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// react/index.js</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (process.env.NODE_ENV === <span class=\"string\">'production'</span>) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">module</span>.exports = <span class=\"built_in\">require</span>(<span class=\"string\">'./cjs/react.production.min.js'</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">module</span>.exports = <span class=\"built_in\">require</span>(<span class=\"string\">'./cjs/react.development.js'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// react/cjs/react.development.js</span></span><br><span class=\"line\"><span class=\"comment\">// …</span></span><br><span class=\"line\">warning$<span class=\"number\">3</span>(</span><br><span class=\"line\">  componentClass.getDefaultProps.isReactClassApproved,</span><br><span class=\"line\">  <span class=\"string\">'getDefaultProps is only used on classic React.createClass '</span> +</span><br><span class=\"line\">  <span class=\"string\">'definitions. Use a static property named `defaultProps` instead.'</span></span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"comment\">// …</span></span><br></pre></td></tr></table></figure>\n<p>这些检查和警告通常在生产环境下不必要的，但是他们仍然保留在代码中并且会增加库的体积。通过配置 webpack 的 <a href=\"https://webpack.js.org/plugins/define-plugin/\" target=\"_blank\" rel=\"noopener\"><code>DefinePlugin</code></a> 来删除他们：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// webpack.config.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.DefinePlugin(&#123;</span><br><span class=\"line\">      <span class=\"string\">'process.env.NODE_ENV'</span>: <span class=\"string\">'\"production\"'</span>,</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.optimize.UglifyJsPlugin(),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><code>DefinePlugin</code>用确定的变量替换所有存在的说明变量。利用下面配置：</p>\n<ol>\n<li><code>DefinePlugin</code>将用<code>&quot;production&quot;</code>替换到<code>process.env.NODE_ENV</code>：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// vue/dist/vue.runtime.esm.js</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> val === <span class=\"string\">'string'</span>) &#123;</span><br><span class=\"line\">  name = camelize(val);</span><br><span class=\"line\">  res[name] = &#123; <span class=\"attr\">type</span>: <span class=\"literal\">null</span> &#125;;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span>) &#123;</span><br><span class=\"line\">  warn(<span class=\"string\">'props must be strings when using array syntax.'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>to</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// vue/dist/vue.runtime.esm.js</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> val === <span class=\"string\">'string'</span>) &#123;</span><br><span class=\"line\">  name = camelize(val);</span><br><span class=\"line\">  res[name] = &#123; <span class=\"attr\">type</span>: <span class=\"literal\">null</span> &#125;;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">\"production\"</span> !== <span class=\"string\">'production'</span>) &#123;</span><br><span class=\"line\">  warn(<span class=\"string\">'props must be strings when using array syntax.'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Note: 如果你偏向有通过 CLI 配置变量，可以查看一下 <a href=\"https://webpack.js.org/plugins/environment-plugin/\" target=\"_blank\" rel=\"noopener\">EnvironmentPlugin</a>。它和<code>DefinePlugin</code>类似，但读环境并且自动替换<code>process.env</code>表达式。</p>\n</blockquote>\n<p>2.<code>UglifyJS</code>会移除掉所有<code>if</code>分支 - 因为<code>&quot;production&quot; !== &#39;production&#39;</code>永远返回 false ，插件理解代码内的判断分支将永远不会执行：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// vue/dist/vue.runtime.esm.js</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> val === <span class=\"string\">'string'</span>) &#123;</span><br><span class=\"line\">  name = camelize(val);</span><br><span class=\"line\">  res[name] = &#123; <span class=\"attr\">type</span>: <span class=\"literal\">null</span> &#125;;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">\"production\"</span> !== <span class=\"string\">'production'</span>) &#123;</span><br><span class=\"line\">  warn(<span class=\"string\">'props must be strings when using array syntax.'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>to</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// vue/dist/vue.runtime.esm.js (without minification)</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> val === <span class=\"string\">'string'</span>) &#123;</span><br><span class=\"line\">  name = camelize(val);</span><br><span class=\"line\">  res[name] = &#123; <span class=\"attr\">type</span>: <span class=\"literal\">null</span> &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Note: 不一定强制要求使用 <code>UglifyJSPlugin</code>。你可以使用其他不同的最小化工具，这些页支持移除无用代码（例如，the <a href=\"https://github.com/webpack-contrib/babel-minify-webpack-plugin\" target=\"_blank\" rel=\"noopener\">Babel Minify plugin</a> or the <a href=\"https://github.com/roman01la/webpack-closure-compiler\" target=\"_blank\" rel=\"noopener\">Google Closure Compiler plugin</a>）</p>\n</blockquote>\n<h4 id=\"Further-Reading\"><a href=\"#Further-Reading\" class=\"headerlink\" title=\"Further Reading\"></a>Further Reading</h4><ul>\n<li><a href=\"https://superuser.com/questions/284342/what-are-path-and-other-environment-variables-and-how-can-i-set-or-use-them\" target=\"_blank\" rel=\"noopener\">What “environment variables” are</a></li>\n<li>Webpack docs about: <a href=\"https://webpack.js.org/plugins/define-plugin/\" target=\"_blank\" rel=\"noopener\"><code>DefinePlugin</code></a>, <a href=\"https://webpack.js.org/plugins/environment-plugin/\" target=\"_blank\" rel=\"noopener\"><code>EnvironmentPlugin</code></a></li>\n</ul>\n<h3 id=\"Use-ES-Modules-使用-ES-模块\"><a href=\"#Use-ES-Modules-使用-ES-模块\" class=\"headerlink\" title=\"Use ES Modules 使用 ES 模块\"></a>Use ES Modules 使用 ES 模块</h3><p>下面这个方式利用 <a href=\"https://ponyfoo.com/articles/es6-modules-in-depth\" target=\"_blank\" rel=\"noopener\">ES modules</a> 减小前端体积。</p>\n<p>当你使用 ES module，webpack 有能力去做 tree-shaking。Tree-shaking 贯穿整个依赖树，检查那些依赖被使用，移除无用依赖。因此，如果你使用 ES module 语法，webpack 可以排除掉无用代码：</p>\n<ol>\n<li>一个有多个 export 的文件，但是 app 只需要其中一个：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// comments.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> render = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123; <span class=\"keyword\">return</span> <span class=\"string\">'Rendered!'</span>; &#125;;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> commentRestEndpoint = <span class=\"string\">'/rest/comments'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// index.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; render &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./comments.js'</span>;</span><br><span class=\"line\">render();</span><br></pre></td></tr></table></figure>\n<ol>\n<li>webpack 理解 <code>commentRestEndPoint</code>没有使用，同时不能在一个 bundle 中生成单独的 export：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// bundle.js (part that corresponds to comments.js)</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">module, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">  \"use strict\"</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> render = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123; <span class=\"keyword\">return</span> <span class=\"string\">'Rendered!'</span>; &#125;;</span><br><span class=\"line\">  <span class=\"comment\">/* harmony export (immutable) */</span> __webpack_exports__[<span class=\"string\">\"a\"</span>] = render;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> commentRestEndpoint = <span class=\"string\">'/rest/comments'</span>;</span><br><span class=\"line\">  <span class=\"comment\">/* unused harmony export commentRestEndpoint */</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<ol>\n<li><code>UglifyJSPlugin</code>移除无用变量：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// bundle.js (part that corresponds to comments.js)</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">n,e</span>)</span>&#123;<span class=\"string\">\"use strict\"</span>;<span class=\"keyword\">var</span> r=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"keyword\">return</span><span class=\"string\">\"Rendered!\"</span>&#125;;e.b=r&#125;)</span><br></pre></td></tr></table></figure>\n<p>如果他们都是有 ES module 编写，就是与一些库并存时也是生效的。</p>\n<blockquote>\n<p>Note: 在 webpack 中，tree-shaking 没有 minifier 是无法生效的。 webpack 仅仅移除了没有被用到的 export 变量；<code>UglifyJSPlugin</code>才会移除无用代码。所以如果你编译打包时没有使用 minifier，打包后体积并不会更小。你也可以不一定使用这个插件。其他最小化的插件也支持移除 dead code（例如：<a href=\"https://github.com/webpack-contrib/babel-minify-webpack-plugin\" target=\"_blank\" rel=\"noopener\">Babel Minify plugin</a> or <a href=\"https://github.com/roman01la/webpack-closure-compiler\" target=\"_blank\" rel=\"noopener\">Google Closure Compiler plugin</a>）</p>\n<p>Warning: 不要将 ES module 编译到 CommonJS 中。 如果你使用 Babel <code>babel-preset-env</code> or <code>babel-preset-es2015</code>，检查一下当前的配置。默认情况下， ES <code>import</code> and <code>export</code> to CommonJS <code>require</code> and <code>module.exports</code>。通过设置 option 来禁止掉<a href=\"https://github.com/babel/babel/tree/master/experimental/babel-preset-env\" target=\"_blank\" rel=\"noopener\">Pass the <code>{ modules: false }</code> option</a>。</p>\n</blockquote>\n<h4 id=\"Futher-reading\"><a href=\"#Futher-reading\" class=\"headerlink\" title=\"Futher reading\"></a>Futher reading</h4><ul>\n<li><a href=\"https://ponyfoo.com/articles/es6-modules-in-depth\" target=\"_blank\" rel=\"noopener\">“ES6 Modules in depth”</a></li>\n<li>Webpack docs <a href=\"https://webpack.js.org/guides/tree-shaking/\" target=\"_blank\" rel=\"noopener\">about tree shaking</a></li>\n</ul>\n<h3 id=\"Optimize-images-优化图片\"><a href=\"#Optimize-images-优化图片\" class=\"headerlink\" title=\"Optimize images 优化图片\"></a>Optimize images 优化图片</h3><p>图片基本会占局页面一半以上体积。虽然它们不像 JavaScript 那么重要（比如它们不会阻止页面渲染），但图片仍然会占用掉一大部分带宽。利用<code>url-loader</code>，<code>svg-url-loader</code>和<code>image-webpack-loader</code>来在 webpack 中进行优化。</p>\n<p><code>url-loader</code> 允许将小静态文件打包进 app。没有配置，他需要通过 file，将它放在编译后的打包 bundle 内并返回一个这个文件的 url。然而，如果我们注明<code>limit</code>选项，它将会 encode 成更小的文件 base64 文件 url。这是可以将图片放在Javascript 代码中，同时节省 HTTP 请求：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack.config.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.(jpe?g|png|gif)$/</span>,</span><br><span class=\"line\">        loader: <span class=\"string\">'url-loader'</span>,</span><br><span class=\"line\">        options: &#123;</span><br><span class=\"line\">          <span class=\"comment\">// Inline files smaller than 10 kB (10240 bytes)</span></span><br><span class=\"line\">          limit: <span class=\"number\">10</span> * <span class=\"number\">1024</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    ],</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// index.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> imageUrl <span class=\"keyword\">from</span> <span class=\"string\">'./image.png'</span>;</span><br><span class=\"line\"><span class=\"comment\">// → If image.png is smaller than 10 kB, `imageUrl` will include</span></span><br><span class=\"line\"><span class=\"comment\">// the encoded image: 'data:image/png;base64,iVBORw0KGg…'</span></span><br><span class=\"line\"><span class=\"comment\">// → If image.png is larger than 10 kB, the loader will create a new file,</span></span><br><span class=\"line\"><span class=\"comment\">// and `imageUrl` will include its url: `/2fcd56a1920be.png`</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Note: 内联图片减少了独立请求的数量，这是很好的方式（<a href=\"https://blog.octo.com/en/http2-arrives-but-sprite-sets-aint-no-dead/\" target=\"_blank\" rel=\"noopener\">even with HTTP/2</a>），但是会增加 bundle下载和转换的时间和内存的消耗。一定要确保不要嵌入超大图片或者较多的图片 - 否则增加的 bundle 的时间将会掩盖做成内联图片的收益。</p>\n</blockquote>\n<p><code>svg-url-loader</code>与<code>url-loader</code>类似 - 都是将使用 <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/percent-encoding\" target=\"_blank\" rel=\"noopener\">URL encoding</a>  encode 文件。这对对于 SVG 图片很奏效 - 因为 SVG 文件是文本，encoding 在体积上更有效率：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack.config.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.svg$/</span>,</span><br><span class=\"line\">        loader: <span class=\"string\">'svg-url-loader'</span>,</span><br><span class=\"line\">        options: &#123;</span><br><span class=\"line\">          <span class=\"comment\">// Inline files smaller than 10 kB (10240 bytes)</span></span><br><span class=\"line\">          limit: <span class=\"number\">10</span> * <span class=\"number\">1024</span>,</span><br><span class=\"line\">          <span class=\"comment\">// Remove the quotes from the url</span></span><br><span class=\"line\">          <span class=\"comment\">// (they’re unnecessary in most cases)</span></span><br><span class=\"line\">          noquotes: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    ],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Note: svg-url-loader 拥有改善 IE 浏览器支持的 options，但是在其他浏览器中更糟糕。如果你需要兼容 IE 浏览器，<a href=\"https://github.com/bhovhannes/svg-url-loader#iesafe\" target=\"_blank\" rel=\"noopener\">设置 iesafe: true 选项</a></p>\n</blockquote>\n<p><code>image-webpack-loader</code>压缩图片使之变小。它支持 JPG，PNG，GIF 和 SVG，因为我们将会使用它所有类型。</p>\n<p>这个 loader 不会将图片嵌入在应用内，因此它必须与<code>url-loader</code>和<code>svg-url-loader</code>配合使用。避免复制粘贴到相同的 rules 中（一个用于 JPG/PNG/GIF 图片，另一个用于 SVG 图片），我们来使用<code>enforce: pre</code>作为单独的一个 rule 涵盖这个 loader：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack.config.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.(jpe?g|png|gif|svg)$/</span>,</span><br><span class=\"line\">        loader: <span class=\"string\">'image-webpack-loader'</span>,</span><br><span class=\"line\">        <span class=\"comment\">// This will apply the loader before the other ones</span></span><br><span class=\"line\">        enforce: <span class=\"string\">'pre'</span>,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    ],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>默认 loader 的设置就已经可以了 - 但是如果你想要更深入的配置，查看 <a href=\"https://github.com/tcoopman/image-webpack-loader#options\" target=\"_blank\" rel=\"noopener\">the plugin options</a>。为了选择哪些 options 需要明确，可以查看 Addy Osmani 的 <a href=\"https://images.guide/\" target=\"_blank\" rel=\"noopener\">guide on image optimization</a></p>\n<h4 id=\"Further-reading-1\"><a href=\"#Further-reading-1\" class=\"headerlink\" title=\"Further reading\"></a>Further reading</h4><ul>\n<li><a href=\"https://stackoverflow.com/questions/201479/what-is-base-64-encoding-used-for\" target=\"_blank\" rel=\"noopener\">“What is base64 encoding used for?”</a></li>\n<li>Addy Osmani’s <a href=\"https://images.guide/\" target=\"_blank\" rel=\"noopener\">guide on image optimization</a></li>\n</ul>\n<h3 id=\"Optimize-dependencies-优化依赖\"><a href=\"#Optimize-dependencies-优化依赖\" class=\"headerlink\" title=\"Optimize dependencies 优化依赖\"></a>Optimize dependencies 优化依赖</h3><p>平均一半以上的 Javascript 体积大小来源于依赖包，并且这些可能都不是必要的。</p>\n<p>举一个例子来说，Lodash（v4.17.4）增加了最小化代码的 72KB 大小到 bundle 中。但是如果你仅仅用到它的20个方法，大于 65 KB 没有用处。</p>\n<p>另外一个例子就是 Moment.js。 V2.19.1版本最小化后有 223KB，体积巨大 - 截至2017年10月一个页面内的 Javascript 平均体积是 452KB。但是，本地文件的体积占 170KB。如果你没有用到 多语言版 Moment.js，这些文件都会没有目的地使 bundle 更臃肿。</p>\n<p>所有这些依赖都可以被轻易优化。我们在 Github repo 手机了优化的建议，<a href=\"https://github.com/GoogleChromeLabs/webpack-libs-optimizations\" target=\"_blank\" rel=\"noopener\">check it out</a>！</p>\n<h3 id=\"Enable-module-concatenation-for-ES-modules-aka-scope-hoisting\"><a href=\"#Enable-module-concatenation-for-ES-modules-aka-scope-hoisting\" class=\"headerlink\" title=\"Enable module concatenation for ES modules (aka scope hoisting)\"></a>Enable module concatenation for ES modules (aka scope hoisting)</h3><p>当你构建一个 bundle 时，webpack 将每一个 module 封装进 function 中：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// index.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;render&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./comments.js'</span>;</span><br><span class=\"line\">render();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// comments.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span>(<span class=\"params\">data, target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Rendered!'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>to</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// bundle.js (part  of)</span></span><br><span class=\"line\"><span class=\"comment\">/* 0 */</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">module, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">  \"use strict\"</span>;</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.defineProperty(__webpack_exports__, <span class=\"string\">\"__esModule\"</span>, &#123; <span class=\"attr\">value</span>: <span class=\"literal\">true</span> &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> __WEBPACK_IMPORTED_MODULE_0__comments_js__ = __webpack_require__(<span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>(__WEBPACK_IMPORTED_MODULE_0__comments_js__[<span class=\"string\">\"a\"</span> <span class=\"comment\">/* render */</span>])();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;),</span><br><span class=\"line\"><span class=\"comment\">/* 1 */</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">module, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">  \"use strict\"</span>;</span><br><span class=\"line\">  __webpack_exports__[<span class=\"string\">\"a\"</span>] = render;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span>(<span class=\"params\">data, target</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Rendered!'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>在以前，这是使 CommonJS/AMD modules 互相分离所必须的。但是，这回增加体积同时性能堪忧。</p>\n<p>Webpack 2 介绍了 ES modules 的支持，不像 CommonJS 和 AMD modules 一样，而是能够不用将每一个 module 用 function 封装起来。同时 Webpack 3 利用<a href=\"https://webpack.js.org/plugins/module-concatenation-plugin/\" target=\"_blank\" rel=\"noopener\"><code>ModuleConcatenationPlugin</code></a>完成这样一个 bundle，下面是例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// index.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;render&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./comments.js'</span>;</span><br><span class=\"line\">render();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// comments.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span>(<span class=\"params\">data, target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Rendered!'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>to</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Unlike the previous snippet, this bundle has only one module</span></span><br><span class=\"line\"><span class=\"comment\">// which includes the code from both files</span></span><br><span class=\"line\"><span class=\"comment\">// 与前面的代码不同，这个 bundle 只有一个 module，同时包含两个文件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// bundle.js (part of; compiled with ModuleConcatenationPlugin)</span></span><br><span class=\"line\"><span class=\"comment\">/* 0 */</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">module, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">  \"use strict\"</span>;</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.defineProperty(__webpack_exports__, <span class=\"string\">\"__esModule\"</span>, &#123; <span class=\"attr\">value</span>: <span class=\"literal\">true</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// CONCATENATED MODULE: ./comments.js</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span>(<span class=\"params\">data, target</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Rendered!'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// CONCATENATED MODULE: ./index.js</span></span><br><span class=\"line\">  render();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>看到区别了吗？在这个 bundle 中， module 0 需要 module 1 的 render 方法。使用 <code>ModuleConcatenationPlugin</code>，<code>require</code>被直接简单的替换成 require 函数，同时 module 1 被删除删除掉了。这个 bundle 拥有更少的 modules，就有更少的 modules 损耗！</p>\n<p>启用这个功能，可以在插件列表中增加<code>ModuleConcatenationPlugin</code>：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack.config.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.optimize.ModuleConcatenationPlugin(),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>Note：想要知道为什么这个功能不是默认启用？Concatenating modules 很棒， <a href=\"https://twitter.com/TheLarkInn/status/925800563144454144\" target=\"_blank\" rel=\"noopener\">但是他会增加编译的时间同时破坏 module 的热更新</a>。这就是为什么只在生产环境中启用的原因了。</p>\n</blockquote>\n<h4 id=\"Further-reading-2\"><a href=\"#Further-reading-2\" class=\"headerlink\" title=\"Further reading\"></a>Further reading</h4><ul>\n<li>Webpack docs <a href=\"https://webpack.js.org/plugins/module-concatenation-plugin/\" target=\"_blank\" rel=\"noopener\">for the ModuleConcatenationPlugin</a></li>\n<li><a href=\"https://medium.com/webpack/brief-introduction-to-scope-hoisting-in-webpack-8435084c171f\" target=\"_blank\" rel=\"noopener\">“Brief introduction to scope hoisting”</a></li>\n<li>Detailed description of <a href=\"https://medium.com/webpack/webpack-freelancing-log-book-week-5-7-4764be3266f5\" target=\"_blank\" rel=\"noopener\">what this plugin does</a></li>\n</ul>\n<h3 id=\"Use-externals-if-you-have-both-webpack-and-non-webpack-code-如果代码中包含-webpack-和非-webpack-的代码要使用-externals\"><a href=\"#Use-externals-if-you-have-both-webpack-and-non-webpack-code-如果代码中包含-webpack-和非-webpack-的代码要使用-externals\" class=\"headerlink\" title=\"Use externals if you have both webpack and non-webpack code 如果代码中包含 webpack 和非 webpack 的代码要使用 externals\"></a>Use <code>externals</code> if you have both webpack and non-webpack code 如果代码中包含 webpack 和非 webpack 的代码要使用 externals</h3><p>你可能拥有一个体积庞大的工程，其中一部分代码可以使用 webpack 编译，而有一些代码又不能。比如一个视频网站，播放器的 widget 可能通过 webpack 编译，但是其周围页面区域可能不是：</p>\n<p><img src=\"https://img30.360buyimg.com/uba/jfs/t15334/148/2273118093/210074/8260a296/5a81599dN148751d5.png\" alt=\"video-hosting\"></p>\n<p>如果两部分代码有相同的依赖，你可以共享这些依赖以便减少重复下载耗时。<a href=\"https://webpack.js.org/configuration/externals/\" target=\"_blank\" rel=\"noopener\">the webpack’s <code>externals</code> option</a>就干了这件事 - 它用变量或者外部引用来替代 modules。</p>\n<h4 id=\"如果依赖是挂载到-window\"><a href=\"#如果依赖是挂载到-window\" class=\"headerlink\" title=\"如果依赖是挂载到 window\"></a>如果依赖是挂载到 window</h4><p>如果你的非 webpack 代码依靠这些依赖，这些依赖是挂载 window 上的变量，可以将依赖名称 alias 成变量名：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack.config.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  externals: &#123;</span><br><span class=\"line\">    <span class=\"string\">'react'</span>: <span class=\"string\">'React'</span>,</span><br><span class=\"line\">    <span class=\"string\">'react-dom'</span>: <span class=\"string\">'ReactDOM'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>利用这个配置，webpack 将不会打包 <code>react</code> 和 <code>react-dom</code>包。取而代之，他们会被替换成下面这个样子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// bundle.js (part of)</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">module, exports</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// A module that exports `window.React`. Without `externals`,</span></span><br><span class=\"line\">  <span class=\"comment\">// this module would include the whole React bundle</span></span><br><span class=\"line\">  <span class=\"built_in\">module</span>.exports = React;</span><br><span class=\"line\">&#125;),</span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">module, exports</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// A module that exports `window.ReactDOM`. Without `externals`,</span></span><br><span class=\"line\">  <span class=\"comment\">// this module would include the whole ReactDOM bundle</span></span><br><span class=\"line\">  <span class=\"built_in\">module</span>.exports = ReactDOM;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h4 id=\"如果依赖是当做-AMD-包被加载\"><a href=\"#如果依赖是当做-AMD-包被加载\" class=\"headerlink\" title=\"如果依赖是当做 AMD 包被加载\"></a>如果依赖是当做 AMD 包被加载</h4><p>如果你的非 webpack 代码没有将依赖暴露挂载到 window 上，这就更复杂了。但是如果非 webpack 代码使用 AMD 包的形式消费了这些依赖，你仍然可以避免重复的代码加载两次。</p>\n<p>具体如何做呢？将 webpack 代码编译成一个 AMD module 同时又名成一个库 URLs：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack.config.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  output: &#123; <span class=\"attr\">libraryTarget</span>: <span class=\"string\">'amd'</span> &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  externals: &#123;</span><br><span class=\"line\">    <span class=\"string\">'react'</span>: &#123; <span class=\"attr\">amd</span>: <span class=\"string\">'/libraries/react.min.js'</span> &#125;,</span><br><span class=\"line\">    <span class=\"string\">'react-dom'</span>: &#123; <span class=\"attr\">amd</span>: <span class=\"string\">'/libraries/react-dom.min.js'</span> &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>Webpack 将会把 bundle 包装进 <code>define()</code>同时让它依赖于这些URLs：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// bundle.js (beginning)</span></span><br><span class=\"line\">define([<span class=\"string\">\"/libraries/react.min.js\"</span>, <span class=\"string\">\"/libraries/react-dom.min.js\"</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; … &#125;);</span><br></pre></td></tr></table></figure>\n<p>如果非 webpack 代码使用相同的 URLs 加载依赖，这些文件将会加载一次 - 多余的请求会使用缓存。</p>\n<blockquote>\n<p>Note：webpack 只是替换那些<code>externals</code>对象中的准确匹配的 keys 的引用。这意味着如果你的代码这样写<code>import React from &#39;react/umd/react.production.min.js&#39;</code>，这个库是不会被 bundle 排除掉的。这是因为 - webpack 并不知道 <code>import &#39;react&#39;</code> 和 <code>import &#39;react/umd/react.production.min.js&#39;</code> 是同一个库，这样比较谨慎。</p>\n</blockquote>\n<h4 id=\"Further-reading-3\"><a href=\"#Further-reading-3\" class=\"headerlink\" title=\"Further reading\"></a>Further reading</h4><ul>\n<li>Webpack docs <a href=\"https://webpack.js.org/configuration/externals/\" target=\"_blank\" rel=\"noopener\">on <code>externals</code></a></li>\n</ul>\n<h3 id=\"Summing-up-总结\"><a href=\"#Summing-up-总结\" class=\"headerlink\" title=\"Summing up 总结\"></a>Summing up 总结</h3><ul>\n<li>Minimize your code with the <code>UglifyJsPlugin</code> and loader options</li>\n<li>Remove the development-only code with the <code>DefinePlugin</code></li>\n<li>Use ES modules to enable tree shaking</li>\n<li>Compress images</li>\n<li>Apply dependency-specific optimizations</li>\n<li>Enable module concatenation</li>\n<li>Use <code>externals</code> if this makes sense for you</li>\n</ul>\n<h2 id=\"Make-use-of-long-term-caching-利用好长时缓存\"><a href=\"#Make-use-of-long-term-caching-利用好长时缓存\" class=\"headerlink\" title=\"Make use of long-term caching 利用好长时缓存\"></a>Make use of long-term caching 利用好长时缓存</h2><p>作者 <a href=\"https://developers.google.com/web/resources/contributors/iamakulov\" target=\"_blank\" rel=\"noopener\">Ivan Akulov</a></p>\n<p>在做完优化应用体积之后的下一步提升应用加载时间的就是缓存。在客户端中使用缓存作为应用的一部分同时每一次减少重新下载。</p>\n<h3 id=\"Use-bundle-versioning-and-cache-headers-使用-bundle-版本和缓存头信息\"><a href=\"#Use-bundle-versioning-and-cache-headers-使用-bundle-版本和缓存头信息\" class=\"headerlink\" title=\"Use bundle versioning and cache headers 使用 bundle 版本和缓存头信息\"></a>Use bundle versioning and cache headers 使用 bundle 版本和缓存头信息</h3><p>做缓存通用的解决办法：</p>\n<ol>\n<li>告诉浏览器缓存一个文件很长时间（比如一年）</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Server header</span><br><span class=\"line\">Cache-Control: max-age=31536000</span><br></pre></td></tr></table></figure>\n<p>Note：如果你不熟悉 <code>Cache-Control</code>做了什么，你可以看一下Jake Archibald 的精彩博文 <a href=\"https://jakearchibald.com/2016/caching-best-practices/\" target=\"_blank\" rel=\"noopener\">on caching best practices</a></p>\n<p>2.当文件改变需要强制重新下载时候去重命名这些文件</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- Before the change --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"./index-v15.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- After the change --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"./index-v16.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这些方法告诉浏览器下载这些 JS 文件，缓存起来。浏览器将会只在文件名变化是才会请求网络（或者是缓存失效）。</p>\n<p>使用 webpack，你也可以做同样的事，但是是可以使用版本号来解决，你需要明确这个文件的 hash。使用 <a href=\"https://webpack.js.org/configuration/output/#output-filename\" target=\"_blank\" rel=\"noopener\"><code>[chunkhash]</code></a> 可以将 hash 值包含进文件名中：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack.config.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: <span class=\"string\">'./index.js'</span>,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    filename: <span class=\"string\">'bundle.[chunkhash].js'</span>,</span><br><span class=\"line\">        <span class=\"comment\">// → bundle.8e0d62a03.js</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Note: webpack 可能会生成不同的 hash 就是 bundle 相同 - 比如你重名了了一个文件或者重新在不同的操作系统下编译了一个 bundle。 <a href=\"https://github.com/webpack/webpack/issues/1479\" target=\"_blank\" rel=\"noopener\">This is a bug.</a><br>如果你需要将文件名发送给客户端，也可以使用 <code>HtmlWebpackPlugin</code> 或者 <code>WebpackManifestPlugin</code>。</p>\n</blockquote>\n<p><code>HtmlWebpackPlugin</code> 很简单，但是灵活性欠缺一些。编译时，插件会生成一个 HTML 文件，这其中包括所有的编译后的资源文件。如果你的业务逻辑不复杂，这就非常适合你：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- index.html --&gt;</span></span><br><span class=\"line\"><span class=\"meta\">&lt;!doctype html&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- ... --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"bundle.8e0d62a03.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><code>WebpackManifestPlugin</code>更灵活一些，它可以帮助你解决业务负责的部分。编译时它会生成一个 JSON 文件，这文件保存这没有 hash 值文件与有 hash 文件之间的映射。服务端利用这个 JSON 可以识别出那个文件有效：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// manifest.json</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"bundle.js\"</span>: <span class=\"string\">\"bundle.8e0d62a03.js\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Further-reading-4\"><a href=\"#Further-reading-4\" class=\"headerlink\" title=\"Further reading\"></a>Further reading</h4><ul>\n<li>Jake Archibald <a href=\"https://jakearchibald.com/2016/caching-best-practices/\" target=\"_blank\" rel=\"noopener\">about caching best practices</a></li>\n</ul>\n<h3 id=\"Extract-dependencies-and-runtime-into-a-separate-file-外部依赖和独立文件运行时\"><a href=\"#Extract-dependencies-and-runtime-into-a-separate-file-外部依赖和独立文件运行时\" class=\"headerlink\" title=\"Extract dependencies and runtime into a separate file 外部依赖和独立文件运行时\"></a>Extract dependencies and runtime into a separate file 外部依赖和独立文件运行时</h3><h4 id=\"Dependencies-依赖包\"><a href=\"#Dependencies-依赖包\" class=\"headerlink\" title=\"Dependencies 依赖包\"></a>Dependencies 依赖包</h4><p>App 依赖通常情况下趋向于比实际 app 内代码中更少的变化。如果你将他们移到独立的文件中，浏览器将可以把他们独立缓存起来 - 同时不会每次 app 代码改变时重新下载。</p>\n<blockquote>\n<p>Key Term: 在 webpack 的技术中，利用 app 代码拆分文件被称为 <code>chunks</code>。我们后面会用到这个名词。</p>\n</blockquote>\n<p>为了将依赖包提取到单独的 chunk 中，下面分为三步：</p>\n<ol>\n<li>使用<code>[name].[chunkname].js</code>替换<code>output</code>的文件名：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack.config.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Before</span></span><br><span class=\"line\">    filename: <span class=\"string\">'bundle.[chunkhash].js'</span>,</span><br><span class=\"line\">    <span class=\"comment\">// After</span></span><br><span class=\"line\">    filename: <span class=\"string\">'[name].[chunkhash].js'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>当 webpack 构建应用时，它会用一个带有 chunk 的名称来替换<code>[name]</code>。如果没有添加<code>[name]</code>部分，我们不得不通过 chunks 之间的 hash 区别来比较他们的区别 - 那就太难了！</p>\n<ol>\n<li>将<code>entry</code>转成一个对象：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack.config.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Before</span></span><br><span class=\"line\">  entry: <span class=\"string\">'./index.js'</span>,</span><br><span class=\"line\">  <span class=\"comment\">// After</span></span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    main: <span class=\"string\">'./index.js'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>在这段代码中，”main” 对象是一个 chunk 的名字。这个名字将会被步骤 1 里面的 <code>[name]</code>代替。目前为止，如果你构建一个 app，chunk 就会包括整个 app 的代码 - 就像我们没有做这些步骤一样。但是很快就会产生变化。</p>\n<ol>\n<li>添加  <a href=\"https://webpack.js.org/plugins/commons-chunk-plugin/\" target=\"_blank\" rel=\"noopener\"><code>CommonsChunkPlugin</code></a>：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack.config.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class=\"line\">      <span class=\"comment\">// A name of the chunk that will include the dependencies.</span></span><br><span class=\"line\">      <span class=\"comment\">// This name is substituted in place of [name] from step 1</span></span><br><span class=\"line\">      name: <span class=\"string\">'vendor'</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// A function that determines which modules to include into this chunk</span></span><br><span class=\"line\">      minChunks: <span class=\"function\"><span class=\"params\">module</span> =&gt;</span> <span class=\"built_in\">module</span>.context &amp;&amp;</span><br><span class=\"line\">        <span class=\"built_in\">module</span>.context.includes(<span class=\"string\">'node_modules'</span>),</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这个插件将包括全部<code>node_modules</code>路径下的 modules 同时将他们移到一个单独的文件中，这个文件被称为 <code>vendor.[chunkhash].js</code>。</p>\n<p>完成了上面的步骤，每一次 build 都将生成两个文件。浏览器会将他们单独缓存 - 以便代码该生改变时重新下载。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ webpack</span><br><span class=\"line\">Hash: ac01483e8fec1fa70676</span><br><span class=\"line\">Version: webpack 3.8.1</span><br><span class=\"line\">Time: 3816ms</span><br><span class=\"line\">                           Asset   Size  Chunks             Chunk Names</span><br><span class=\"line\">  ./main.00bab6fd3100008a42b0.js  82 kB       0  [emitted]  main</span><br><span class=\"line\">./vendor.d9e134771799ecdf9483.js  47 kB       1  [emitted]  vendor</span><br></pre></td></tr></table></figure>\n<h4 id=\"Webpack-runtime-code\"><a href=\"#Webpack-runtime-code\" class=\"headerlink\" title=\"Webpack runtime code\"></a>Webpack runtime code</h4><p>不幸的是，仅仅抽取<code>vendor</code>是不够的。如果你试图在应用代码中修改一些东西：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// index.js</span></span><br><span class=\"line\">…</span><br><span class=\"line\">…</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// E.g. add this:</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Wat'</span>);</span><br></pre></td></tr></table></figure>\n<p>你会注意到<code>vendor</code>的 hash 值也会改变：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">                           Asset   Size  Chunks             Chunk Names</span><br><span class=\"line\">./vendor.d9e134771799ecdf9483.js  47 kB       1  [emitted]  vendor</span><br></pre></td></tr></table></figure>\n<p>to</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">                            Asset   Size  Chunks             Chunk Names</span><br><span class=\"line\">./vendor.e6ea4504d61a1cc1c60b.js  47 kB       1  [emitted]  vendor</span><br></pre></td></tr></table></figure>\n<p>发生这样的事是因为 webpack 打包时，一部分 modules 的代码，拥有 <a href=\"https://webpack.js.org/concepts/manifest/\" target=\"_blank\" rel=\"noopener\"><em>a runtime</em></a> - 管理模块执行一部分代码。当你将代码拆分成多个文件时，这小部分代码在 chunk ids 和 匹配的文件之间开始了一个映射：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// vendor.e6ea4504d61a1cc1c60b.js</span></span><br><span class=\"line\">script.src = __webpack_require__.p + chunkId + <span class=\"string\">\".\"</span> + &#123;</span><br><span class=\"line\">  <span class=\"string\">\"0\"</span>: <span class=\"string\">\"2f2269c7f0a55a5c1871\"</span></span><br><span class=\"line\">&#125;[chunkId] + <span class=\"string\">\".js\"</span>;</span><br></pre></td></tr></table></figure>\n<p>Webpack 将最新生成的 chunk 包含了这个 runtime 内，这个 chunk 就是我们代码中的<code>vendor</code>。与此同时每一次任何 <code>chunk</code>的改变，这一小部分代码也改变，导致整个 <code>vendor</code> chunk 也改变、</p>\n<p>为了解决这个问题，我们将这个 runtime 转义到一个独立的文件中，通过<code>CommonsChunkPlugin</code>创建一个额外的空的 chunk：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack.config.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class=\"line\">      name: <span class=\"string\">'vendor'</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">      minChunks: <span class=\"function\"><span class=\"params\">module</span> =&gt;</span> <span class=\"built_in\">module</span>.context &amp;&amp;</span><br><span class=\"line\">        <span class=\"built_in\">module</span>.context.includes(<span class=\"string\">'node_modules'</span>),</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// This plugin must come after the vendor one (because webpack</span></span><br><span class=\"line\">    <span class=\"comment\">// includes runtime into the last chunk)</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class=\"line\">      name: <span class=\"string\">'runtime'</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// minChunks: Infinity means that no app modules</span></span><br><span class=\"line\">      <span class=\"comment\">// will be included into this chunk</span></span><br><span class=\"line\">      minChunks: <span class=\"literal\">Infinity</span>,</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>完成这一部分改变，每一次 build 都将生成三个文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ webpack</span><br><span class=\"line\">Hash: ac01483e8fec1fa70676</span><br><span class=\"line\">Version: webpack 3.8.1</span><br><span class=\"line\">Time: 3816ms</span><br><span class=\"line\">                            Asset     Size  Chunks             Chunk Names</span><br><span class=\"line\">   ./main.00bab6fd3100008a42b0.js    82 kB       0  [emitted]  main</span><br><span class=\"line\"> ./vendor.26886caf15818fa82dfa.js    46 kB       1  [emitted]  vendor</span><br><span class=\"line\">./runtime.79f17c27b335abc7aaf4.js  1.45 kB       3  [emitted]  runtime</span><br></pre></td></tr></table></figure>\n<p>将他们反过来顺序添加到 index.html 中，你就搞定了：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- index.html --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"./runtime.79f17c27b335abc7aaf4.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"./vendor.26886caf15818fa82dfa.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"./main.00bab6fd3100008a42b0.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"Further-reading-5\"><a href=\"#Further-reading-5\" class=\"headerlink\" title=\"Further reading\"></a>Further reading</h4><ul>\n<li>Webpack guide <a href=\"https://webpack.js.org/guides/caching/\" target=\"_blank\" rel=\"noopener\">on long term caching</a></li>\n<li>Webpack docs <a href=\"https://webpack.js.org/concepts/manifest/\" target=\"_blank\" rel=\"noopener\">about webpack runtime and manifest</a></li>\n<li><a href=\"https://medium.com/webpack/webpack-bits-getting-the-most-out-of-the-commonschunkplugin-ab389e5f318\" target=\"_blank\" rel=\"noopener\">“Getting the most out of the CommonsChunkPlugin”</a></li>\n</ul>\n<h3 id=\"Inline-webpack-runtime-to-save-an-extra-HTTP-request-内联-webpack-runtime-节省额外的-HTTP-请求\"><a href=\"#Inline-webpack-runtime-to-save-an-extra-HTTP-request-内联-webpack-runtime-节省额外的-HTTP-请求\" class=\"headerlink\" title=\"Inline webpack runtime to save an extra HTTP request 内联 webpack runtime 节省额外的 HTTP  请求\"></a>Inline webpack runtime to save an extra HTTP request 内联 webpack runtime 节省额外的 HTTP  请求</h3><p>为了做的更好，尽力把 webpack runtime 内联在 HTML 请求里。下面举例：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- index.html --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"./runtime.79f17c27b335abc7aaf4.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这样做：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- index.html --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">!<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">n</span>(<span class=\"params\">r</span>)</span>&#123;<span class=\"keyword\">if</span>(t[r])<span class=\"keyword\">return</span> t[r].exports;…&#125;&#125; ([]);</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这个 runtime 很小，内联它可以帮助你节省 HTTP 请求（尤其对 HTTP/1 重要；但是在 HTTP/2 就没有那么重要了，但是仍能够提高效率）。</p>\n<p>下面就来看看如何做。</p>\n<h4 id=\"如果使用-HtmlWebpackPlugin-来生成-HTML\"><a href=\"#如果使用-HtmlWebpackPlugin-来生成-HTML\" class=\"headerlink\" title=\"如果使用 HtmlWebpackPlugin 来生成 HTML\"></a>如果使用 HtmlWebpackPlugin 来生成 HTML</h4><p>如果使用 <a href=\"https://github.com/jantimon/html-webpack-plugin\" target=\"_blank\" rel=\"noopener\"><code>HtmlWebpackPlugin</code></a> 来生成 HTML 文件，<a href=\"https://github.com/rohitlodha/html-webpack-inline-chunk-plugin\" target=\"_blank\" rel=\"noopener\"><code>InlineChunkWebpackPlugin</code></a> 就足够了。</p>\n<h4 id=\"如果使用自己的定制服务逻辑来生成-HTML\"><a href=\"#如果使用自己的定制服务逻辑来生成-HTML\" class=\"headerlink\" title=\"如果使用自己的定制服务逻辑来生成 HTML\"></a>如果使用自己的定制服务逻辑来生成 HTML</h4><ol>\n<li>将 runtime 名称成静态明确的文件名：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack.config.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class=\"line\">      name: <span class=\"string\">'runtime'</span>,</span><br><span class=\"line\">      minChunks: <span class=\"literal\">Infinity</span>,</span><br><span class=\"line\">      filename: <span class=\"string\">'runtime.js'</span>,</span><br><span class=\"line\">        <span class=\"comment\">// → Now the runtime file will be called</span></span><br><span class=\"line\">        <span class=\"comment\">// “runtime.js”, not “runtime.79f17c27b335abc7aaf4.js”</span></span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>将方便的方式将 runtime.js 嵌入进去。比如：Node.js 和 Express</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// server.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> runtimeContent = fs.readFileSync(<span class=\"string\">'./runtime.js'</span>, <span class=\"string\">'utf-8'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(<span class=\"string\">'/'</span>, (req, res) =&gt; &#123;</span><br><span class=\"line\">  res.send(<span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">    …</span></span><br><span class=\"line\"><span class=\"string\">    &lt;script&gt;<span class=\"subst\">$&#123;runtimeContent&#125;</span>&lt;/script&gt;</span></span><br><span class=\"line\"><span class=\"string\">    …</span></span><br><span class=\"line\"><span class=\"string\">  `</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"懒加载\"><a href=\"#懒加载\" class=\"headerlink\" title=\"懒加载\"></a>懒加载</h3><p>有时候，页面拥有或多或少的部分：</p>\n<ul>\n<li>如果你在 YouTube 上加载一个视频页面，相比评论区域你更在乎视频区域。这就是视频要比评论区域重要。</li>\n<li>如果你在一个新闻网站打开一个报道，相比广告区域你更关心文章的内容。这就是文字比广告更重要。</li>\n</ul>\n<p>在这些案例中，通过仅下载最重要的部分，懒加载剩余区域能够提升最初的加载性能。使用 <a href=\"https://webpack.js.org/api/module-methods/#import-\" target=\"_blank\" rel=\"noopener\">the <code>import()</code> function</a> 和 <a href=\"https://webpack.js.org/guides/code-splitting/\" target=\"_blank\" rel=\"noopener\">code-splitting</a> 解决这个问题：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// videoPlayer.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">renderVideoPlayer</span>(<span class=\"params\"></span>) </span>&#123; … &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// comments.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">renderComments</span>(<span class=\"params\"></span>) </span>&#123; … &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// index.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;renderVideoPlayer&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./videoPlayer'</span>;</span><br><span class=\"line\">renderVideoPlayer();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// …Custom event listener</span></span><br><span class=\"line\">onShowCommentsClick(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">import</span>(<span class=\"string\">'./comments'</span>).then(<span class=\"function\">(<span class=\"params\">comments</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    comments.renderComments();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><code>import()</code>明确表示你期望动态地加载独立的 module。当 webpack 看到 <code>import(&#39;./module.js&#39;)</code>时，他就会将这个 module 移到独立的 chunk 中：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ webpack</span><br><span class=\"line\">Hash: 39b2a53cb4e73f0dc5b2</span><br><span class=\"line\">Version: webpack 3.8.1</span><br><span class=\"line\">Time: 4273ms</span><br><span class=\"line\">                            Asset     Size  Chunks             Chunk Names</span><br><span class=\"line\">      ./0.8ecaf182f5c85b7a8199.js  22.5 kB       0  [emitted]</span><br><span class=\"line\">   ./main.f7e53d8e13e9a2745d6d.js    60 kB       1  [emitted]  main</span><br><span class=\"line\"> ./vendor.4f14b6326a80f4752a98.js    46 kB       2  [emitted]  vendor</span><br><span class=\"line\">./runtime.79f17c27b335abc7aaf4.js  1.45 kB       3  [emitted]  runtime</span><br></pre></td></tr></table></figure>\n<p>并且只在代码执行到 <code>import()</code> 才会下载。</p>\n<p>这将会让 main bundle 更小，提升初始加载的时间。更重要的是改进缓存 - 如果你修改 main chunk 的代码，其他部分的 chunk 也不会受影响。</p>\n<blockquote>\n<p>Note: 如果使用 Babel 编译代码，你会因为 Babel 还不认识 <em>import()</em> 而遇到语法错误抛出来。可以使用 <a href=\"https://www.npmjs.com/package/babel-plugin-syntax-dynamic-import\" target=\"_blank\" rel=\"noopener\"><code>syntax-dynamic-import</code></a> 解决这个错误。</p>\n</blockquote>\n<h4 id=\"Further-reading-6\"><a href=\"#Further-reading-6\" class=\"headerlink\" title=\"Further reading\"></a>Further reading</h4><ul>\n<li>Webpack docs <a href=\"https://webpack.js.org/api/module-methods/#import-\" target=\"_blank\" rel=\"noopener\">for the <code>import()</code> function</a></li>\n<li>The JavaScript proposal <a href=\"https://github.com/tc39/proposal-dynamic-import\" target=\"_blank\" rel=\"noopener\">for implementing the <code>import()</code> syntax</a></li>\n</ul>\n<h3 id=\"Split-the-code-into-routes-and-pages-拆分代码到路由和页面中\"><a href=\"#Split-the-code-into-routes-and-pages-拆分代码到路由和页面中\" class=\"headerlink\" title=\"Split the code into routes and pages 拆分代码到路由和页面中\"></a>Split the code into routes and pages 拆分代码到路由和页面中</h3><p>如果你的应用拥有多个路由或者页面，但是代码中只有单独一个 JS 文件（一个单独的 main chunk），这看起来你正在每一个请求中节省额外的 bytes 带宽。举个例子，当用户正在访问你网站的首页：</p>\n<p><img src=\"https://img10.360buyimg.com/uba/jfs/t17272/291/466883786/44644/f5b82d7c/5a8159b0N4fe9f50d.png\" alt=\"site-home-page\"></p>\n<p>他们并不需要加载另外不同的页面上渲染文章标题的的代码 - 但是他们还是会加载到这段代码。更严重的是如果用户经常只访问首页，同时你还经常改变渲染文章标题的代码，webpack 将会对整个 bundle 失效 - 用户每次都会重复下载全部 app 的代码。</p>\n<p>如果我们将代码拆分到页面里（或者单页面应用的路由里），用户就会下载对他有意义的代码。更好的是，浏览器也会更好地缓存代码：当你改变首页的代码时，webpack 只会让相匹配的 chunk 失效。</p>\n<h4 id=\"For-single-page-apps-对于单页面应用\"><a href=\"#For-single-page-apps-对于单页面应用\" class=\"headerlink\" title=\"For single-page apps 对于单页面应用\"></a>For single-page apps 对于单页面应用</h4><p>通过路由拆分带页面引用，使用<code>import()</code>（看看 <a href=\"https://developers.google.com/web/fundamentals/performance/webpack/use-long-term-caching#lazy-loading\" target=\"_blank\" rel=\"noopener\">“Lazy-load code that you don’t need right now”</a>这部分）。如果你在使用一个框架，现在已经有成熟的方案：</p>\n<ul>\n<li><a href=\"https://reacttraining.com/react-router/web/guides/code-splitting\" target=\"_blank\" rel=\"noopener\">“Code Splitting”</a> in <code>react-router</code>‘s docs (for React)</li>\n<li><a href=\"https://router.vuejs.org/en/advanced/lazy-loading.html\" target=\"_blank\" rel=\"noopener\">“Lazy Loading Routes”</a> in <code>vue-router</code>‘s docs (for Vue.js)</li>\n</ul>\n<h4 id=\"For-traditional-multi-page-apps-对于传统的多页面应用\"><a href=\"#For-traditional-multi-page-apps-对于传统的多页面应用\" class=\"headerlink\" title=\"For traditional multi-page apps 对于传统的多页面应用\"></a>For traditional multi-page apps 对于传统的多页面应用</h4><p>通过页面拆分传统多页面应用，可以使用 webpack 的 <a href=\"https://webpack.js.org/concepts/entry-points/\" target=\"_blank\" rel=\"noopener\"><em>entry points</em></a> 。如果你的应用有三种页面：主页、文章页、用户账户页，那就分厂三个 entries：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack.config.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    home: <span class=\"string\">'./src/Home/index.js'</span>,</span><br><span class=\"line\">    article: <span class=\"string\">'./src/Article/index.js'</span>,</span><br><span class=\"line\">    profile: <span class=\"string\">'./src/Profile/index.js'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>对于每一个 entry 文件，webpack 将构建出独立的依赖树，并且声称一个 bundle，它将通过 entry 来只包括用到的 modules：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ webpack</span><br><span class=\"line\">Hash: 318d7b8490a7382bf23b</span><br><span class=\"line\">Version: webpack 3.8.1</span><br><span class=\"line\">Time: 4273ms</span><br><span class=\"line\">                            Asset     Size  Chunks             Chunk Names</span><br><span class=\"line\">      ./0.8ecaf182f5c85b7a8199.js  22.5 kB       0  [emitted]</span><br><span class=\"line\">   ./home.91b9ed27366fe7e33d6a.js    18 kB       1  [emitted]  home</span><br><span class=\"line\">./article.87a128755b16ac3294fd.js    32 kB       2  [emitted]  article</span><br><span class=\"line\">./profile.de945dc02685f6166781.js    24 kB       3  [emitted]  profile</span><br><span class=\"line\"> ./vendor.4f14b6326a80f4752a98.js    46 kB       4  [emitted]  vendor</span><br><span class=\"line\">./runtime.318d7b8490a7382bf23b.js  1.45 kB       5  [emitted]  runtime</span><br></pre></td></tr></table></figure>\n<p> 因此，如果仅仅是文章页使用<em>Lodash</em>，<em>home</em> 和 <em>profile</em> 的 bundle 将不会包含 lodash - 同时用户也不会在访问首页的时候下载到这个库。</p>\n<p>拆分依赖树也有缺点。如果两个 entry points 都用到了<em>loadash</em>，同时你没有在 <em>vendor</em> 移除掉依赖，两个 entry points 将包括两个重复的<em>lodash</em>。我们使用<a href=\"https://webpack.js.org/plugins/commons-chunk-plugin/\" target=\"_blank\" rel=\"noopener\"><code>CommonsChunkPlugin</code></a>解决这个问题 - 它会将通用的依赖转移到一个独立的文件中：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack.config.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class=\"line\">      <span class=\"comment\">// A name of the chunk that will include the common dependencies</span></span><br><span class=\"line\">      name: <span class=\"string\">'common'</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// The plugin will move a module into a common file</span></span><br><span class=\"line\">      <span class=\"comment\">// only if it’s included into `minChunks` chunks</span></span><br><span class=\"line\">      <span class=\"comment\">// (Note that the plugin analyzes all chunks, not only entries)</span></span><br><span class=\"line\">      minChunks: <span class=\"number\">2</span>,    <span class=\"comment\">// 2 is the default value</span></span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>随意使用<code>minChunks</code>的值来找到最优的选项。通常情况下，你想要它尽可能体积小，但它会增加 chunks 的数量。举个例子，3 个 chunk，<code>minChunks</code> 可能是 2 个，但是 30 个 chunk，它可能是 8 个 - 因为如果你把它设置成 2 ，过多的 modules 将会打包进一个通用文件中，文件更臃肿。</p>\n<h4 id=\"Further-reading-7\"><a href=\"#Further-reading-7\" class=\"headerlink\" title=\"Further reading\"></a>Further reading</h4><ul>\n<li>Webpack docs <a href=\"https://webpack.js.org/concepts/entry-points/\" target=\"_blank\" rel=\"noopener\">about the concept of entry points</a></li>\n<li>Webpack docs <a href=\"https://webpack.js.org/plugins/commons-chunk-plugin/\" target=\"_blank\" rel=\"noopener\">about the CommonsChunkPlugin</a></li>\n<li><a href=\"https://medium.com/webpack/webpack-bits-getting-the-most-out-of-the-commonschunkplugin-ab389e5f318\" target=\"_blank\" rel=\"noopener\">“Getting the most out of the CommonsChunkPlugin”</a></li>\n</ul>\n<h3 id=\"Make-module-ids-more-stable-让-module-ide-更稳定\"><a href=\"#Make-module-ids-more-stable-让-module-ide-更稳定\" class=\"headerlink\" title=\"Make module ids more stable 让 module ide 更稳定\"></a>Make module ids more stable 让 module ide 更稳定</h3><p>当编译代码时，webpack 会分配给每一个 module 一个 ID。之后，这些 ID 就会被<code>require()</code>引用到 bundle 内部。你可以在编译输出的右侧在 moudle 路径之前看到这些 ID：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ webpack</span><br><span class=\"line\">Hash: df3474e4f76528e3bbc9</span><br><span class=\"line\">Version: webpack 3.8.1</span><br><span class=\"line\">Time: 2150ms</span><br><span class=\"line\">                           Asset      Size  Chunks             Chunk Names</span><br><span class=\"line\">      ./0.8ecaf182f5c85b7a8199.js  22.5 kB       0  [emitted]</span><br><span class=\"line\">   ./main.4e50a16675574df6a9e9.js    60 kB       1  [emitted]  main</span><br><span class=\"line\"> ./vendor.26886caf15818fa82dfa.js    46 kB       2  [emitted]  vendor</span><br><span class=\"line\">./runtime.79f17c27b335abc7aaf4.js  1.45 kB       3  [emitted]  runtime</span><br></pre></td></tr></table></figure>\n<p>here</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[0] ./index.js 29 kB &#123;1&#125; [built]</span><br><span class=\"line\">[2] (webpack)/buildin/global.js 488 bytes &#123;2&#125; [built]</span><br><span class=\"line\">[3] (webpack)/buildin/module.js 495 bytes &#123;2&#125; [built]</span><br><span class=\"line\">[4] ./comments.js 58 kB &#123;0&#125; [built]</span><br><span class=\"line\">[5] ./ads.js 74 kB &#123;1&#125; [built]</span><br><span class=\"line\"> + 1 hidden module</span><br></pre></td></tr></table></figure>\n<p>默认情况下，这些 ID 是使用计数器计算出来的（比如第一个 module 是 ID 0，第二个 moudle 就是 ID 1，以此类推）。这样的问题就在于当你新增一个 module 事，它会出现在原来 module 列表中的中间，改变后面所有 module 的 ID：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ webpack</span><br><span class=\"line\">Hash: df3474e4f76528e3bbc9</span><br><span class=\"line\">Version: webpack 3.8.1</span><br><span class=\"line\">Time: 2150ms</span><br><span class=\"line\">                           Asset      Size  Chunks             Chunk Names</span><br><span class=\"line\">      ./0.5c82c0f337fcb22672b5.js    22 kB       0  [emitted]</span><br><span class=\"line\">   ./main.0c8b617dfc40c2827ae3.js    82 kB       1  [emitted]  main</span><br><span class=\"line\"> ./vendor.26886caf15818fa82dfa.js    46 kB       2  [emitted]  vendor</span><br><span class=\"line\">./runtime.79f17c27b335abc7aaf4.js  1.45 kB       3  [emitted]  runtime</span><br><span class=\"line\">   [0] ./index.js 29 kB &#123;1&#125; [built]</span><br><span class=\"line\">   [2] (webpack)/buildin/global.js 488 bytes &#123;2&#125; [built]</span><br><span class=\"line\">   [3] (webpack)/buildin/module.js 495 bytes &#123;2&#125; [built]</span><br></pre></td></tr></table></figure>\n<p>↓ 我们增加一个新 module</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[4] ./webPlayer.js 24 kB &#123;1&#125; [built]</span><br></pre></td></tr></table></figure>\n<p>↓ 现在看这里做了什么！<code>comments.js</code>现在的 ID 由 4 变成了 5</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[5] ./comments.js 58 kB &#123;0&#125; [built]</span><br></pre></td></tr></table></figure>\n<p>↓ <code>ads.js</code> 的 ID 由 5 变成 6</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[6] ./ads.js 74 kB &#123;1&#125; [built]</span><br><span class=\"line\">       + 1 hidden module</span><br></pre></td></tr></table></figure>\n<p>这将使包含或依赖于具有更改ID的模块的所有块无效 - 即使它们的实际代码没有更改。在我们的代码中，<em>0</em>这个 chunk 和 <em>main</em> chunk 都会失效 - 只有<em>main</em>才应该失效。</p>\n<p>使用<a href=\"https://webpack.js.org/plugins/hashed-module-ids-plugin/\" target=\"_blank\" rel=\"noopener\"><code>HashedModuleIdsPlugin</code></a>插件改变module ID 如何计算来解决这个问题。它利用 module 路径的 hash 来替换掉计数器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ webpack</span><br><span class=\"line\">Hash: df3474e4f76528e3bbc9</span><br><span class=\"line\">Version: webpack 3.8.1</span><br><span class=\"line\">Time: 2150ms</span><br><span class=\"line\">                           Asset      Size  Chunks             Chunk Names</span><br><span class=\"line\">      ./0.6168aaac8461862eab7a.js  22.5 kB       0  [emitted]</span><br><span class=\"line\">   ./main.a2e49a279552980e3b91.js    60 kB       1  [emitted]  main</span><br><span class=\"line\"> ./vendor.ff9f7ea865884e6a84c8.js    46 kB       2  [emitted]  vendor</span><br><span class=\"line\">./runtime.25f5d0204e4f77fa57a1.js  1.45 kB       3  [emitted]  runtime</span><br></pre></td></tr></table></figure>\n<p>↓ Here</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[3IRH] ./index.js 29 kB &#123;1&#125; [built]</span><br><span class=\"line\">[DuR2] (webpack)/buildin/global.js 488 bytes &#123;2&#125; [built]</span><br><span class=\"line\">[JkW7] (webpack)/buildin/module.js 495 bytes &#123;2&#125; [built]</span><br><span class=\"line\">[LbCc] ./webPlayer.js 24 kB &#123;1&#125; [built]</span><br><span class=\"line\">[lebJ] ./comments.js 58 kB &#123;0&#125; [built]</span><br><span class=\"line\">[02Tr] ./ads.js 74 kB &#123;1&#125; [built]</span><br><span class=\"line\">    + 1 hidden module</span><br></pre></td></tr></table></figure>\n<p>有了这个方法，只有你重命名护着删除这个 moudle 它的 ID 才会变化。新的 modules 不会因为 module ID 互相影响。</p>\n<p>启用这个插件，在配置中增加 <em>plugins</em>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack.config.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.HashedModuleIdsPlugin(),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Further-reading-8\"><a href=\"#Further-reading-8\" class=\"headerlink\" title=\"Further reading\"></a>Further reading</h4><ul>\n<li>Webpack docs <a href=\"https://webpack.js.org/plugins/hashed-module-ids-plugin/\" target=\"_blank\" rel=\"noopener\">about the HashedModuleIdsPlugin</a></li>\n</ul>\n<h3 id=\"Summing-up\"><a href=\"#Summing-up\" class=\"headerlink\" title=\"Summing up\"></a>Summing up</h3><ul>\n<li>Cache the bundle and differentiate between them by changing their names</li>\n<li>Split the bundle into app code, vendor code and runtime</li>\n<li>Inline the runtime to save an HTTP request</li>\n<li>Lazy-load non-critical code with <code>import</code></li>\n<li>Split code by routes/pages to avoid loading unnecessary stuff</li>\n</ul>\n<p>===</p>\n<h2 id=\"Monitor-and-analyze-the-app-监控并分析\"><a href=\"#Monitor-and-analyze-the-app-监控并分析\" class=\"headerlink\" title=\"Monitor and analyze the app 监控并分析\"></a>Monitor and analyze the app 监控并分析</h2><p>作者 <a href=\"https://developers.google.com/web/resources/contributors/iamakulov\" target=\"_blank\" rel=\"noopener\">Ivan Akulov</a></p>\n<p>即使当你配置好你的 webpack 让你的引用尽可能体积较小的时候，跟踪这个应用就非常重要，同时了解里面包含了什么。除此之外，你安装一个依赖，它将让你的 app 增加两倍大小 - 但并没有注意到这个问题！</p>\n<p>这一部分就来讲解一些能够帮助你理解你的 bundle 的工具。</p>\n<h3 id=\"Keep-track-of-the-bundle-size-跟踪打包的体积\"><a href=\"#Keep-track-of-the-bundle-size-跟踪打包的体积\" class=\"headerlink\" title=\"Keep track of the bundle size 跟踪打包的体积\"></a>Keep track of the bundle size 跟踪打包的体积</h3><p>在开发时可以使用<a href=\"https://github.com/FormidableLabs/webpack-dashboard/\" target=\"_blank\" rel=\"noopener\">webpack-dashboard</a>和命令行<a href=\"https://github.com/siddharthkp/bundlesize\" target=\"_blank\" rel=\"noopener\">bundlesize</a> 来监控 app 的体积。</p>\n<h4 id=\"webpack-dashboard\"><a href=\"#webpack-dashboard\" class=\"headerlink\" title=\"webpack-dashboard\"></a>webpack-dashboard</h4><p><a href=\"https://github.com/FormidableLabs/webpack-dashboard/\" target=\"_blank\" rel=\"noopener\">webpack-dashboard</a>可以通过依赖体积大小、进程和其他细节来改进 webpack 的输出。</p>\n<p><img src=\"http://img30.360buyimg.com/uba/jfs/t16294/169/2125639991/38263/ad862ba/5a8159c0N0da38a60.png\" alt=\"webpack-dashboard\"></p>\n<p>这个 dashborad 帮助我们跟踪大型依赖 - 如果你增加一个依赖，你就立刻能在 Modules section 始终看到它！</p>\n<p>启用这个功能，需要安装 <em>webpack-dashboard</em> 包：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install webpack-dashboard --save-dev</span><br></pre></td></tr></table></figure>\n<p> 同时在配置的 plugins 增加：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack.config.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> DashboardPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack-dashboard/plugin'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> DashboardPlugin(),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>或者如果正在使用基于 Express dev server 可以使用 <code>compiler.apply()</code>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compiler.apply(new DashboardPlugin());</span><br></pre></td></tr></table></figure>\n<p>多尝试 dashboard 找出改进的地方！比如，在 modules section 滚动找到那个库体积过大，把它替换成小的可替代的库。</p>\n<h4 id=\"bundlesize\"><a href=\"#bundlesize\" class=\"headerlink\" title=\"bundlesize\"></a>bundlesize</h4><p><a href=\"https://github.com/siddharthkp/bundlesize\" target=\"_blank\" rel=\"noopener\">bundlesize</a> 可以验证 webpack assets 不超过指定的大小。通过自动化 CI 就可以知晓 app 是否变的过于臃肿：</p>\n<p><img src=\"https://img30.360buyimg.com/uba/jfs/t15808/165/2111159728/110001/633e93ab/5a8159cdN1c575a1f.jpg\" alt=\"bundlesize\"></p>\n<p>配置如下：</p>\n<h5 id=\"Find-out-the-maximum-sizes-找出最大体积\"><a href=\"#Find-out-the-maximum-sizes-找出最大体积\" class=\"headerlink\" title=\"Find out the maximum sizes 找出最大体积\"></a><strong>Find out the maximum sizes</strong> 找出最大体积</h5><ol>\n<li>分析 app 尽可能减小体积，执行生产环境的 build。</li>\n<li>在<code>package.json</code>中增加<code>bundlesize</code>部分：</li>\n</ol>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// package.json</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"bundlesize\"</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"path\"</span>: <span class=\"string\">\"./dist/*\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>使用<code>npx</code>执行<code>bundlesize</code>：</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx bundlesize</span><br></pre></td></tr></table></figure>\n<p>它就会将每一个文件的 gzip 压缩后的体积打印出来：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PASS  ./dist/icon256.6168aaac8461862eab7a.png:  10.89KB PASS./dist/icon512.c3e073a4100bd0c28a86.png:  13.1KB PASS./dist/main.0c8b617dfc40c2827ae3.js:  16.28KB PASS./dist/vendor.ff9f7ea865884e6a84c8.js:  31.49KB</span><br></pre></td></tr></table></figure>\n<ol>\n<li>每一个体积增加10-20%，你将得到最大体积。这个10-20％的幅度可以让你像往常一样开发应用程序，同时警告你，当它的大小增长太多。</li>\n</ol>\n<h5 id=\"Enable-bundlesize-启用-bundlesize\"><a href=\"#Enable-bundlesize-启用-bundlesize\" class=\"headerlink\" title=\"Enable bundlesize 启用 bundlesize\"></a><strong>Enable <code>bundlesize</code></strong> 启用 bundlesize</h5><p>5.安装<em>bundlesize</em>开发依赖</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install bundlesize --save-dev</span><br></pre></td></tr></table></figure>\n<p>6.在<code>package.json</code>中的<code>bundlesize</code>部分，声明具体的最大值。对于某一些文件（比如图片），你可以单独根据文件类型来设置最大体积大小，而不需要根据每一个文件：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// package.json</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"bundlesize\"</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"path\"</span>: <span class=\"string\">\"./dist/*.png\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"maxSize\"</span>: <span class=\"string\">\"16 kB\"</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"path\"</span>: <span class=\"string\">\"./dist/main.*.js\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"maxSize\"</span>: <span class=\"string\">\"20 kB\"</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"path\"</span>: <span class=\"string\">\"./dist/vendor.*.js\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"maxSize\"</span>: <span class=\"string\">\"35 kB\"</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>7.增加一个 npm 脚本来执行检查：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// package.json</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"check-size\"</span>: <span class=\"string\">\"bundlesize\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>8.配置自动化 CI 来在每一次 push 时执行<code>npm run check-size</code>做检查。（如果你在 Github 上开发项目，直接可以使用<a href=\"https://github.com/siddharthkp/bundlesize#2-build-status\" target=\"_blank\" rel=\"noopener\">integrate <code>bundlesize</code> with GitHub</a>。）</p>\n<p>这就全部了！现在如果你运行<code>npm run check-size</code>或者 push 代码，你就会看到输出的文件是否足够小：</p>\n<p><img src=\"https://img14.360buyimg.com/uba/jfs/t14890/146/2205111432/17457/fa7f748a/5a8159dcN17378d16.png\" alt=\"bundlesize-output-success\"></p>\n<p>或者下面失败的情况</p>\n<p><img src=\"https://img11.360buyimg.com/uba/jfs/t16969/198/453213154/26368/834a1c7f/5a8159e8Nc1f5ffe8.png\" alt=\"bundlesize-output-failure\"></p>\n<h4 id=\"Further-reading-9\"><a href=\"#Further-reading-9\" class=\"headerlink\" title=\"Further reading\"></a>Further reading</h4><ul>\n<li>Alex Russell <a href=\"https://infrequently.org/2017/10/can-you-afford-it-real-world-web-performance-budgets/\" target=\"_blank\" rel=\"noopener\">about the real-world loading time we should target</a></li>\n</ul>\n<h3 id=\"Analyze-why-the-bundle-is-so-large-分析-bundle-为什么这么大\"><a href=\"#Analyze-why-the-bundle-is-so-large-分析-bundle-为什么这么大\" class=\"headerlink\" title=\"Analyze why the bundle is so large 分析 bundle 为什么这么大\"></a>Analyze why the bundle is so large 分析 bundle 为什么这么大</h3><p>你想要深挖 bundle 内，看看里面具体哪些 module 占用多大空间。<a href=\"https://github.com/webpack-contrib/webpack-bundle-analyzer\" target=\"_blank\" rel=\"noopener\">webpack-bundle-analyzer</a></p>\n<p>(Screen recording from <a href=\"https://github.com/webpack-contrib/webpack-bundle-analyzer\" target=\"_blank\" rel=\"noopener\">github.com/webpack-contrib/webpack -bundle-analyzer</a>)</p>\n<p>webpack-bundle-analyzer 可以扫描 bundle 同时构建一个查看内部的可视化窗口。使用这个可视化工具找到过大或者不必要的依赖。</p>\n<p>使用这个分析器，需要安装<code>webpack-bundle-analyzer</code>包：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install webpack-bundle-analyzer --save-dev</span><br></pre></td></tr></table></figure>\n<p>在 config 中增加插件：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack.config.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> BundleAnalyzerPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack-bundle-analyzer'</span>).BundleAnalyzerPlugin;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> BundleAnalyzerPlugin(),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>运行生产环境的 build。这个插件就会在浏览器中打开一个显示状态的页面。</p>\n<p>默认情况下，这个页面会显示语法分析后的文件体积（在 bundle 出现的文件）。您可能想比较 gzip 的大小，因为这更接近实际用户的体验；使用左边的边栏来切换尺寸。</p>\n<blockquote>\n<p>Note: 如果你使用 <a href=\"https://webpack.js.org/plugins/module-concatenation-plugin/\" target=\"_blank\" rel=\"noopener\">ModuleConcatenationPlugin</a>，它可能在webpack-bundle-analyzer输出时合并一部分 module，使得报告小一些细节。如果你使用这个插件，在执行分析的时候需要禁用掉。</p>\n</blockquote>\n<p>下面是报告中需要看什么：</p>\n<ul>\n<li><strong>大型依赖</strong> 为什么体积这么大？是否有更小的替代包（比如 Preact 替代 React）？用了全部代码（比如 Moment.js 包含大量的本地变量 <a href=\"https://github.com/GoogleChromeLabs/webpack-libs-optimizations#moment\" target=\"_blank\" rel=\"noopener\">that are often not used and could be dropped</a>）？</li>\n<li><strong>重复依赖</strong> 是否在不同文件中看到相同的库？（使用<em>CommonsChunkPlugin</em>将他们移到一个通用文件内）亦或是在同一个库中 bundle 拥有多个版本？</li>\n<li><strong>相似依赖</strong> 是否存在有相似功能的相似库存在？（比如<em>moment</em>和<em>date-fns</em> 或者 <em>lodash</em> 和 <em>lodash-es</em>）尽力汇总成一个。</li>\n</ul>\n<p>同样的，也可以看看 Sean Larkin 的文章 <a href=\"https://medium.com/webpack/webpack-bits-getting-the-most-out-of-the-commonschunkplugin-ab389e5f318\" target=\"_blank\" rel=\"noopener\">great analysis of webpack bundles</a>。</p>\n<h3 id=\"Summing-up-1\"><a href=\"#Summing-up-1\" class=\"headerlink\" title=\"Summing up\"></a>Summing up</h3><ul>\n<li>Use <code>webpack-dashboard</code> and <code>bundlesize</code> to stay tuned of how large your app is</li>\n<li>Dig into what builds up the size with <code>webpack-bundle-analyzer</code></li>\n</ul>\n<p>===</p>\n<h2 id=\"Conclusion结尾\"><a href=\"#Conclusion结尾\" class=\"headerlink\" title=\"Conclusion结尾\"></a>Conclusion结尾</h2><p>总结一下：</p>\n<ul>\n<li><strong>剔除不必要的体积</strong> 把所有的都压缩，剔除无用代码，增加依赖是保持谨慎小心。</li>\n<li><strong>通过路由拆分代码</strong> 只在真正需要的时候才加载，其他的部分做来加载。</li>\n<li><strong>缓存代码</strong> 应用程序的某些部分更新频率低于其他部分，将这些部分拆分成文件，以便在必要时仅重新下载。</li>\n<li><strong>跟踪体积大小</strong> 使用  <a href=\"https://github.com/FormidableLabs/webpack-dashboard/\" target=\"_blank\" rel=\"noopener\">webpack-dashboard</a> 和 <a href=\"https://github.com/webpack-contrib/webpack-bundle-analyzer\" target=\"_blank\" rel=\"noopener\">webpack-bundle-analyzer</a> 监控你的 app。每隔几个月重新检查一下你的应用的性能。</li>\n</ul>\n<p>Webpack 不仅仅是一个帮助你创建 app 更快的工具。它还帮助是你的 app 成为 <a href=\"https://developers.google.com/web/progressive-web-apps/\" target=\"_blank\" rel=\"noopener\">a Progressive Web App</a> ，你的引用拥有更好的体检自动化的填充工具就像<a href=\"https://developers.google.com/web/tools/lighthouse/\" target=\"_blank\" rel=\"noopener\">Lighthouse</a>根据环境给出建议。</p>\n<p>不要忘记阅读 <a href=\"https://webpack.js.org/guides/\" target=\"_blank\" rel=\"noopener\">webpack docs</a> - 里面提供了大量的优化的信息。</p>\n<p>记得练习一下 <a href=\"https://github.com/GoogleChromeLabs/webpack-training-project\" target=\"_blank\" rel=\"noopener\">with the training app</a>！</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjc31n1ea0000gey5yi0ahi6e","category_id":"cjc31n1el0004gey5tqbofl0m","_id":"cjc31n1ex000egey5jtmhor7s"},{"post_id":"cjc31n1er0009gey51eklzi4e","category_id":"cjc31n1el0004gey5tqbofl0m","_id":"cjc31n1ez000igey5y6rjvknr"},{"post_id":"cjc31n1eu000cgey5zlfhofq1","category_id":"cjc31n1el0004gey5tqbofl0m","_id":"cjc31n1f2000lgey5g5af92m7"},{"post_id":"cjc31n1ei0002gey5j52jjhbu","category_id":"cjc31n1et000agey5f9i8mgg2","_id":"cjc31n1f4000pgey5wc31nz36"},{"post_id":"cjc31n1em0006gey5st931zla","category_id":"cjc31n1el0004gey5tqbofl0m","_id":"cjc31n1f7000sgey5u3a725aw"},{"post_id":"cjc31n1f1000kgey5v1qy7czf","category_id":"cjc31n1f5000qgey5t5cxo51j","_id":"cjc31n1ff0010gey5j7dst4cn"},{"post_id":"cjc31n1fa000vgey5onf8z0ii","category_id":"cjc31n1el0004gey5tqbofl0m","_id":"cjc31n1fg0013gey59ytehtvl"},{"post_id":"cjc31n1fc000xgey5pzl35b66","category_id":"cjc31n1el0004gey5tqbofl0m","_id":"cjc31n1fh0017gey5uk1931aj"},{"post_id":"cjc31n1fe000zgey58u4mfkz0","category_id":"cjc31n1el0004gey5tqbofl0m","_id":"cjc31n1fi001agey5k0391b3m"},{"post_id":"cjc31n1ff0012gey5mi8k7fjw","category_id":"cjc31n1el0004gey5tqbofl0m","_id":"cjc31n1fk001egey529ezvin1"},{"post_id":"cjc31n1fg0016gey56z0bvzl7","category_id":"cjc31n1el0004gey5tqbofl0m","_id":"cjc31n1fn001ggey5r8bghfng"},{"post_id":"cjc31n1fh0019gey5pzi6k7vl","category_id":"cjc31n1el0004gey5tqbofl0m","_id":"cjc31n1fp001jgey51dw0s7uw"},{"post_id":"cjc31n1fj001dgey55m4qdzs5","category_id":"cjc31n1el0004gey5tqbofl0m","_id":"cjc31n1fr001mgey5b3009e3y"},{"post_id":"cjc31n1fl001fgey52kocxmz1","category_id":"cjc31n1el0004gey5tqbofl0m","_id":"cjc31n1fs001qgey5lmmimd1p"},{"post_id":"cjc31n1fo001igey5skgjsen2","category_id":"cjc31n1el0004gey5tqbofl0m","_id":"cjc31n1fv001tgey5rsn6fc6d"},{"post_id":"cjc31n1fq001lgey5eiyurgff","category_id":"cjc31n1el0004gey5tqbofl0m","_id":"cjc31n1fy001ygey5v4ttc3e1"},{"post_id":"cjc31n1fx001xgey5egw9iual","category_id":"cjc31n1el0004gey5tqbofl0m","_id":"cjc31n1g30026gey51d3lu5xk"},{"post_id":"cjc31n1fs001pgey5fs7578kt","category_id":"cjc31n1fx001vgey5ln1v6e3r","_id":"cjc31n1g50028gey5w9len3jr"},{"post_id":"cjc31n1g00021gey54kvcej04","category_id":"cjc31n1fx001vgey5ln1v6e3r","_id":"cjc31n1g8002cgey57ruzemmx"},{"post_id":"cjc31n1g20025gey58lvghweo","category_id":"cjc31n1f5000qgey5t5cxo51j","_id":"cjc31n1g9002egey5mnpmaw3e"},{"post_id":"cjc31n1fu001sgey56cwdwn1j","category_id":"cjc31n1fx001vgey5ln1v6e3r","_id":"cjc31n1g9002ggey5o988cunw"},{"post_id":"cjc31n1g5002bgey526y0oofd","category_id":"cjc31n1f5000qgey5t5cxo51j","_id":"cjc31n1g9002hgey5h4sjt2wi"}],"PostTag":[{"post_id":"cjc31n1ea0000gey5yi0ahi6e","tag_id":"cjc31n1em0005gey57zb1g35f","_id":"cjc31n1f0000jgey5po41pfma"},{"post_id":"cjc31n1ea0000gey5yi0ahi6e","tag_id":"cjc31n1et000bgey5z0ndj30u","_id":"cjc31n1f2000mgey530mpqzll"},{"post_id":"cjc31n1ei0002gey5j52jjhbu","tag_id":"cjc31n1ex000ggey5758w7sfi","_id":"cjc31n1fd000ygey5nkioza0m"},{"post_id":"cjc31n1ei0002gey5j52jjhbu","tag_id":"cjc31n1et000bgey5z0ndj30u","_id":"cjc31n1ff0011gey5ueuzsa8u"},{"post_id":"cjc31n1ei0002gey5j52jjhbu","tag_id":"cjc31n1f8000tgey5vqk5bzxc","_id":"cjc31n1fg0015gey5yrj8pykk"},{"post_id":"cjc31n1fe000zgey58u4mfkz0","tag_id":"cjc31n1em0005gey57zb1g35f","_id":"cjc31n1fh0018gey53cb5pl9x"},{"post_id":"cjc31n1fe000zgey58u4mfkz0","tag_id":"cjc31n1et000bgey5z0ndj30u","_id":"cjc31n1fj001cgey5zw9wtdj7"},{"post_id":"cjc31n1em0006gey5st931zla","tag_id":"cjc31n1fb000wgey5cdxscvtr","_id":"cjc31n1fq001kgey5z1wg61va"},{"post_id":"cjc31n1em0006gey5st931zla","tag_id":"cjc31n1fg0014gey54c0k0czg","_id":"cjc31n1fr001ngey5nlqw8fe8"},{"post_id":"cjc31n1em0006gey5st931zla","tag_id":"cjc31n1fi001bgey56jm2fabp","_id":"cjc31n1ft001rgey5gowrtwpo"},{"post_id":"cjc31n1eq0008gey5mt8wtog6","tag_id":"cjc31n1fb000wgey5cdxscvtr","_id":"cjc31n1fx001ugey5r6kunhea"},{"post_id":"cjc31n1er0009gey51eklzi4e","tag_id":"cjc31n1fr001ogey5t6nphfv1","_id":"cjc31n1fy001zgey58ze3zzvc"},{"post_id":"cjc31n1eu000cgey5zlfhofq1","tag_id":"cjc31n1fx001wgey5pcxmuoip","_id":"cjc31n1g20024gey5v3axuw90"},{"post_id":"cjc31n1ew000dgey59jqnk1cm","tag_id":"cjc31n1fx001wgey5pcxmuoip","_id":"cjc31n1g5002agey5h7mjmxky"},{"post_id":"cjc31n1g40027gey5uuj4w00t","tag_id":"cjc31n1f8000tgey5vqk5bzxc","_id":"cjc31n1g8002dgey5gvhnuycs"},{"post_id":"cjc31n1ez000hgey572ou0oc2","tag_id":"cjc31n1et000bgey5z0ndj30u","_id":"cjc31n1ga002jgey5hkx7epgd"},{"post_id":"cjc31n1ez000hgey572ou0oc2","tag_id":"cjc31n1g50029gey5uptsdwyd","_id":"cjc31n1gb002kgey55f7cu6r5"},{"post_id":"cjc31n1ez000hgey572ou0oc2","tag_id":"cjc31n1g9002fgey55ykpbx55","_id":"cjc31n1gc002mgey5c8fmt3b9"},{"post_id":"cjc31n1f1000kgey5v1qy7czf","tag_id":"cjc31n1fb000wgey5cdxscvtr","_id":"cjc31n1gc002ngey5rqgfabiy"},{"post_id":"cjc31n1f3000ogey5oha8zaj5","tag_id":"cjc31n1gb002lgey5vx2rf85u","_id":"cjc31n1gc002pgey5l0emhqk9"},{"post_id":"cjc31n1f5000rgey5lwjawvna","tag_id":"cjc31n1gc002ogey5tuqyesdi","_id":"cjc31n1gc002rgey5k4sv2aok"},{"post_id":"cjc31n1fc000xgey5pzl35b66","tag_id":"cjc31n1gc002ogey5tuqyesdi","_id":"cjc31n1gd002tgey5z6hepygy"},{"post_id":"cjc31n1ff0012gey5mi8k7fjw","tag_id":"cjc31n1gc002sgey5g1sn281s","_id":"cjc31n1ge002wgey5jpj4rc1g"},{"post_id":"cjc31n1ff0012gey5mi8k7fjw","tag_id":"cjc31n1gd002ugey5btvo0ecg","_id":"cjc31n1ge002xgey56ybbqowh"},{"post_id":"cjc31n1fg0016gey56z0bvzl7","tag_id":"cjc31n1gc002ogey5tuqyesdi","_id":"cjc31n1ge002zgey5xcbzzwau"},{"post_id":"cjc31n1fh0019gey5pzi6k7vl","tag_id":"cjc31n1ge002ygey5alujwcdw","_id":"cjc31n1ge0031gey533gpoe10"},{"post_id":"cjc31n1fh0019gey5pzi6k7vl","tag_id":"cjc31n1ex000ggey5758w7sfi","_id":"cjc31n1ge0032gey5f4yckg1t"},{"post_id":"cjc31n1fj001dgey55m4qdzs5","tag_id":"cjc31n1ge0030gey5vy23vgk8","_id":"cjc31n1gf0035gey5285lmm6h"},{"post_id":"cjc31n1fj001dgey55m4qdzs5","tag_id":"cjc31n1gd002ugey5btvo0ecg","_id":"cjc31n1gf0036gey5np8nvg2b"},{"post_id":"cjc31n1fl001fgey52kocxmz1","tag_id":"cjc31n1gf0034gey52jus3yml","_id":"cjc31n1gf0039gey5jrdtz4yt"},{"post_id":"cjc31n1fl001fgey52kocxmz1","tag_id":"cjc31n1gf0037gey54c9cbt6p","_id":"cjc31n1gf003agey5wt80k3un"},{"post_id":"cjc31n1fo001igey5skgjsen2","tag_id":"cjc31n1gf0038gey5z5ba62iy","_id":"cjc31n1gg003cgey56uj1gm6q"},{"post_id":"cjc31n1fo001igey5skgjsen2","tag_id":"cjc31n1f8000tgey5vqk5bzxc","_id":"cjc31n1gg003dgey58dxqz2e9"},{"post_id":"cjc31n1fq001lgey5eiyurgff","tag_id":"cjc31n1gg003bgey5tc3n5eom","_id":"cjc31n1gg003ggey5vhr75jsa"},{"post_id":"cjc31n1fq001lgey5eiyurgff","tag_id":"cjc31n1gg003egey5kyfi2vva","_id":"cjc31n1gg003hgey52y87exke"},{"post_id":"cjc31n1fs001pgey5fs7578kt","tag_id":"cjc31n1gg003fgey5oho9dhb1","_id":"cjc31n1gg003jgey5nom3hqww"},{"post_id":"cjc31n1fu001sgey56cwdwn1j","tag_id":"cjc31n1fb000wgey5cdxscvtr","_id":"cjc31n1gh003mgey5dpmz5trc"},{"post_id":"cjc31n1fu001sgey56cwdwn1j","tag_id":"cjc31n1gg003igey5yr6xz6uf","_id":"cjc31n1gh003ngey5m8tj3mds"},{"post_id":"cjc31n1fu001sgey56cwdwn1j","tag_id":"cjc31n1gg003kgey59ft45tf7","_id":"cjc31n1gi003pgey5w7lfx1av"},{"post_id":"cjc31n1fu001sgey56cwdwn1j","tag_id":"cjc31n1fr001ogey5t6nphfv1","_id":"cjc31n1gi003qgey5c1lvf902"},{"post_id":"cjc31n1fx001xgey5egw9iual","tag_id":"cjc31n1gh003lgey572rqhitu","_id":"cjc31n1gj003sgey54kcpgz1m"},{"post_id":"cjc31n1fz0020gey5ngd1bxi3","tag_id":"cjc31n1gh003lgey572rqhitu","_id":"cjc31n1gj003tgey5whvlx05o"},{"post_id":"cjc31n1g00021gey54kvcej04","tag_id":"cjc31n1fb000wgey5cdxscvtr","_id":"cjc31n1gj003wgey5q1wj1hj7"},{"post_id":"cjc31n1g00021gey54kvcej04","tag_id":"cjc31n1gi003rgey5hsed0a44","_id":"cjc31n1gk003xgey5siiymkei"},{"post_id":"cjc31n1g00021gey54kvcej04","tag_id":"cjc31n1gj003ugey543atls6p","_id":"cjc31n1gk003zgey5z56zktvn"},{"post_id":"cjc31n1g00021gey54kvcej04","tag_id":"cjc31n1fr001ogey5t6nphfv1","_id":"cjc31n1gk0040gey5vdyj5wju"},{"post_id":"cjc31n1g20025gey58lvghweo","tag_id":"cjc31n1gj003vgey5wqzvrnhu","_id":"cjc31n1gk0042gey5q43050ya"},{"post_id":"cjc31n1g20025gey58lvghweo","tag_id":"cjc31n1gk003ygey5r71r4rwz","_id":"cjc31n1gk0043gey59hz55x35"},{"post_id":"cjc31n1g5002bgey526y0oofd","tag_id":"cjc31n1gj003vgey5wqzvrnhu","_id":"cjc31n1gk0044gey50zoj0xti"},{"post_id":"cjc31n1g5002bgey526y0oofd","tag_id":"cjc31n1fb000wgey5cdxscvtr","_id":"cjc31n1gk0045gey5nm0fj0db"},{"post_id":"cjc31n1g5002bgey526y0oofd","tag_id":"cjc31n1fr001ogey5t6nphfv1","_id":"cjc31n1gk0046gey5btp8a2fo"}],"Tag":[{"name":"文字","_id":"cjc31n1em0005gey57zb1g35f"},{"name":"生活","_id":"cjc31n1et000bgey5z0ndj30u"},{"name":"数码","_id":"cjc31n1ex000ggey5758w7sfi"},{"name":"Mac","_id":"cjc31n1f8000tgey5vqk5bzxc"},{"name":"Javascript","_id":"cjc31n1fb000wgey5cdxscvtr"},{"name":"jQuery","_id":"cjc31n1fg0014gey54c0k0czg"},{"name":"技术","_id":"cjc31n1fi001bgey56jm2fabp"},{"name":"Front-End","_id":"cjc31n1fr001ogey5t6nphfv1"},{"name":"Life","_id":"cjc31n1fx001wgey5pcxmuoip"},{"name":"工作","_id":"cjc31n1g50029gey5uptsdwyd"},{"name":"新年计划","_id":"cjc31n1g9002fgey55ykpbx55"},{"name":"linux","_id":"cjc31n1gb002lgey5vx2rf85u"},{"name":"reading","_id":"cjc31n1gc002ogey5tuqyesdi"},{"name":"分享","_id":"cjc31n1gc002sgey5g1sn281s"},{"name":"总结","_id":"cjc31n1gd002ugey5btvo0ecg"},{"name":"digital","_id":"cjc31n1ge002ygey5alujwcdw"},{"name":"Java","_id":"cjc31n1ge0030gey5vy23vgk8"},{"name":"Apple","_id":"cjc31n1gf0034gey52jus3yml"},{"name":"Swift","_id":"cjc31n1gf0037gey54c9cbt6p"},{"name":"Tool","_id":"cjc31n1gf0038gey5z5ba62iy"},{"name":"VPN","_id":"cjc31n1gg003bgey5tc3n5eom"},{"name":"Share","_id":"cjc31n1gg003egey5kyfi2vva"},{"name":"note","_id":"cjc31n1gg003fgey5oho9dhb1"},{"name":"HTML","_id":"cjc31n1gg003igey5yr6xz6uf"},{"name":"CSS","_id":"cjc31n1gg003kgey59ft45tf7"},{"name":"life","_id":"cjc31n1gh003lgey572rqhitu"},{"name":"ReractJS","_id":"cjc31n1gi003rgey5hsed0a44"},{"name":"NodeJS","_id":"cjc31n1gj003ugey543atls6p"},{"name":"翻译","_id":"cjc31n1gj003vgey5wqzvrnhu"},{"name":"英语学习","_id":"cjc31n1gk003ygey5r71r4rwz"}]}}